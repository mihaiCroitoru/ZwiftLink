/// Generated by the Protocol Buffers 3.5.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "zwiftMessages.proto"
/// Syntax "Proto3"

// The PlayerState class should hold the info we're interested in

import Foundation
import ProtocolBuffers
import SwiftProtobuf


public struct ZwiftMessagesRoot {
    public static let `default` = ZwiftMessagesRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class PlayerState : GeneratedMessage {
    public typealias BuilderType = PlayerState.Builder

    public static func == (lhs: PlayerState, rhs: PlayerState) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasWorldTime == rhs.hasWorldTime) && (!lhs.hasWorldTime || lhs.worldTime == rhs.worldTime)
        fieldCheck = fieldCheck && (lhs.hasDistance == rhs.hasDistance) && (!lhs.hasDistance || lhs.distance == rhs.distance)
        fieldCheck = fieldCheck && (lhs.hasRoadTime == rhs.hasRoadTime) && (!lhs.hasRoadTime || lhs.roadTime == rhs.roadTime)
        fieldCheck = fieldCheck && (lhs.hasLaps == rhs.hasLaps) && (!lhs.hasLaps || lhs.laps == rhs.laps)
        fieldCheck = fieldCheck && (lhs.hasSpeed == rhs.hasSpeed) && (!lhs.hasSpeed || lhs.speed == rhs.speed)
        fieldCheck = fieldCheck && (lhs.hasRoadPosition == rhs.hasRoadPosition) && (!lhs.hasRoadPosition || lhs.roadPosition == rhs.roadPosition)
        fieldCheck = fieldCheck && (lhs.hasCadenceUhz == rhs.hasCadenceUhz) && (!lhs.hasCadenceUhz || lhs.cadenceUhz == rhs.cadenceUhz)
        fieldCheck = fieldCheck && (lhs.hasHeartrate == rhs.hasHeartrate) && (!lhs.hasHeartrate || lhs.heartrate == rhs.heartrate)
        fieldCheck = fieldCheck && (lhs.hasPower == rhs.hasPower) && (!lhs.hasPower || lhs.power == rhs.power)
        fieldCheck = fieldCheck && (lhs.hasHeading == rhs.hasHeading) && (!lhs.hasHeading || lhs.heading == rhs.heading)
        fieldCheck = fieldCheck && (lhs.hasLean == rhs.hasLean) && (!lhs.hasLean || lhs.lean == rhs.lean)
        fieldCheck = fieldCheck && (lhs.hasClimbing == rhs.hasClimbing) && (!lhs.hasClimbing || lhs.climbing == rhs.climbing)
        fieldCheck = fieldCheck && (lhs.hasTime == rhs.hasTime) && (!lhs.hasTime || lhs.time == rhs.time)
        fieldCheck = fieldCheck && (lhs.hasF19 == rhs.hasF19) && (!lhs.hasF19 || lhs.f19 == rhs.f19)
        fieldCheck = fieldCheck && (lhs.hasF20 == rhs.hasF20) && (!lhs.hasF20 || lhs.f20 == rhs.f20)
        fieldCheck = fieldCheck && (lhs.hasProgress == rhs.hasProgress) && (!lhs.hasProgress || lhs.progress == rhs.progress)
        fieldCheck = fieldCheck && (lhs.hasCustomisationId == rhs.hasCustomisationId) && (!lhs.hasCustomisationId || lhs.customisationId == rhs.customisationId)
        fieldCheck = fieldCheck && (lhs.hasJustWatching == rhs.hasJustWatching) && (!lhs.hasJustWatching || lhs.justWatching == rhs.justWatching)
        fieldCheck = fieldCheck && (lhs.hasCalories == rhs.hasCalories) && (!lhs.hasCalories || lhs.calories == rhs.calories)
        fieldCheck = fieldCheck && (lhs.hasX == rhs.hasX) && (!lhs.hasX || lhs.x == rhs.x)
        fieldCheck = fieldCheck && (lhs.hasAltitude == rhs.hasAltitude) && (!lhs.hasAltitude || lhs.altitude == rhs.altitude)
        fieldCheck = fieldCheck && (lhs.hasY == rhs.hasY) && (!lhs.hasY || lhs.y == rhs.y)
        fieldCheck = fieldCheck && (lhs.hasWatchingRiderId == rhs.hasWatchingRiderId) && (!lhs.hasWatchingRiderId || lhs.watchingRiderId == rhs.watchingRiderId)
        fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
        fieldCheck = fieldCheck && (lhs.hasSport == rhs.hasSport) && (!lhs.hasSport || lhs.sport == rhs.sport)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int32! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var worldTime:Int64! = nil
    public fileprivate(set) var hasWorldTime:Bool = false

    public fileprivate(set) var distance:Int32! = nil
    public fileprivate(set) var hasDistance:Bool = false

    public fileprivate(set) var roadTime:Int32! = nil
    public fileprivate(set) var hasRoadTime:Bool = false

    public fileprivate(set) var laps:Int32! = nil
    public fileprivate(set) var hasLaps:Bool = false

    public fileprivate(set) var speed:Int32! = nil
    public fileprivate(set) var hasSpeed:Bool = false

    public fileprivate(set) var roadPosition:Int32! = nil
    public fileprivate(set) var hasRoadPosition:Bool = false

    public fileprivate(set) var cadenceUhz:Int32! = nil
    public fileprivate(set) var hasCadenceUhz:Bool = false

    public fileprivate(set) var heartrate:Int32! = nil
    public fileprivate(set) var hasHeartrate:Bool = false

    public fileprivate(set) var power:Int32! = nil
    public fileprivate(set) var hasPower:Bool = false

    public fileprivate(set) var heading:Int64! = nil
    public fileprivate(set) var hasHeading:Bool = false

    public fileprivate(set) var lean:Int32! = nil
    public fileprivate(set) var hasLean:Bool = false

    public fileprivate(set) var climbing:Int32! = nil
    public fileprivate(set) var hasClimbing:Bool = false

    public fileprivate(set) var time:Int32! = nil
    public fileprivate(set) var hasTime:Bool = false

    public fileprivate(set) var f19:Int32! = nil
    public fileprivate(set) var hasF19:Bool = false

    public fileprivate(set) var f20:Int32! = nil
    public fileprivate(set) var hasF20:Bool = false

    public fileprivate(set) var progress:Int32! = nil
    public fileprivate(set) var hasProgress:Bool = false

    public fileprivate(set) var customisationId:Int64! = nil
    public fileprivate(set) var hasCustomisationId:Bool = false

    public fileprivate(set) var justWatching:Int32! = nil
    public fileprivate(set) var hasJustWatching:Bool = false

    public fileprivate(set) var calories:Int32! = nil
    public fileprivate(set) var hasCalories:Bool = false

    public fileprivate(set) var x:Float! = nil
    public fileprivate(set) var hasX:Bool = false

    public fileprivate(set) var altitude:Float! = nil
    public fileprivate(set) var hasAltitude:Bool = false

    public fileprivate(set) var y:Float! = nil
    public fileprivate(set) var hasY:Bool = false

    public fileprivate(set) var watchingRiderId:Int32! = nil
    public fileprivate(set) var hasWatchingRiderId:Bool = false

    public fileprivate(set) var groupId:Int32! = nil
    public fileprivate(set) var hasGroupId:Bool = false

    public fileprivate(set) var sport:Int64! = nil
    public fileprivate(set) var hasSport:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true;
    }
    
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:id)
        }
        if hasWorldTime {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:worldTime)
        }
        if hasDistance {
            try codedOutputStream.writeInt32(fieldNumber: 3, value:distance)
        }
        if hasRoadTime {
            try codedOutputStream.writeInt32(fieldNumber: 4, value:roadTime)
        }
        if hasLaps {
            try codedOutputStream.writeInt32(fieldNumber: 5, value:laps)
        }
        if hasSpeed {
            try codedOutputStream.writeInt32(fieldNumber: 6, value:speed)
        }
        if hasRoadPosition {
            try codedOutputStream.writeInt32(fieldNumber: 8, value:roadPosition)
        }
        if hasCadenceUhz {
            try codedOutputStream.writeInt32(fieldNumber: 9, value:cadenceUhz)
        }
        if hasHeartrate {
            try codedOutputStream.writeInt32(fieldNumber: 11, value:heartrate)
        }
        if hasPower {
            try codedOutputStream.writeInt32(fieldNumber: 12, value:power)
        }
        if hasHeading {
            try codedOutputStream.writeInt64(fieldNumber: 13, value:heading)
        }
        if hasLean {
            try codedOutputStream.writeInt32(fieldNumber: 14, value:lean)
        }
        if hasClimbing {
            try codedOutputStream.writeInt32(fieldNumber: 15, value:climbing)
        }
        if hasTime {
            try codedOutputStream.writeInt32(fieldNumber: 16, value:time)
        }
        if hasF19 {
            try codedOutputStream.writeInt32(fieldNumber: 19, value:f19)
        }
        if hasF20 {
            try codedOutputStream.writeInt32(fieldNumber: 20, value:f20)
        }
        if hasProgress {
            try codedOutputStream.writeInt32(fieldNumber: 21, value:progress)
        }
        if hasCustomisationId {
            try codedOutputStream.writeInt64(fieldNumber: 22, value:customisationId)
        }
        if hasJustWatching {
            try codedOutputStream.writeInt32(fieldNumber: 23, value:justWatching)
        }
        if hasCalories {
            try codedOutputStream.writeInt32(fieldNumber: 24, value:calories)
        }
        if hasX {
            try codedOutputStream.writeFloat(fieldNumber: 25, value:x)
        }
        if hasAltitude {
            try codedOutputStream.writeFloat(fieldNumber: 26, value:altitude)
        }
        if hasY {
            try codedOutputStream.writeFloat(fieldNumber: 27, value:y)
        }
        if hasWatchingRiderId {
            try codedOutputStream.writeInt32(fieldNumber: 28, value:watchingRiderId)
        }
        if hasGroupId {
            try codedOutputStream.writeInt32(fieldNumber: 29, value:groupId)
        }
        if hasSport {
            try codedOutputStream.writeInt64(fieldNumber: 31, value:sport)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt32Size(fieldNumber: 1)
        }
        if hasWorldTime {
            serialize_size += worldTime.computeInt64Size(fieldNumber: 2)
        }
        if hasDistance {
            serialize_size += distance.computeInt32Size(fieldNumber: 3)
        }
        if hasRoadTime {
            serialize_size += roadTime.computeInt32Size(fieldNumber: 4)
        }
        if hasLaps {
            serialize_size += laps.computeInt32Size(fieldNumber: 5)
        }
        if hasSpeed {
            serialize_size += speed.computeInt32Size(fieldNumber: 6)
        }
        if hasRoadPosition {
            serialize_size += roadPosition.computeInt32Size(fieldNumber: 8)
        }
        if hasCadenceUhz {
            serialize_size += cadenceUhz.computeInt32Size(fieldNumber: 9)
        }
        if hasHeartrate {
            serialize_size += heartrate.computeInt32Size(fieldNumber: 11)
        }
        if hasPower {
            serialize_size += power.computeInt32Size(fieldNumber: 12)
        }
        if hasHeading {
            serialize_size += heading.computeInt64Size(fieldNumber: 13)
        }
        if hasLean {
            serialize_size += lean.computeInt32Size(fieldNumber: 14)
        }
        if hasClimbing {
            serialize_size += climbing.computeInt32Size(fieldNumber: 15)
        }
        if hasTime {
            serialize_size += time.computeInt32Size(fieldNumber: 16)
        }
        if hasF19 {
            serialize_size += f19.computeInt32Size(fieldNumber: 19)
        }
        if hasF20 {
            serialize_size += f20.computeInt32Size(fieldNumber: 20)
        }
        if hasProgress {
            serialize_size += progress.computeInt32Size(fieldNumber: 21)
        }
        if hasCustomisationId {
            serialize_size += customisationId.computeInt64Size(fieldNumber: 22)
        }
        if hasJustWatching {
            serialize_size += justWatching.computeInt32Size(fieldNumber: 23)
        }
        if hasCalories {
            serialize_size += calories.computeInt32Size(fieldNumber: 24)
        }
        if hasX {
            serialize_size += x.computeFloatSize(fieldNumber: 25)
        }
        if hasAltitude {
            serialize_size += altitude.computeFloatSize(fieldNumber: 26)
        }
        if hasY {
            serialize_size += y.computeFloatSize(fieldNumber: 27)
        }
        if hasWatchingRiderId {
            serialize_size += watchingRiderId.computeInt32Size(fieldNumber: 28)
        }
        if hasGroupId {
            serialize_size += groupId.computeInt32Size(fieldNumber: 29)
        }
        if hasSport {
            serialize_size += sport.computeInt64Size(fieldNumber: 31)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> PlayerState.Builder {
        return PlayerState.classBuilder() as! PlayerState.Builder
    }
    public func getBuilder() -> PlayerState.Builder {
        return classBuilder() as! PlayerState.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PlayerState.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PlayerState.Builder()
    }
    public func toBuilder() throws -> PlayerState.Builder {
        return try PlayerState.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:PlayerState) throws -> PlayerState.Builder {
        return try PlayerState.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasId {
            jsonMap["id"] = Int(id)
        }
        if hasWorldTime {
            jsonMap["worldTime"] = "\(worldTime!)"
        }
        if hasDistance {
            jsonMap["distance"] = Int(distance)
        }
        if hasRoadTime {
            jsonMap["roadTime"] = Int(roadTime)
        }
        if hasLaps {
            jsonMap["laps"] = Int(laps)
        }
        if hasSpeed {
            jsonMap["speed"] = Int(speed)
        }
        if hasRoadPosition {
            jsonMap["roadPosition"] = Int(roadPosition)
        }
        if hasCadenceUhz {
            jsonMap["cadenceUHz"] = Int(cadenceUhz)
        }
        if hasHeartrate {
            jsonMap["heartrate"] = Int(heartrate)
        }
        if hasPower {
            jsonMap["power"] = Int(power)
        }
        if hasHeading {
            jsonMap["heading"] = "\(heading!)"
        }
        if hasLean {
            jsonMap["lean"] = Int(lean)
        }
        if hasClimbing {
            jsonMap["climbing"] = Int(climbing)
        }
        if hasTime {
            jsonMap["time"] = Int(time)
        }
        if hasF19 {
            jsonMap["f19"] = Int(f19)
        }
        if hasF20 {
            jsonMap["f20"] = Int(f20)
        }
        if hasProgress {
            jsonMap["progress"] = Int(progress)
        }
        if hasCustomisationId {
            jsonMap["customisationId"] = "\(customisationId!)"
        }
        if hasJustWatching {
            jsonMap["justWatching"] = Int(justWatching)
        }
        if hasCalories {
            jsonMap["calories"] = Int(calories)
        }
        if hasX {
            jsonMap["x"] = Float(x)
        }
        if hasAltitude {
            jsonMap["altitude"] = Float(altitude)
        }
        if hasY {
            jsonMap["y"] = Float(y)
        }
        if hasWatchingRiderId {
            jsonMap["watchingRiderId"] = Int(watchingRiderId)
        }
        if hasGroupId {
            jsonMap["groupId"] = Int(groupId)
        }
        if hasSport {
            jsonMap["sport"] = "\(sport!)"
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> PlayerState {
        return try PlayerState.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> PlayerState {
        return try PlayerState.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasWorldTime {
            output += "\(indent) worldTime: \(worldTime) \n"
        }
        if hasDistance {
            output += "\(indent) distance: \(distance) \n"
        }
        if hasRoadTime {
            output += "\(indent) roadTime: \(roadTime) \n"
        }
        if hasLaps {
            output += "\(indent) laps: \(laps) \n"
        }
        if hasSpeed {
            output += "\(indent) speed: \(speed) \n"
        }
        if hasRoadPosition {
            output += "\(indent) roadPosition: \(roadPosition) \n"
        }
        if hasCadenceUhz {
            output += "\(indent) cadenceUhz: \(cadenceUhz) \n"
        }
        if hasHeartrate {
            output += "\(indent) heartrate: \(heartrate) \n"
        }
        if hasPower {
            output += "\(indent) power: \(power) \n"
        }
        if hasHeading {
            output += "\(indent) heading: \(heading) \n"
        }
        if hasLean {
            output += "\(indent) lean: \(lean) \n"
        }
        if hasClimbing {
            output += "\(indent) climbing: \(climbing) \n"
        }
        if hasTime {
            output += "\(indent) time: \(time) \n"
        }
        if hasF19 {
            output += "\(indent) f19: \(f19) \n"
        }
        if hasF20 {
            output += "\(indent) f20: \(f20) \n"
        }
        if hasProgress {
            output += "\(indent) progress: \(progress) \n"
        }
        if hasCustomisationId {
            output += "\(indent) customisationId: \(customisationId) \n"
        }
        if hasJustWatching {
            output += "\(indent) justWatching: \(justWatching) \n"
        }
        if hasCalories {
            output += "\(indent) calories: \(calories) \n"
        }
        if hasX {
            output += "\(indent) x: \(x) \n"
        }
        if hasAltitude {
            output += "\(indent) altitude: \(altitude) \n"
        }
        if hasY {
            output += "\(indent) y: \(y) \n"
        }
        if hasWatchingRiderId {
            output += "\(indent) watchingRiderId: \(watchingRiderId) \n"
        }
        if hasGroupId {
            output += "\(indent) groupId: \(groupId) \n"
        }
        if hasSport {
            output += "\(indent) sport: \(sport) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasWorldTime {
                hashCode = (hashCode &* 31) &+ worldTime.hashValue
            }
            if hasDistance {
                hashCode = (hashCode &* 31) &+ distance.hashValue
            }
            if hasRoadTime {
                hashCode = (hashCode &* 31) &+ roadTime.hashValue
            }
            if hasLaps {
                hashCode = (hashCode &* 31) &+ laps.hashValue
            }
            if hasSpeed {
                hashCode = (hashCode &* 31) &+ speed.hashValue
            }
            if hasRoadPosition {
                hashCode = (hashCode &* 31) &+ roadPosition.hashValue
            }
            if hasCadenceUhz {
                hashCode = (hashCode &* 31) &+ cadenceUhz.hashValue
            }
            if hasHeartrate {
                hashCode = (hashCode &* 31) &+ heartrate.hashValue
            }
            if hasPower {
                hashCode = (hashCode &* 31) &+ power.hashValue
            }
            if hasHeading {
                hashCode = (hashCode &* 31) &+ heading.hashValue
            }
            if hasLean {
                hashCode = (hashCode &* 31) &+ lean.hashValue
            }
            if hasClimbing {
                hashCode = (hashCode &* 31) &+ climbing.hashValue
            }
            if hasTime {
                hashCode = (hashCode &* 31) &+ time.hashValue
            }
            if hasF19 {
                hashCode = (hashCode &* 31) &+ f19.hashValue
            }
            if hasF20 {
                hashCode = (hashCode &* 31) &+ f20.hashValue
            }
            if hasProgress {
                hashCode = (hashCode &* 31) &+ progress.hashValue
            }
            if hasCustomisationId {
                hashCode = (hashCode &* 31) &+ customisationId.hashValue
            }
            if hasJustWatching {
                hashCode = (hashCode &* 31) &+ justWatching.hashValue
            }
            if hasCalories {
                hashCode = (hashCode &* 31) &+ calories.hashValue
            }
            if hasX {
                hashCode = (hashCode &* 31) &+ x.hashValue
            }
            if hasAltitude {
                hashCode = (hashCode &* 31) &+ altitude.hashValue
            }
            if hasY {
                hashCode = (hashCode &* 31) &+ y.hashValue
            }
            if hasWatchingRiderId {
                hashCode = (hashCode &* 31) &+ watchingRiderId.hashValue
            }
            if hasGroupId {
                hashCode = (hashCode &* 31) &+ groupId.hashValue
            }
            if hasSport {
                hashCode = (hashCode &* 31) &+ sport.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "PlayerState"
    }
    override public func className() -> String {
        return "PlayerState"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PlayerState = PlayerState()
        public func getMessage() -> PlayerState {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int32 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int32) -> PlayerState.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> PlayerState.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var worldTime:Int64 {
            get {
                return builderResult.worldTime
            }
            set (value) {
                builderResult.hasWorldTime = true
                builderResult.worldTime = value
            }
        }
        public var hasWorldTime:Bool {
            get {
                return builderResult.hasWorldTime
            }
        }
        @discardableResult
        public func setWorldTime(_ value:Int64) -> PlayerState.Builder {
            self.worldTime = value
            return self
        }
        @discardableResult
        public func clearWorldTime() -> PlayerState.Builder{
            builderResult.hasWorldTime = false
            builderResult.worldTime = nil
            return self
        }
        public var distance:Int32 {
            get {
                return builderResult.distance
            }
            set (value) {
                builderResult.hasDistance = true
                builderResult.distance = value
            }
        }
        public var hasDistance:Bool {
            get {
                return builderResult.hasDistance
            }
        }
        @discardableResult
        public func setDistance(_ value:Int32) -> PlayerState.Builder {
            self.distance = value
            return self
        }
        @discardableResult
        public func clearDistance() -> PlayerState.Builder{
            builderResult.hasDistance = false
            builderResult.distance = nil
            return self
        }
        public var roadTime:Int32 {
            get {
                return builderResult.roadTime
            }
            set (value) {
                builderResult.hasRoadTime = true
                builderResult.roadTime = value
            }
        }
        public var hasRoadTime:Bool {
            get {
                return builderResult.hasRoadTime
            }
        }
        @discardableResult
        public func setRoadTime(_ value:Int32) -> PlayerState.Builder {
            self.roadTime = value
            return self
        }
        @discardableResult
        public func clearRoadTime() -> PlayerState.Builder{
            builderResult.hasRoadTime = false
            builderResult.roadTime = nil
            return self
        }
        public var laps:Int32 {
            get {
                return builderResult.laps
            }
            set (value) {
                builderResult.hasLaps = true
                builderResult.laps = value
            }
        }
        public var hasLaps:Bool {
            get {
                return builderResult.hasLaps
            }
        }
        @discardableResult
        public func setLaps(_ value:Int32) -> PlayerState.Builder {
            self.laps = value
            return self
        }
        @discardableResult
        public func clearLaps() -> PlayerState.Builder{
            builderResult.hasLaps = false
            builderResult.laps = nil
            return self
        }
        public var speed:Int32 {
            get {
                return builderResult.speed
            }
            set (value) {
                builderResult.hasSpeed = true
                builderResult.speed = value
            }
        }
        public var hasSpeed:Bool {
            get {
                return builderResult.hasSpeed
            }
        }
        @discardableResult
        public func setSpeed(_ value:Int32) -> PlayerState.Builder {
            self.speed = value
            return self
        }
        @discardableResult
        public func clearSpeed() -> PlayerState.Builder{
            builderResult.hasSpeed = false
            builderResult.speed = nil
            return self
        }
        public var roadPosition:Int32 {
            get {
                return builderResult.roadPosition
            }
            set (value) {
                builderResult.hasRoadPosition = true
                builderResult.roadPosition = value
            }
        }
        public var hasRoadPosition:Bool {
            get {
                return builderResult.hasRoadPosition
            }
        }
        @discardableResult
        public func setRoadPosition(_ value:Int32) -> PlayerState.Builder {
            self.roadPosition = value
            return self
        }
        @discardableResult
        public func clearRoadPosition() -> PlayerState.Builder{
            builderResult.hasRoadPosition = false
            builderResult.roadPosition = nil
            return self
        }
        public var cadenceUhz:Int32 {
            get {
                return builderResult.cadenceUhz
            }
            set (value) {
                builderResult.hasCadenceUhz = true
                builderResult.cadenceUhz = value
            }
        }
        public var hasCadenceUhz:Bool {
            get {
                return builderResult.hasCadenceUhz
            }
        }
        @discardableResult
        public func setCadenceUhz(_ value:Int32) -> PlayerState.Builder {
            self.cadenceUhz = value
            return self
        }
        @discardableResult
        public func clearCadenceUhz() -> PlayerState.Builder{
            builderResult.hasCadenceUhz = false
            builderResult.cadenceUhz = nil
            return self
        }
        public var heartrate:Int32 {
            get {
                return builderResult.heartrate
            }
            set (value) {
                builderResult.hasHeartrate = true
                builderResult.heartrate = value
            }
        }
        public var hasHeartrate:Bool {
            get {
                return builderResult.hasHeartrate
            }
        }
        @discardableResult
        public func setHeartrate(_ value:Int32) -> PlayerState.Builder {
            self.heartrate = value
            return self
        }
        @discardableResult
        public func clearHeartrate() -> PlayerState.Builder{
            builderResult.hasHeartrate = false
            builderResult.heartrate = nil
            return self
        }
        public var power:Int32 {
            get {
                return builderResult.power
            }
            set (value) {
                builderResult.hasPower = true
                builderResult.power = value
            }
        }
        public var hasPower:Bool {
            get {
                return builderResult.hasPower
            }
        }
        @discardableResult
        public func setPower(_ value:Int32) -> PlayerState.Builder {
            self.power = value
            return self
        }
        @discardableResult
        public func clearPower() -> PlayerState.Builder{
            builderResult.hasPower = false
            builderResult.power = nil
            return self
        }
        public var heading:Int64 {
            get {
                return builderResult.heading
            }
            set (value) {
                builderResult.hasHeading = true
                builderResult.heading = value
            }
        }
        public var hasHeading:Bool {
            get {
                return builderResult.hasHeading
            }
        }
        @discardableResult
        public func setHeading(_ value:Int64) -> PlayerState.Builder {
            self.heading = value
            return self
        }
        @discardableResult
        public func clearHeading() -> PlayerState.Builder{
            builderResult.hasHeading = false
            builderResult.heading = nil
            return self
        }
        public var lean:Int32 {
            get {
                return builderResult.lean
            }
            set (value) {
                builderResult.hasLean = true
                builderResult.lean = value
            }
        }
        public var hasLean:Bool {
            get {
                return builderResult.hasLean
            }
        }
        @discardableResult
        public func setLean(_ value:Int32) -> PlayerState.Builder {
            self.lean = value
            return self
        }
        @discardableResult
        public func clearLean() -> PlayerState.Builder{
            builderResult.hasLean = false
            builderResult.lean = nil
            return self
        }
        public var climbing:Int32 {
            get {
                return builderResult.climbing
            }
            set (value) {
                builderResult.hasClimbing = true
                builderResult.climbing = value
            }
        }
        public var hasClimbing:Bool {
            get {
                return builderResult.hasClimbing
            }
        }
        @discardableResult
        public func setClimbing(_ value:Int32) -> PlayerState.Builder {
            self.climbing = value
            return self
        }
        @discardableResult
        public func clearClimbing() -> PlayerState.Builder{
            builderResult.hasClimbing = false
            builderResult.climbing = nil
            return self
        }
        public var time:Int32 {
            get {
                return builderResult.time
            }
            set (value) {
                builderResult.hasTime = true
                builderResult.time = value
            }
        }
        public var hasTime:Bool {
            get {
                return builderResult.hasTime
            }
        }
        @discardableResult
        public func setTime(_ value:Int32) -> PlayerState.Builder {
            self.time = value
            return self
        }
        @discardableResult
        public func clearTime() -> PlayerState.Builder{
            builderResult.hasTime = false
            builderResult.time = nil
            return self
        }
        public var f19:Int32 {
            get {
                return builderResult.f19
            }
            set (value) {
                builderResult.hasF19 = true
                builderResult.f19 = value
            }
        }
        public var hasF19:Bool {
            get {
                return builderResult.hasF19
            }
        }
        @discardableResult
        public func setF19(_ value:Int32) -> PlayerState.Builder {
            self.f19 = value
            return self
        }
        @discardableResult
        public func clearF19() -> PlayerState.Builder{
            builderResult.hasF19 = false
            builderResult.f19 = nil
            return self
        }
        public var f20:Int32 {
            get {
                return builderResult.f20
            }
            set (value) {
                builderResult.hasF20 = true
                builderResult.f20 = value
            }
        }
        public var hasF20:Bool {
            get {
                return builderResult.hasF20
            }
        }
        @discardableResult
        public func setF20(_ value:Int32) -> PlayerState.Builder {
            self.f20 = value
            return self
        }
        @discardableResult
        public func clearF20() -> PlayerState.Builder{
            builderResult.hasF20 = false
            builderResult.f20 = nil
            return self
        }
        public var progress:Int32 {
            get {
                return builderResult.progress
            }
            set (value) {
                builderResult.hasProgress = true
                builderResult.progress = value
            }
        }
        public var hasProgress:Bool {
            get {
                return builderResult.hasProgress
            }
        }
        @discardableResult
        public func setProgress(_ value:Int32) -> PlayerState.Builder {
            self.progress = value
            return self
        }
        @discardableResult
        public func clearProgress() -> PlayerState.Builder{
            builderResult.hasProgress = false
            builderResult.progress = nil
            return self
        }
        public var customisationId:Int64 {
            get {
                return builderResult.customisationId
            }
            set (value) {
                builderResult.hasCustomisationId = true
                builderResult.customisationId = value
            }
        }
        public var hasCustomisationId:Bool {
            get {
                return builderResult.hasCustomisationId
            }
        }
        @discardableResult
        public func setCustomisationId(_ value:Int64) -> PlayerState.Builder {
            self.customisationId = value
            return self
        }
        @discardableResult
        public func clearCustomisationId() -> PlayerState.Builder{
            builderResult.hasCustomisationId = false
            builderResult.customisationId = nil
            return self
        }
        public var justWatching:Int32 {
            get {
                return builderResult.justWatching
            }
            set (value) {
                builderResult.hasJustWatching = true
                builderResult.justWatching = value
            }
        }
        public var hasJustWatching:Bool {
            get {
                return builderResult.hasJustWatching
            }
        }
        @discardableResult
        public func setJustWatching(_ value:Int32) -> PlayerState.Builder {
            self.justWatching = value
            return self
        }
        @discardableResult
        public func clearJustWatching() -> PlayerState.Builder{
            builderResult.hasJustWatching = false
            builderResult.justWatching = nil
            return self
        }
        public var calories:Int32 {
            get {
                return builderResult.calories
            }
            set (value) {
                builderResult.hasCalories = true
                builderResult.calories = value
            }
        }
        public var hasCalories:Bool {
            get {
                return builderResult.hasCalories
            }
        }
        @discardableResult
        public func setCalories(_ value:Int32) -> PlayerState.Builder {
            self.calories = value
            return self
        }
        @discardableResult
        public func clearCalories() -> PlayerState.Builder{
            builderResult.hasCalories = false
            builderResult.calories = nil
            return self
        }
        public var x:Float {
            get {
                return builderResult.x
            }
            set (value) {
                builderResult.hasX = true
                builderResult.x = value
            }
        }
        public var hasX:Bool {
            get {
                return builderResult.hasX
            }
        }
        @discardableResult
        public func setX(_ value:Float) -> PlayerState.Builder {
            self.x = value
            return self
        }
        @discardableResult
        public func clearX() -> PlayerState.Builder{
            builderResult.hasX = false
            builderResult.x = nil
            return self
        }
        public var altitude:Float {
            get {
                return builderResult.altitude
            }
            set (value) {
                builderResult.hasAltitude = true
                builderResult.altitude = value
            }
        }
        public var hasAltitude:Bool {
            get {
                return builderResult.hasAltitude
            }
        }
        @discardableResult
        public func setAltitude(_ value:Float) -> PlayerState.Builder {
            self.altitude = value
            return self
        }
        @discardableResult
        public func clearAltitude() -> PlayerState.Builder{
            builderResult.hasAltitude = false
            builderResult.altitude = nil
            return self
        }
        public var y:Float {
            get {
                return builderResult.y
            }
            set (value) {
                builderResult.hasY = true
                builderResult.y = value
            }
        }
        public var hasY:Bool {
            get {
                return builderResult.hasY
            }
        }
        @discardableResult
        public func setY(_ value:Float) -> PlayerState.Builder {
            self.y = value
            return self
        }
        @discardableResult
        public func clearY() -> PlayerState.Builder{
            builderResult.hasY = false
            builderResult.y = nil
            return self
        }
        public var watchingRiderId:Int32 {
            get {
                return builderResult.watchingRiderId
            }
            set (value) {
                builderResult.hasWatchingRiderId = true
                builderResult.watchingRiderId = value
            }
        }
        public var hasWatchingRiderId:Bool {
            get {
                return builderResult.hasWatchingRiderId
            }
        }
        @discardableResult
        public func setWatchingRiderId(_ value:Int32) -> PlayerState.Builder {
            self.watchingRiderId = value
            return self
        }
        @discardableResult
        public func clearWatchingRiderId() -> PlayerState.Builder{
            builderResult.hasWatchingRiderId = false
            builderResult.watchingRiderId = nil
            return self
        }
        public var groupId:Int32 {
            get {
                return builderResult.groupId
            }
            set (value) {
                builderResult.hasGroupId = true
                builderResult.groupId = value
            }
        }
        public var hasGroupId:Bool {
            get {
                return builderResult.hasGroupId
            }
        }
        @discardableResult
        public func setGroupId(_ value:Int32) -> PlayerState.Builder {
            self.groupId = value
            return self
        }
        @discardableResult
        public func clearGroupId() -> PlayerState.Builder{
            builderResult.hasGroupId = false
            builderResult.groupId = nil
            return self
        }
        public var sport:Int64 {
            get {
                return builderResult.sport
            }
            set (value) {
                builderResult.hasSport = true
                builderResult.sport = value
            }
        }
        public var hasSport:Bool {
            get {
                return builderResult.hasSport
            }
        }
        @discardableResult
        public func setSport(_ value:Int64) -> PlayerState.Builder {
            self.sport = value
            return self
        }
        @discardableResult
        public func clearSport() -> PlayerState.Builder{
            builderResult.hasSport = false
            builderResult.sport = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> PlayerState.Builder {
            builderResult = PlayerState()
            return self
        }
        override public func clone() throws -> PlayerState.Builder {
            return try PlayerState.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> PlayerState {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> PlayerState {
            let returnMe:PlayerState = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:PlayerState) throws -> PlayerState.Builder {
            if other == PlayerState() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasWorldTime {
                worldTime = other.worldTime
            }
            if other.hasDistance {
                distance = other.distance
            }
            if other.hasRoadTime {
                roadTime = other.roadTime
            }
            if other.hasLaps {
                laps = other.laps
            }
            if other.hasSpeed {
                speed = other.speed
            }
            if other.hasRoadPosition {
                roadPosition = other.roadPosition
            }
            if other.hasCadenceUhz {
                cadenceUhz = other.cadenceUhz
            }
            if other.hasHeartrate {
                heartrate = other.heartrate
            }
            if other.hasPower {
                power = other.power
            }
            if other.hasHeading {
                heading = other.heading
            }
            if other.hasLean {
                lean = other.lean
            }
            if other.hasClimbing {
                climbing = other.climbing
            }
            if other.hasTime {
                time = other.time
            }
            if other.hasF19 {
                f19 = other.f19
            }
            if other.hasF20 {
                f20 = other.f20
            }
            if other.hasProgress {
                progress = other.progress
            }
            if other.hasCustomisationId {
                customisationId = other.customisationId
            }
            if other.hasJustWatching {
                justWatching = other.justWatching
            }
            if other.hasCalories {
                calories = other.calories
            }
            if other.hasX {
                x = other.x
            }
            if other.hasAltitude {
                altitude = other.altitude
            }
            if other.hasY {
                y = other.y
            }
            if other.hasWatchingRiderId {
                watchingRiderId = other.watchingRiderId
            }
            if other.hasGroupId {
                groupId = other.groupId
            }
            if other.hasSport {
                sport = other.sport
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PlayerState.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PlayerState.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt32()

                case 16:
                    worldTime = try codedInputStream.readInt64()

                case 24:
                    distance = try codedInputStream.readInt32()

                case 32:
                    roadTime = try codedInputStream.readInt32()

                case 40:
                    laps = try codedInputStream.readInt32()

                case 48:
                    speed = try codedInputStream.readInt32()

                case 64:
                    roadPosition = try codedInputStream.readInt32()

                case 72:
                    cadenceUhz = try codedInputStream.readInt32()

                case 88:
                    heartrate = try codedInputStream.readInt32()

                case 96:
                    power = try codedInputStream.readInt32()

                case 104:
                    heading = try codedInputStream.readInt64()

                case 112:
                    lean = try codedInputStream.readInt32()

                case 120:
                    climbing = try codedInputStream.readInt32()

                case 128:
                    time = try codedInputStream.readInt32()

                case 152:
                    f19 = try codedInputStream.readInt32()

                case 160:
                    f20 = try codedInputStream.readInt32()

                case 168:
                    progress = try codedInputStream.readInt32()

                case 176:
                    customisationId = try codedInputStream.readInt64()

                case 184:
                    justWatching = try codedInputStream.readInt32()

                case 192:
                    calories = try codedInputStream.readInt32()

                case 205:
                    x = try codedInputStream.readFloat()

                case 213:
                    altitude = try codedInputStream.readFloat()

                case 221:
                    y = try codedInputStream.readFloat()

                case 224:
                    watchingRiderId = try codedInputStream.readInt32()

                case 232:
                    groupId = try codedInputStream.readInt32()

                case 248:
                    sport = try codedInputStream.readInt64()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PlayerState.Builder {
            let resultDecodedBuilder = PlayerState.Builder()
            if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int32(jsonValueId)
            } else if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int32(jsonValueId)!
            }
            if let jsonValueWorldTime = jsonMap["worldTime"] as? String {
                resultDecodedBuilder.worldTime = Int64(jsonValueWorldTime)!
            } else if let jsonValueWorldTime = jsonMap["worldTime"] as? Int {
                resultDecodedBuilder.worldTime = Int64(jsonValueWorldTime)
            }
            if let jsonValueDistance = jsonMap["distance"] as? Int {
                resultDecodedBuilder.distance = Int32(jsonValueDistance)
            } else if let jsonValueDistance = jsonMap["distance"] as? String {
                resultDecodedBuilder.distance = Int32(jsonValueDistance)!
            }
            if let jsonValueRoadTime = jsonMap["roadTime"] as? Int {
                resultDecodedBuilder.roadTime = Int32(jsonValueRoadTime)
            } else if let jsonValueRoadTime = jsonMap["roadTime"] as? String {
                resultDecodedBuilder.roadTime = Int32(jsonValueRoadTime)!
            }
            if let jsonValueLaps = jsonMap["laps"] as? Int {
                resultDecodedBuilder.laps = Int32(jsonValueLaps)
            } else if let jsonValueLaps = jsonMap["laps"] as? String {
                resultDecodedBuilder.laps = Int32(jsonValueLaps)!
            }
            if let jsonValueSpeed = jsonMap["speed"] as? Int {
                resultDecodedBuilder.speed = Int32(jsonValueSpeed)
            } else if let jsonValueSpeed = jsonMap["speed"] as? String {
                resultDecodedBuilder.speed = Int32(jsonValueSpeed)!
            }
            if let jsonValueRoadPosition = jsonMap["roadPosition"] as? Int {
                resultDecodedBuilder.roadPosition = Int32(jsonValueRoadPosition)
            } else if let jsonValueRoadPosition = jsonMap["roadPosition"] as? String {
                resultDecodedBuilder.roadPosition = Int32(jsonValueRoadPosition)!
            }
            if let jsonValueCadenceUhz = jsonMap["cadenceUHz"] as? Int {
                resultDecodedBuilder.cadenceUhz = Int32(jsonValueCadenceUhz)
            } else if let jsonValueCadenceUhz = jsonMap["cadenceUHz"] as? String {
                resultDecodedBuilder.cadenceUhz = Int32(jsonValueCadenceUhz)!
            }
            if let jsonValueHeartrate = jsonMap["heartrate"] as? Int {
                resultDecodedBuilder.heartrate = Int32(jsonValueHeartrate)
            } else if let jsonValueHeartrate = jsonMap["heartrate"] as? String {
                resultDecodedBuilder.heartrate = Int32(jsonValueHeartrate)!
            }
            if let jsonValuePower = jsonMap["power"] as? Int {
                resultDecodedBuilder.power = Int32(jsonValuePower)
            } else if let jsonValuePower = jsonMap["power"] as? String {
                resultDecodedBuilder.power = Int32(jsonValuePower)!
            }
            if let jsonValueHeading = jsonMap["heading"] as? String {
                resultDecodedBuilder.heading = Int64(jsonValueHeading)!
            } else if let jsonValueHeading = jsonMap["heading"] as? Int {
                resultDecodedBuilder.heading = Int64(jsonValueHeading)
            }
            if let jsonValueLean = jsonMap["lean"] as? Int {
                resultDecodedBuilder.lean = Int32(jsonValueLean)
            } else if let jsonValueLean = jsonMap["lean"] as? String {
                resultDecodedBuilder.lean = Int32(jsonValueLean)!
            }
            if let jsonValueClimbing = jsonMap["climbing"] as? Int {
                resultDecodedBuilder.climbing = Int32(jsonValueClimbing)
            } else if let jsonValueClimbing = jsonMap["climbing"] as? String {
                resultDecodedBuilder.climbing = Int32(jsonValueClimbing)!
            }
            if let jsonValueTime = jsonMap["time"] as? Int {
                resultDecodedBuilder.time = Int32(jsonValueTime)
            } else if let jsonValueTime = jsonMap["time"] as? String {
                resultDecodedBuilder.time = Int32(jsonValueTime)!
            }
            if let jsonValueF19 = jsonMap["f19"] as? Int {
                resultDecodedBuilder.f19 = Int32(jsonValueF19)
            } else if let jsonValueF19 = jsonMap["f19"] as? String {
                resultDecodedBuilder.f19 = Int32(jsonValueF19)!
            }
            if let jsonValueF20 = jsonMap["f20"] as? Int {
                resultDecodedBuilder.f20 = Int32(jsonValueF20)
            } else if let jsonValueF20 = jsonMap["f20"] as? String {
                resultDecodedBuilder.f20 = Int32(jsonValueF20)!
            }
            if let jsonValueProgress = jsonMap["progress"] as? Int {
                resultDecodedBuilder.progress = Int32(jsonValueProgress)
            } else if let jsonValueProgress = jsonMap["progress"] as? String {
                resultDecodedBuilder.progress = Int32(jsonValueProgress)!
            }
            if let jsonValueCustomisationId = jsonMap["customisationId"] as? String {
                resultDecodedBuilder.customisationId = Int64(jsonValueCustomisationId)!
            } else if let jsonValueCustomisationId = jsonMap["customisationId"] as? Int {
                resultDecodedBuilder.customisationId = Int64(jsonValueCustomisationId)
            }
            if let jsonValueJustWatching = jsonMap["justWatching"] as? Int {
                resultDecodedBuilder.justWatching = Int32(jsonValueJustWatching)
            } else if let jsonValueJustWatching = jsonMap["justWatching"] as? String {
                resultDecodedBuilder.justWatching = Int32(jsonValueJustWatching)!
            }
            if let jsonValueCalories = jsonMap["calories"] as? Int {
                resultDecodedBuilder.calories = Int32(jsonValueCalories)
            } else if let jsonValueCalories = jsonMap["calories"] as? String {
                resultDecodedBuilder.calories = Int32(jsonValueCalories)!
            }
            if let jsonValueX = jsonMap["x"] as? Float {
                resultDecodedBuilder.x = Float(jsonValueX)
            } else if let jsonValueX = jsonMap["x"] as? String {
                resultDecodedBuilder.x = Float(jsonValueX)!
            }
            if let jsonValueAltitude = jsonMap["altitude"] as? Float {
                resultDecodedBuilder.altitude = Float(jsonValueAltitude)
            } else if let jsonValueAltitude = jsonMap["altitude"] as? String {
                resultDecodedBuilder.altitude = Float(jsonValueAltitude)!
            }
            if let jsonValueY = jsonMap["y"] as? Float {
                resultDecodedBuilder.y = Float(jsonValueY)
            } else if let jsonValueY = jsonMap["y"] as? String {
                resultDecodedBuilder.y = Float(jsonValueY)!
            }
            if let jsonValueWatchingRiderId = jsonMap["watchingRiderId"] as? Int {
                resultDecodedBuilder.watchingRiderId = Int32(jsonValueWatchingRiderId)
            } else if let jsonValueWatchingRiderId = jsonMap["watchingRiderId"] as? String {
                resultDecodedBuilder.watchingRiderId = Int32(jsonValueWatchingRiderId)!
            }
            if let jsonValueGroupId = jsonMap["groupId"] as? Int {
                resultDecodedBuilder.groupId = Int32(jsonValueGroupId)
            } else if let jsonValueGroupId = jsonMap["groupId"] as? String {
                resultDecodedBuilder.groupId = Int32(jsonValueGroupId)!
            }
            if let jsonValueSport = jsonMap["sport"] as? String {
                resultDecodedBuilder.sport = Int64(jsonValueSport)!
            } else if let jsonValueSport = jsonMap["sport"] as? Int {
                resultDecodedBuilder.sport = Int64(jsonValueSport)
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> PlayerState.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PlayerState.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class ClientToServer : GeneratedMessage {
    public typealias BuilderType = ClientToServer.Builder

    public static func == (lhs: ClientToServer, rhs: ClientToServer) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasConnected == rhs.hasConnected) && (!lhs.hasConnected || lhs.connected == rhs.connected)
        fieldCheck = fieldCheck && (lhs.hasRiderId == rhs.hasRiderId) && (!lhs.hasRiderId || lhs.riderId == rhs.riderId)
        fieldCheck = fieldCheck && (lhs.hasWorldTime == rhs.hasWorldTime) && (!lhs.hasWorldTime || lhs.worldTime == rhs.worldTime)
        fieldCheck = fieldCheck && (lhs.hasSeqno == rhs.hasSeqno) && (!lhs.hasSeqno || lhs.seqno == rhs.seqno)
        fieldCheck = fieldCheck && (lhs.hasState == rhs.hasState) && (!lhs.hasState || lhs.state == rhs.state)
        fieldCheck = fieldCheck && (lhs.hasTag8 == rhs.hasTag8) && (!lhs.hasTag8 || lhs.tag8 == rhs.tag8)
        fieldCheck = fieldCheck && (lhs.hasTag9 == rhs.hasTag9) && (!lhs.hasTag9 || lhs.tag9 == rhs.tag9)
        fieldCheck = fieldCheck && (lhs.hasLastUpdate == rhs.hasLastUpdate) && (!lhs.hasLastUpdate || lhs.lastUpdate == rhs.lastUpdate)
        fieldCheck = fieldCheck && (lhs.hasTag11 == rhs.hasTag11) && (!lhs.hasTag11 || lhs.tag11 == rhs.tag11)
        fieldCheck = fieldCheck && (lhs.hasLastPlayerUpdate == rhs.hasLastPlayerUpdate) && (!lhs.hasLastPlayerUpdate || lhs.lastPlayerUpdate == rhs.lastPlayerUpdate)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var connected:Int32! = nil
    public fileprivate(set) var hasConnected:Bool = false

    public fileprivate(set) var riderId:Int32! = nil
    public fileprivate(set) var hasRiderId:Bool = false

    public fileprivate(set) var worldTime:Int64! = nil
    public fileprivate(set) var hasWorldTime:Bool = false

    public fileprivate(set) var state:PlayerState!
    public fileprivate(set) var hasState:Bool = false
    public fileprivate(set) var seqno:Int32! = nil
    public fileprivate(set) var hasSeqno:Bool = false

    public fileprivate(set) var tag8:Int64! = nil
    public fileprivate(set) var hasTag8:Bool = false

    public fileprivate(set) var tag9:Int64! = nil
    public fileprivate(set) var hasTag9:Bool = false

    public fileprivate(set) var lastUpdate:Int64! = nil
    public fileprivate(set) var hasLastUpdate:Bool = false

    public fileprivate(set) var tag11:Int64! = nil
    public fileprivate(set) var hasTag11:Bool = false

    public fileprivate(set) var lastPlayerUpdate:Int64! = nil
    public fileprivate(set) var hasLastPlayerUpdate:Bool = false

    required public init() {
        super.init()
    }
    
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasConnected {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:connected)
        }
        if hasRiderId {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:riderId)
        }
        if hasWorldTime {
            try codedOutputStream.writeInt64(fieldNumber: 3, value:worldTime)
        }
        if hasSeqno {
            try codedOutputStream.writeInt32(fieldNumber: 4, value:seqno)
        }
        if hasState {
            try codedOutputStream.writeMessage(fieldNumber: 7, value:state)
        }
        if hasTag8 {
            try codedOutputStream.writeInt64(fieldNumber: 8, value:tag8)
        }
        if hasTag9 {
            try codedOutputStream.writeInt64(fieldNumber: 9, value:tag9)
        }
        if hasLastUpdate {
            try codedOutputStream.writeInt64(fieldNumber: 10, value:lastUpdate)
        }
        if hasTag11 {
            try codedOutputStream.writeInt64(fieldNumber: 11, value:tag11)
        }
        if hasLastPlayerUpdate {
            try codedOutputStream.writeInt64(fieldNumber: 12, value:lastPlayerUpdate)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasConnected {
            serialize_size += connected.computeInt32Size(fieldNumber: 1)
        }
        if hasRiderId {
            serialize_size += riderId.computeInt32Size(fieldNumber: 2)
        }
        if hasWorldTime {
            serialize_size += worldTime.computeInt64Size(fieldNumber: 3)
        }
        if hasSeqno {
            serialize_size += seqno.computeInt32Size(fieldNumber: 4)
        }
        if hasState {
            if let varSizestate = state?.computeMessageSize(fieldNumber: 7) {
                serialize_size += varSizestate
            }
        }
        if hasTag8 {
            serialize_size += tag8.computeInt64Size(fieldNumber: 8)
        }
        if hasTag9 {
            serialize_size += tag9.computeInt64Size(fieldNumber: 9)
        }
        if hasLastUpdate {
            serialize_size += lastUpdate.computeInt64Size(fieldNumber: 10)
        }
        if hasTag11 {
            serialize_size += tag11.computeInt64Size(fieldNumber: 11)
        }
        if hasLastPlayerUpdate {
            serialize_size += lastPlayerUpdate.computeInt64Size(fieldNumber: 12)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> ClientToServer.Builder {
        return ClientToServer.classBuilder() as! ClientToServer.Builder
    }
    public func getBuilder() -> ClientToServer.Builder {
        return classBuilder() as! ClientToServer.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ClientToServer.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ClientToServer.Builder()
    }
    public func toBuilder() throws -> ClientToServer.Builder {
        return try ClientToServer.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:ClientToServer) throws -> ClientToServer.Builder {
        return try ClientToServer.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasConnected {
            jsonMap["connected"] = Int(connected)
        }
        if hasRiderId {
            jsonMap["riderId"] = Int(riderId)
        }
        if hasWorldTime {
            jsonMap["worldTime"] = "\(worldTime!)"
        }
        if hasState {
            jsonMap["state"] = try state.encode()
        }
        if hasSeqno {
            jsonMap["seqno"] = Int(seqno)
        }
        if hasTag8 {
            jsonMap["tag8"] = "\(tag8!)"
        }
        if hasTag9 {
            jsonMap["tag9"] = "\(tag9!)"
        }
        if hasLastUpdate {
            jsonMap["lastUpdate"] = "\(lastUpdate!)"
        }
        if hasTag11 {
            jsonMap["tag11"] = "\(tag11!)"
        }
        if hasLastPlayerUpdate {
            jsonMap["lastPlayerUpdate"] = "\(lastPlayerUpdate!)"
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ClientToServer {
        return try ClientToServer.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> ClientToServer {
        return try ClientToServer.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasConnected {
            output += "\(indent) connected: \(connected) \n"
        }
        if hasRiderId {
            output += "\(indent) riderId: \(riderId) \n"
        }
        if hasWorldTime {
            output += "\(indent) worldTime: \(worldTime) \n"
        }
        if hasSeqno {
            output += "\(indent) seqno: \(seqno) \n"
        }
        if hasState {
            output += "\(indent) state {\n"
            if let outDescState = state {
                output += try outDescState.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasTag8 {
            output += "\(indent) tag8: \(tag8) \n"
        }
        if hasTag9 {
            output += "\(indent) tag9: \(tag9) \n"
        }
        if hasLastUpdate {
            output += "\(indent) lastUpdate: \(lastUpdate) \n"
        }
        if hasTag11 {
            output += "\(indent) tag11: \(tag11) \n"
        }
        if hasLastPlayerUpdate {
            output += "\(indent) lastPlayerUpdate: \(lastPlayerUpdate) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasConnected {
                hashCode = (hashCode &* 31) &+ connected.hashValue
            }
            if hasRiderId {
                hashCode = (hashCode &* 31) &+ riderId.hashValue
            }
            if hasWorldTime {
                hashCode = (hashCode &* 31) &+ worldTime.hashValue
            }
            if hasSeqno {
                hashCode = (hashCode &* 31) &+ seqno.hashValue
            }
            if hasState {
                if let hashValuestate = state?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuestate
                }
            }
            if hasTag8 {
                hashCode = (hashCode &* 31) &+ tag8.hashValue
            }
            if hasTag9 {
                hashCode = (hashCode &* 31) &+ tag9.hashValue
            }
            if hasLastUpdate {
                hashCode = (hashCode &* 31) &+ lastUpdate.hashValue
            }
            if hasTag11 {
                hashCode = (hashCode &* 31) &+ tag11.hashValue
            }
            if hasLastPlayerUpdate {
                hashCode = (hashCode &* 31) &+ lastPlayerUpdate.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ClientToServer"
    }
    override public func className() -> String {
        return "ClientToServer"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:ClientToServer = ClientToServer()
        public func getMessage() -> ClientToServer {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var connected:Int32 {
            get {
                return builderResult.connected
            }
            set (value) {
                builderResult.hasConnected = true
                builderResult.connected = value
            }
        }
        public var hasConnected:Bool {
            get {
                return builderResult.hasConnected
            }
        }
        @discardableResult
        public func setConnected(_ value:Int32) -> ClientToServer.Builder {
            self.connected = value
            return self
        }
        @discardableResult
        public func clearConnected() -> ClientToServer.Builder{
            builderResult.hasConnected = false
            builderResult.connected = nil
            return self
        }
        public var riderId:Int32 {
            get {
                return builderResult.riderId
            }
            set (value) {
                builderResult.hasRiderId = true
                builderResult.riderId = value
            }
        }
        public var hasRiderId:Bool {
            get {
                return builderResult.hasRiderId
            }
        }
        @discardableResult
        public func setRiderId(_ value:Int32) -> ClientToServer.Builder {
            self.riderId = value
            return self
        }
        @discardableResult
        public func clearRiderId() -> ClientToServer.Builder{
            builderResult.hasRiderId = false
            builderResult.riderId = nil
            return self
        }
        public var worldTime:Int64 {
            get {
                return builderResult.worldTime
            }
            set (value) {
                builderResult.hasWorldTime = true
                builderResult.worldTime = value
            }
        }
        public var hasWorldTime:Bool {
            get {
                return builderResult.hasWorldTime
            }
        }
        @discardableResult
        public func setWorldTime(_ value:Int64) -> ClientToServer.Builder {
            self.worldTime = value
            return self
        }
        @discardableResult
        public func clearWorldTime() -> ClientToServer.Builder{
            builderResult.hasWorldTime = false
            builderResult.worldTime = nil
            return self
        }
        public var state:PlayerState! {
            get {
                if stateBuilder_ != nil {
                    builderResult.state = stateBuilder_.getMessage()
                }
                return builderResult.state
            }
            set (value) {
                builderResult.hasState = value != nil
                builderResult.state = value
            }
        }
        public var hasState:Bool {
            get {
                return builderResult.hasState
            }
        }
        fileprivate var stateBuilder_:PlayerState.Builder! {
            didSet {
                builderResult.hasState = true
            }
        }
        public func getStateBuilder() -> PlayerState.Builder {
            if stateBuilder_ == nil {
                stateBuilder_ = PlayerState.Builder()
                builderResult.state = stateBuilder_.getMessage()
                if state != nil {
                    try! stateBuilder_.mergeFrom(other: state)
                }
            }
            return stateBuilder_
        }
        @discardableResult
        public func setState(_ value:PlayerState!) -> ClientToServer.Builder {
            self.state = value
            return self
        }
        @discardableResult
        public func mergeState(value:PlayerState) throws -> ClientToServer.Builder {
            if builderResult.hasState {
                builderResult.state = try PlayerState.builderWithPrototype(prototype:builderResult.state).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.state = value
            }
            builderResult.hasState = true
            return self
        }
        @discardableResult
        public func clearState() -> ClientToServer.Builder {
            stateBuilder_ = nil
            builderResult.hasState = false
            builderResult.state = nil
            return self
        }
        public var seqno:Int32 {
            get {
                return builderResult.seqno
            }
            set (value) {
                builderResult.hasSeqno = true
                builderResult.seqno = value
            }
        }
        public var hasSeqno:Bool {
            get {
                return builderResult.hasSeqno
            }
        }
        @discardableResult
        public func setSeqno(_ value:Int32) -> ClientToServer.Builder {
            self.seqno = value
            return self
        }
        @discardableResult
        public func clearSeqno() -> ClientToServer.Builder{
            builderResult.hasSeqno = false
            builderResult.seqno = nil
            return self
        }
        public var tag8:Int64 {
            get {
                return builderResult.tag8
            }
            set (value) {
                builderResult.hasTag8 = true
                builderResult.tag8 = value
            }
        }
        public var hasTag8:Bool {
            get {
                return builderResult.hasTag8
            }
        }
        @discardableResult
        public func setTag8(_ value:Int64) -> ClientToServer.Builder {
            self.tag8 = value
            return self
        }
        @discardableResult
        public func clearTag8() -> ClientToServer.Builder{
            builderResult.hasTag8 = false
            builderResult.tag8 = nil
            return self
        }
        public var tag9:Int64 {
            get {
                return builderResult.tag9
            }
            set (value) {
                builderResult.hasTag9 = true
                builderResult.tag9 = value
            }
        }
        public var hasTag9:Bool {
            get {
                return builderResult.hasTag9
            }
        }
        @discardableResult
        public func setTag9(_ value:Int64) -> ClientToServer.Builder {
            self.tag9 = value
            return self
        }
        @discardableResult
        public func clearTag9() -> ClientToServer.Builder{
            builderResult.hasTag9 = false
            builderResult.tag9 = nil
            return self
        }
        public var lastUpdate:Int64 {
            get {
                return builderResult.lastUpdate
            }
            set (value) {
                builderResult.hasLastUpdate = true
                builderResult.lastUpdate = value
            }
        }
        public var hasLastUpdate:Bool {
            get {
                return builderResult.hasLastUpdate
            }
        }
        @discardableResult
        public func setLastUpdate(_ value:Int64) -> ClientToServer.Builder {
            self.lastUpdate = value
            return self
        }
        @discardableResult
        public func clearLastUpdate() -> ClientToServer.Builder{
            builderResult.hasLastUpdate = false
            builderResult.lastUpdate = nil
            return self
        }
        public var tag11:Int64 {
            get {
                return builderResult.tag11
            }
            set (value) {
                builderResult.hasTag11 = true
                builderResult.tag11 = value
            }
        }
        public var hasTag11:Bool {
            get {
                return builderResult.hasTag11
            }
        }
        @discardableResult
        public func setTag11(_ value:Int64) -> ClientToServer.Builder {
            self.tag11 = value
            return self
        }
        @discardableResult
        public func clearTag11() -> ClientToServer.Builder{
            builderResult.hasTag11 = false
            builderResult.tag11 = nil
            return self
        }
        public var lastPlayerUpdate:Int64 {
            get {
                return builderResult.lastPlayerUpdate
            }
            set (value) {
                builderResult.hasLastPlayerUpdate = true
                builderResult.lastPlayerUpdate = value
            }
        }
        public var hasLastPlayerUpdate:Bool {
            get {
                return builderResult.hasLastPlayerUpdate
            }
        }
        @discardableResult
        public func setLastPlayerUpdate(_ value:Int64) -> ClientToServer.Builder {
            self.lastPlayerUpdate = value
            return self
        }
        @discardableResult
        public func clearLastPlayerUpdate() -> ClientToServer.Builder{
            builderResult.hasLastPlayerUpdate = false
            builderResult.lastPlayerUpdate = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> ClientToServer.Builder {
            builderResult = ClientToServer()
            return self
        }
        override public func clone() throws -> ClientToServer.Builder {
            return try ClientToServer.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> ClientToServer {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> ClientToServer {
            let returnMe:ClientToServer = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:ClientToServer) throws -> ClientToServer.Builder {
            if other == ClientToServer() {
                return self
            }
            if other.hasConnected {
                connected = other.connected
            }
            if other.hasRiderId {
                riderId = other.riderId
            }
            if other.hasWorldTime {
                worldTime = other.worldTime
            }
            if (other.hasState) {
                try mergeState(value: other.state)
            }
            if other.hasSeqno {
                seqno = other.seqno
            }
            if other.hasTag8 {
                tag8 = other.tag8
            }
            if other.hasTag9 {
                tag9 = other.tag9
            }
            if other.hasLastUpdate {
                lastUpdate = other.lastUpdate
            }
            if other.hasTag11 {
                tag11 = other.tag11
            }
            if other.hasLastPlayerUpdate {
                lastPlayerUpdate = other.lastPlayerUpdate
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ClientToServer.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ClientToServer.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    connected = try codedInputStream.readInt32()

                case 16:
                    riderId = try codedInputStream.readInt32()

                case 24:
                    worldTime = try codedInputStream.readInt64()

                case 32:
                    seqno = try codedInputStream.readInt32()

                case 58:
                    let subBuilder:PlayerState.Builder = PlayerState.Builder()
                    if hasState {
                        try subBuilder.mergeFrom(other: state)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    state = subBuilder.buildPartial()

                case 64:
                    tag8 = try codedInputStream.readInt64()

                case 72:
                    tag9 = try codedInputStream.readInt64()

                case 80:
                    lastUpdate = try codedInputStream.readInt64()

                case 88:
                    tag11 = try codedInputStream.readInt64()

                case 96:
                    lastPlayerUpdate = try codedInputStream.readInt64()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ClientToServer.Builder {
            let resultDecodedBuilder = ClientToServer.Builder()
            if let jsonValueConnected = jsonMap["connected"] as? Int {
                resultDecodedBuilder.connected = Int32(jsonValueConnected)
            } else if let jsonValueConnected = jsonMap["connected"] as? String {
                resultDecodedBuilder.connected = Int32(jsonValueConnected)!
            }
            if let jsonValueRiderId = jsonMap["riderId"] as? Int {
                resultDecodedBuilder.riderId = Int32(jsonValueRiderId)
            } else if let jsonValueRiderId = jsonMap["riderId"] as? String {
                resultDecodedBuilder.riderId = Int32(jsonValueRiderId)!
            }
            if let jsonValueWorldTime = jsonMap["worldTime"] as? String {
                resultDecodedBuilder.worldTime = Int64(jsonValueWorldTime)!
            } else if let jsonValueWorldTime = jsonMap["worldTime"] as? Int {
                resultDecodedBuilder.worldTime = Int64(jsonValueWorldTime)
            }
            if let jsonValueState = jsonMap["state"] as? Dictionary<String,Any> {
                resultDecodedBuilder.state = try PlayerState.Builder.decodeToBuilder(jsonMap:jsonValueState).build()

            }
            if let jsonValueSeqno = jsonMap["seqno"] as? Int {
                resultDecodedBuilder.seqno = Int32(jsonValueSeqno)
            } else if let jsonValueSeqno = jsonMap["seqno"] as? String {
                resultDecodedBuilder.seqno = Int32(jsonValueSeqno)!
            }
            if let jsonValueTag8 = jsonMap["tag8"] as? String {
                resultDecodedBuilder.tag8 = Int64(jsonValueTag8)!
            } else if let jsonValueTag8 = jsonMap["tag8"] as? Int {
                resultDecodedBuilder.tag8 = Int64(jsonValueTag8)
            }
            if let jsonValueTag9 = jsonMap["tag9"] as? String {
                resultDecodedBuilder.tag9 = Int64(jsonValueTag9)!
            } else if let jsonValueTag9 = jsonMap["tag9"] as? Int {
                resultDecodedBuilder.tag9 = Int64(jsonValueTag9)
            }
            if let jsonValueLastUpdate = jsonMap["lastUpdate"] as? String {
                resultDecodedBuilder.lastUpdate = Int64(jsonValueLastUpdate)!
            } else if let jsonValueLastUpdate = jsonMap["lastUpdate"] as? Int {
                resultDecodedBuilder.lastUpdate = Int64(jsonValueLastUpdate)
            }
            if let jsonValueTag11 = jsonMap["tag11"] as? String {
                resultDecodedBuilder.tag11 = Int64(jsonValueTag11)!
            } else if let jsonValueTag11 = jsonMap["tag11"] as? Int {
                resultDecodedBuilder.tag11 = Int64(jsonValueTag11)
            }
            if let jsonValueLastPlayerUpdate = jsonMap["lastPlayerUpdate"] as? String {
                resultDecodedBuilder.lastPlayerUpdate = Int64(jsonValueLastPlayerUpdate)!
            } else if let jsonValueLastPlayerUpdate = jsonMap["lastPlayerUpdate"] as? Int {
                resultDecodedBuilder.lastPlayerUpdate = Int64(jsonValueLastPlayerUpdate)
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> ClientToServer.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try ClientToServer.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class SegmentResult : GeneratedMessage {
    public typealias BuilderType = SegmentResult.Builder

    public static func == (lhs: SegmentResult, rhs: SegmentResult) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasRiderId == rhs.hasRiderId) && (!lhs.hasRiderId || lhs.riderId == rhs.riderId)
        fieldCheck = fieldCheck && (lhs.hasEventSubgroupId == rhs.hasEventSubgroupId) && (!lhs.hasEventSubgroupId || lhs.eventSubgroupId == rhs.eventSubgroupId)
        fieldCheck = fieldCheck && (lhs.hasFirstName == rhs.hasFirstName) && (!lhs.hasFirstName || lhs.firstName == rhs.firstName)
        fieldCheck = fieldCheck && (lhs.hasLastName == rhs.hasLastName) && (!lhs.hasLastName || lhs.lastName == rhs.lastName)
        fieldCheck = fieldCheck && (lhs.hasFinishTimeStr == rhs.hasFinishTimeStr) && (!lhs.hasFinishTimeStr || lhs.finishTimeStr == rhs.finishTimeStr)
        fieldCheck = fieldCheck && (lhs.hasElapsedMs == rhs.hasElapsedMs) && (!lhs.hasElapsedMs || lhs.elapsedMs == rhs.elapsedMs)
        fieldCheck = fieldCheck && (lhs.hasPowermeter == rhs.hasPowermeter) && (!lhs.hasPowermeter || lhs.powermeter == rhs.powermeter)
        fieldCheck = fieldCheck && (lhs.hasWeight == rhs.hasWeight) && (!lhs.hasWeight || lhs.weight == rhs.weight)
        fieldCheck = fieldCheck && (lhs.hasPower == rhs.hasPower) && (!lhs.hasPower || lhs.power == rhs.power)
        fieldCheck = fieldCheck && (lhs.hasHeartrate == rhs.hasHeartrate) && (!lhs.hasHeartrate || lhs.heartrate == rhs.heartrate)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int64! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var riderId:Int64! = nil
    public fileprivate(set) var hasRiderId:Bool = false

    public fileprivate(set) var eventSubgroupId:Int64! = nil
    public fileprivate(set) var hasEventSubgroupId:Bool = false

    public fileprivate(set) var firstName:String! = nil
    public fileprivate(set) var hasFirstName:Bool = false

    public fileprivate(set) var lastName:String! = nil
    public fileprivate(set) var hasLastName:Bool = false

    public fileprivate(set) var finishTimeStr:String! = nil
    public fileprivate(set) var hasFinishTimeStr:Bool = false

    public fileprivate(set) var elapsedMs:Int64! = nil
    public fileprivate(set) var hasElapsedMs:Bool = false

    public fileprivate(set) var powermeter:Int32! = nil
    public fileprivate(set) var hasPowermeter:Bool = false

    public fileprivate(set) var weight:Int32! = nil
    public fileprivate(set) var hasWeight:Bool = false

    public fileprivate(set) var power:Int32! = nil
    public fileprivate(set) var hasPower:Bool = false

    public fileprivate(set) var heartrate:Int32! = nil
    public fileprivate(set) var hasHeartrate:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
        }
        if hasRiderId {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:riderId)
        }
        if hasEventSubgroupId {
            try codedOutputStream.writeInt64(fieldNumber: 6, value:eventSubgroupId)
        }
        if hasFirstName {
            try codedOutputStream.writeString(fieldNumber: 7, value:firstName)
        }
        if hasLastName {
            try codedOutputStream.writeString(fieldNumber: 8, value:lastName)
        }
        if hasFinishTimeStr {
            try codedOutputStream.writeString(fieldNumber: 10, value:finishTimeStr)
        }
        if hasElapsedMs {
            try codedOutputStream.writeInt64(fieldNumber: 11, value:elapsedMs)
        }
        if hasPowermeter {
            try codedOutputStream.writeInt32(fieldNumber: 12, value:powermeter)
        }
        if hasWeight {
            try codedOutputStream.writeInt32(fieldNumber: 13, value:weight)
        }
        if hasPower {
            try codedOutputStream.writeInt32(fieldNumber: 15, value:power)
        }
        if hasHeartrate {
            try codedOutputStream.writeInt32(fieldNumber: 19, value:heartrate)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt64Size(fieldNumber: 1)
        }
        if hasRiderId {
            serialize_size += riderId.computeInt64Size(fieldNumber: 2)
        }
        if hasEventSubgroupId {
            serialize_size += eventSubgroupId.computeInt64Size(fieldNumber: 6)
        }
        if hasFirstName {
            serialize_size += firstName.computeStringSize(fieldNumber: 7)
        }
        if hasLastName {
            serialize_size += lastName.computeStringSize(fieldNumber: 8)
        }
        if hasFinishTimeStr {
            serialize_size += finishTimeStr.computeStringSize(fieldNumber: 10)
        }
        if hasElapsedMs {
            serialize_size += elapsedMs.computeInt64Size(fieldNumber: 11)
        }
        if hasPowermeter {
            serialize_size += powermeter.computeInt32Size(fieldNumber: 12)
        }
        if hasWeight {
            serialize_size += weight.computeInt32Size(fieldNumber: 13)
        }
        if hasPower {
            serialize_size += power.computeInt32Size(fieldNumber: 15)
        }
        if hasHeartrate {
            serialize_size += heartrate.computeInt32Size(fieldNumber: 19)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> SegmentResult.Builder {
        return SegmentResult.classBuilder() as! SegmentResult.Builder
    }
    public func getBuilder() -> SegmentResult.Builder {
        return classBuilder() as! SegmentResult.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return SegmentResult.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return SegmentResult.Builder()
    }
    public func toBuilder() throws -> SegmentResult.Builder {
        return try SegmentResult.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:SegmentResult) throws -> SegmentResult.Builder {
        return try SegmentResult.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
            return jsonMap
        }
        if hasId {
            jsonMap["id"] = "\(id!)"
        }
        if hasRiderId {
            jsonMap["riderId"] = "\(riderId!)"
        }
        if hasEventSubgroupId {
            jsonMap["eventSubgroupId"] = "\(eventSubgroupId!)"
        }
        if hasFirstName {
            jsonMap["firstName"] = firstName
        }
        if hasLastName {
            jsonMap["lastName"] = lastName
        }
        if hasFinishTimeStr {
            jsonMap["finishTimeStr"] = finishTimeStr
        }
        if hasElapsedMs {
            jsonMap["elapsedMs"] = "\(elapsedMs!)"
        }
        if hasPowermeter {
            jsonMap["powermeter"] = Int(powermeter)
        }
        if hasWeight {
            jsonMap["weight"] = Int(weight)
        }
        if hasPower {
            jsonMap["power"] = Int(power)
        }
        if hasHeartrate {
            jsonMap["heartrate"] = Int(heartrate)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SegmentResult {
        return try SegmentResult.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> SegmentResult {
        return try SegmentResult.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasRiderId {
            output += "\(indent) riderId: \(riderId) \n"
        }
        if hasEventSubgroupId {
            output += "\(indent) eventSubgroupId: \(eventSubgroupId) \n"
        }
        if hasFirstName {
            output += "\(indent) firstName: \(firstName) \n"
        }
        if hasLastName {
            output += "\(indent) lastName: \(lastName) \n"
        }
        if hasFinishTimeStr {
            output += "\(indent) finishTimeStr: \(finishTimeStr) \n"
        }
        if hasElapsedMs {
            output += "\(indent) elapsedMs: \(elapsedMs) \n"
        }
        if hasPowermeter {
            output += "\(indent) powermeter: \(powermeter) \n"
        }
        if hasWeight {
            output += "\(indent) weight: \(weight) \n"
        }
        if hasPower {
            output += "\(indent) power: \(power) \n"
        }
        if hasHeartrate {
            output += "\(indent) heartrate: \(heartrate) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasRiderId {
                hashCode = (hashCode &* 31) &+ riderId.hashValue
            }
            if hasEventSubgroupId {
                hashCode = (hashCode &* 31) &+ eventSubgroupId.hashValue
            }
            if hasFirstName {
                hashCode = (hashCode &* 31) &+ firstName.hashValue
            }
            if hasLastName {
                hashCode = (hashCode &* 31) &+ lastName.hashValue
            }
            if hasFinishTimeStr {
                hashCode = (hashCode &* 31) &+ finishTimeStr.hashValue
            }
            if hasElapsedMs {
                hashCode = (hashCode &* 31) &+ elapsedMs.hashValue
            }
            if hasPowermeter {
                hashCode = (hashCode &* 31) &+ powermeter.hashValue
            }
            if hasWeight {
                hashCode = (hashCode &* 31) &+ weight.hashValue
            }
            if hasPower {
                hashCode = (hashCode &* 31) &+ power.hashValue
            }
            if hasHeartrate {
                hashCode = (hashCode &* 31) &+ heartrate.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "SegmentResult"
    }
    override public func className() -> String {
        return "SegmentResult"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:SegmentResult = SegmentResult()
        public func getMessage() -> SegmentResult {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int64 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int64) -> SegmentResult.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> SegmentResult.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var riderId:Int64 {
            get {
                return builderResult.riderId
            }
            set (value) {
                builderResult.hasRiderId = true
                builderResult.riderId = value
            }
        }
        public var hasRiderId:Bool {
            get {
                return builderResult.hasRiderId
            }
        }
        @discardableResult
        public func setRiderId(_ value:Int64) -> SegmentResult.Builder {
            self.riderId = value
            return self
        }
        @discardableResult
        public func clearRiderId() -> SegmentResult.Builder{
            builderResult.hasRiderId = false
            builderResult.riderId = nil
            return self
        }
        public var eventSubgroupId:Int64 {
            get {
                return builderResult.eventSubgroupId
            }
            set (value) {
                builderResult.hasEventSubgroupId = true
                builderResult.eventSubgroupId = value
            }
        }
        public var hasEventSubgroupId:Bool {
            get {
                return builderResult.hasEventSubgroupId
            }
        }
        @discardableResult
        public func setEventSubgroupId(_ value:Int64) -> SegmentResult.Builder {
            self.eventSubgroupId = value
            return self
        }
        @discardableResult
        public func clearEventSubgroupId() -> SegmentResult.Builder{
            builderResult.hasEventSubgroupId = false
            builderResult.eventSubgroupId = nil
            return self
        }
        public var firstName:String {
            get {
                return builderResult.firstName
            }
            set (value) {
                builderResult.hasFirstName = true
                builderResult.firstName = value
            }
        }
        public var hasFirstName:Bool {
            get {
                return builderResult.hasFirstName
            }
        }
        @discardableResult
        public func setFirstName(_ value:String) -> SegmentResult.Builder {
            self.firstName = value
            return self
        }
        @discardableResult
        public func clearFirstName() -> SegmentResult.Builder{
            builderResult.hasFirstName = false
            builderResult.firstName = nil
            return self
        }
        public var lastName:String {
            get {
                return builderResult.lastName
            }
            set (value) {
                builderResult.hasLastName = true
                builderResult.lastName = value
            }
        }
        public var hasLastName:Bool {
            get {
                return builderResult.hasLastName
            }
        }
        @discardableResult
        public func setLastName(_ value:String) -> SegmentResult.Builder {
            self.lastName = value
            return self
        }
        @discardableResult
        public func clearLastName() -> SegmentResult.Builder{
            builderResult.hasLastName = false
            builderResult.lastName = nil
            return self
        }
        public var finishTimeStr:String {
            get {
                return builderResult.finishTimeStr
            }
            set (value) {
                builderResult.hasFinishTimeStr = true
                builderResult.finishTimeStr = value
            }
        }
        public var hasFinishTimeStr:Bool {
            get {
                return builderResult.hasFinishTimeStr
            }
        }
        @discardableResult
        public func setFinishTimeStr(_ value:String) -> SegmentResult.Builder {
            self.finishTimeStr = value
            return self
        }
        @discardableResult
        public func clearFinishTimeStr() -> SegmentResult.Builder{
            builderResult.hasFinishTimeStr = false
            builderResult.finishTimeStr = nil
            return self
        }
        public var elapsedMs:Int64 {
            get {
                return builderResult.elapsedMs
            }
            set (value) {
                builderResult.hasElapsedMs = true
                builderResult.elapsedMs = value
            }
        }
        public var hasElapsedMs:Bool {
            get {
                return builderResult.hasElapsedMs
            }
        }
        @discardableResult
        public func setElapsedMs(_ value:Int64) -> SegmentResult.Builder {
            self.elapsedMs = value
            return self
        }
        @discardableResult
        public func clearElapsedMs() -> SegmentResult.Builder{
            builderResult.hasElapsedMs = false
            builderResult.elapsedMs = nil
            return self
        }
        public var powermeter:Int32 {
            get {
                return builderResult.powermeter
            }
            set (value) {
                builderResult.hasPowermeter = true
                builderResult.powermeter = value
            }
        }
        public var hasPowermeter:Bool {
            get {
                return builderResult.hasPowermeter
            }
        }
        @discardableResult
        public func setPowermeter(_ value:Int32) -> SegmentResult.Builder {
            self.powermeter = value
            return self
        }
        @discardableResult
        public func clearPowermeter() -> SegmentResult.Builder{
            builderResult.hasPowermeter = false
            builderResult.powermeter = nil
            return self
        }
        public var weight:Int32 {
            get {
                return builderResult.weight
            }
            set (value) {
                builderResult.hasWeight = true
                builderResult.weight = value
            }
        }
        public var hasWeight:Bool {
            get {
                return builderResult.hasWeight
            }
        }
        @discardableResult
        public func setWeight(_ value:Int32) -> SegmentResult.Builder {
            self.weight = value
            return self
        }
        @discardableResult
        public func clearWeight() -> SegmentResult.Builder{
            builderResult.hasWeight = false
            builderResult.weight = nil
            return self
        }
        public var power:Int32 {
            get {
                return builderResult.power
            }
            set (value) {
                builderResult.hasPower = true
                builderResult.power = value
            }
        }
        public var hasPower:Bool {
            get {
                return builderResult.hasPower
            }
        }
        @discardableResult
        public func setPower(_ value:Int32) -> SegmentResult.Builder {
            self.power = value
            return self
        }
        @discardableResult
        public func clearPower() -> SegmentResult.Builder{
            builderResult.hasPower = false
            builderResult.power = nil
            return self
        }
        public var heartrate:Int32 {
            get {
                return builderResult.heartrate
            }
            set (value) {
                builderResult.hasHeartrate = true
                builderResult.heartrate = value
            }
        }
        public var hasHeartrate:Bool {
            get {
                return builderResult.hasHeartrate
            }
        }
        @discardableResult
        public func setHeartrate(_ value:Int32) -> SegmentResult.Builder {
            self.heartrate = value
            return self
        }
        @discardableResult
        public func clearHeartrate() -> SegmentResult.Builder{
            builderResult.hasHeartrate = false
            builderResult.heartrate = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> SegmentResult.Builder {
            builderResult = SegmentResult()
            return self
        }
        override public func clone() throws -> SegmentResult.Builder {
            return try SegmentResult.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> SegmentResult {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> SegmentResult {
            let returnMe:SegmentResult = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:SegmentResult) throws -> SegmentResult.Builder {
            if other == SegmentResult() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasRiderId {
                riderId = other.riderId
            }
            if other.hasEventSubgroupId {
                eventSubgroupId = other.eventSubgroupId
            }
            if other.hasFirstName {
                firstName = other.firstName
            }
            if other.hasLastName {
                lastName = other.lastName
            }
            if other.hasFinishTimeStr {
                finishTimeStr = other.finishTimeStr
            }
            if other.hasElapsedMs {
                elapsedMs = other.elapsedMs
            }
            if other.hasPowermeter {
                powermeter = other.powermeter
            }
            if other.hasWeight {
                weight = other.weight
            }
            if other.hasPower {
                power = other.power
            }
            if other.hasHeartrate {
                heartrate = other.heartrate
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SegmentResult.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SegmentResult.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt64()

                case 16:
                    riderId = try codedInputStream.readInt64()

                case 48:
                    eventSubgroupId = try codedInputStream.readInt64()

                case 58:
                    firstName = try codedInputStream.readString()

                case 66:
                    lastName = try codedInputStream.readString()

                case 82:
                    finishTimeStr = try codedInputStream.readString()

                case 88:
                    elapsedMs = try codedInputStream.readInt64()

                case 96:
                    powermeter = try codedInputStream.readInt32()

                case 104:
                    weight = try codedInputStream.readInt32()

                case 120:
                    power = try codedInputStream.readInt32()

                case 152:
                    heartrate = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SegmentResult.Builder {
            let resultDecodedBuilder = SegmentResult.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int64(jsonValueId)!
            } else if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int64(jsonValueId)
            }
            if let jsonValueRiderId = jsonMap["riderId"] as? String {
                resultDecodedBuilder.riderId = Int64(jsonValueRiderId)!
            } else if let jsonValueRiderId = jsonMap["riderId"] as? Int {
                resultDecodedBuilder.riderId = Int64(jsonValueRiderId)
            }
            if let jsonValueEventSubgroupId = jsonMap["eventSubgroupId"] as? String {
                resultDecodedBuilder.eventSubgroupId = Int64(jsonValueEventSubgroupId)!
            } else if let jsonValueEventSubgroupId = jsonMap["eventSubgroupId"] as? Int {
                resultDecodedBuilder.eventSubgroupId = Int64(jsonValueEventSubgroupId)
            }
            if let jsonValueFirstName = jsonMap["firstName"] as? String {
                resultDecodedBuilder.firstName = jsonValueFirstName
            }
            if let jsonValueLastName = jsonMap["lastName"] as? String {
                resultDecodedBuilder.lastName = jsonValueLastName
            }
            if let jsonValueFinishTimeStr = jsonMap["finishTimeStr"] as? String {
                resultDecodedBuilder.finishTimeStr = jsonValueFinishTimeStr
            }
            if let jsonValueElapsedMs = jsonMap["elapsedMs"] as? String {
                resultDecodedBuilder.elapsedMs = Int64(jsonValueElapsedMs)!
            } else if let jsonValueElapsedMs = jsonMap["elapsedMs"] as? Int {
                resultDecodedBuilder.elapsedMs = Int64(jsonValueElapsedMs)
            }
            if let jsonValuePowermeter = jsonMap["powermeter"] as? Int {
                resultDecodedBuilder.powermeter = Int32(jsonValuePowermeter)
            } else if let jsonValuePowermeter = jsonMap["powermeter"] as? String {
                resultDecodedBuilder.powermeter = Int32(jsonValuePowermeter)!
            }
            if let jsonValueWeight = jsonMap["weight"] as? Int {
                resultDecodedBuilder.weight = Int32(jsonValueWeight)
            } else if let jsonValueWeight = jsonMap["weight"] as? String {
                resultDecodedBuilder.weight = Int32(jsonValueWeight)!
            }
            if let jsonValuePower = jsonMap["power"] as? Int {
                resultDecodedBuilder.power = Int32(jsonValuePower)
            } else if let jsonValuePower = jsonMap["power"] as? String {
                resultDecodedBuilder.power = Int32(jsonValuePower)!
            }
            if let jsonValueHeartrate = jsonMap["heartrate"] as? Int {
                resultDecodedBuilder.heartrate = Int32(jsonValueHeartrate)
            } else if let jsonValueHeartrate = jsonMap["heartrate"] as? String {
                resultDecodedBuilder.heartrate = Int32(jsonValueHeartrate)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> SegmentResult.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try SegmentResult.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class SegmentResults : GeneratedMessage {
    public typealias BuilderType = SegmentResults.Builder

    public static func == (lhs: SegmentResults, rhs: SegmentResults) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasWorldId == rhs.hasWorldId) && (!lhs.hasWorldId || lhs.worldId == rhs.worldId)
        fieldCheck = fieldCheck && (lhs.hasSegmentId == rhs.hasSegmentId) && (!lhs.hasSegmentId || lhs.segmentId == rhs.segmentId)
        fieldCheck = fieldCheck && (lhs.hasEventSubgroupId == rhs.hasEventSubgroupId) && (!lhs.hasEventSubgroupId || lhs.eventSubgroupId == rhs.eventSubgroupId)
        fieldCheck = fieldCheck && (lhs.segmentResults == rhs.segmentResults)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var worldId:Int64! = nil
    public fileprivate(set) var hasWorldId:Bool = false

    public fileprivate(set) var segmentId:Int64! = nil
    public fileprivate(set) var hasSegmentId:Bool = false

    public fileprivate(set) var eventSubgroupId:Int64! = nil
    public fileprivate(set) var hasEventSubgroupId:Bool = false

    public fileprivate(set) var segmentResults:Array<SegmentResult>  = Array<SegmentResult>()
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasWorldId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:worldId)
        }
        if hasSegmentId {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:segmentId)
        }
        if hasEventSubgroupId {
            try codedOutputStream.writeInt64(fieldNumber: 3, value:eventSubgroupId)
        }
        for oneElementSegmentResults in segmentResults {
              try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementSegmentResults)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasWorldId {
            serialize_size += worldId.computeInt64Size(fieldNumber: 1)
        }
        if hasSegmentId {
            serialize_size += segmentId.computeInt64Size(fieldNumber: 2)
        }
        if hasEventSubgroupId {
            serialize_size += eventSubgroupId.computeInt64Size(fieldNumber: 3)
        }
        for oneElementSegmentResults in segmentResults {
            serialize_size += oneElementSegmentResults.computeMessageSize(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> SegmentResults.Builder {
        return SegmentResults.classBuilder() as! SegmentResults.Builder
    }
    public func getBuilder() -> SegmentResults.Builder {
        return classBuilder() as! SegmentResults.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return SegmentResults.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return SegmentResults.Builder()
    }
    public func toBuilder() throws -> SegmentResults.Builder {
        return try SegmentResults.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:SegmentResults) throws -> SegmentResults.Builder {
        return try SegmentResults.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasWorldId {
            jsonMap["worldId"] = "\(worldId!)"
        }
        if hasSegmentId {
            jsonMap["segmentId"] = "\(segmentId!)"
        }
        if hasEventSubgroupId {
            jsonMap["eventSubgroupId"] = "\(eventSubgroupId!)"
        }
        if !segmentResults.isEmpty {
            var jsonArraySegmentResults:Array<Dictionary<String,Any>> = []
            for oneValueSegmentResults in segmentResults {
                let ecodedMessageSegmentResults = try oneValueSegmentResults.encode()
                jsonArraySegmentResults.append(ecodedMessageSegmentResults)
            }
            jsonMap["segmentResults"] = jsonArraySegmentResults
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SegmentResults {
        return try SegmentResults.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> SegmentResults {
        return try SegmentResults.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasWorldId {
            output += "\(indent) worldId: \(worldId) \n"
        }
        if hasSegmentId {
            output += "\(indent) segmentId: \(segmentId) \n"
        }
        if hasEventSubgroupId {
            output += "\(indent) eventSubgroupId: \(eventSubgroupId) \n"
        }
        var segmentResultsElementIndex:Int = 0
        for oneElementSegmentResults in segmentResults {
            output += "\(indent) segmentResults[\(segmentResultsElementIndex)] {\n"
            output += try oneElementSegmentResults.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            segmentResultsElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasWorldId {
                hashCode = (hashCode &* 31) &+ worldId.hashValue
            }
            if hasSegmentId {
                hashCode = (hashCode &* 31) &+ segmentId.hashValue
            }
            if hasEventSubgroupId {
                hashCode = (hashCode &* 31) &+ eventSubgroupId.hashValue
            }
            for oneElementSegmentResults in segmentResults {
                hashCode = (hashCode &* 31) &+ oneElementSegmentResults.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "SegmentResults"
    }
    override public func className() -> String {
        return "SegmentResults"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:SegmentResults = SegmentResults()
        public func getMessage() -> SegmentResults {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var worldId:Int64 {
            get {
                return builderResult.worldId
            }
            set (value) {
                builderResult.hasWorldId = true
                builderResult.worldId = value
            }
        }
        public var hasWorldId:Bool {
            get {
                return builderResult.hasWorldId
            }
        }
        @discardableResult
        public func setWorldId(_ value:Int64) -> SegmentResults.Builder {
            self.worldId = value
            return self
        }
        @discardableResult
        public func clearWorldId() -> SegmentResults.Builder{
            builderResult.hasWorldId = false
            builderResult.worldId = nil
            return self
        }
        public var segmentId:Int64 {
            get {
                return builderResult.segmentId
            }
            set (value) {
                builderResult.hasSegmentId = true
                builderResult.segmentId = value
            }
        }
        public var hasSegmentId:Bool {
            get {
                return builderResult.hasSegmentId
            }
        }
        @discardableResult
        public func setSegmentId(_ value:Int64) -> SegmentResults.Builder {
            self.segmentId = value
            return self
        }
        @discardableResult
        public func clearSegmentId() -> SegmentResults.Builder{
            builderResult.hasSegmentId = false
            builderResult.segmentId = nil
            return self
        }
        public var eventSubgroupId:Int64 {
            get {
                return builderResult.eventSubgroupId
            }
            set (value) {
                builderResult.hasEventSubgroupId = true
                builderResult.eventSubgroupId = value
            }
        }
        public var hasEventSubgroupId:Bool {
            get {
                return builderResult.hasEventSubgroupId
            }
        }
        @discardableResult
        public func setEventSubgroupId(_ value:Int64) -> SegmentResults.Builder {
            self.eventSubgroupId = value
            return self
        }
        @discardableResult
        public func clearEventSubgroupId() -> SegmentResults.Builder{
            builderResult.hasEventSubgroupId = false
            builderResult.eventSubgroupId = nil
            return self
        }
        public var segmentResults:Array<SegmentResult> {
            get {
                return builderResult.segmentResults
            }
            set (value) {
                builderResult.segmentResults = value
            }
        }
        @discardableResult
        public func setSegmentResults(_ value:Array<SegmentResult>) -> SegmentResults.Builder {
            self.segmentResults = value
            return self
        }
        @discardableResult
        public func clearSegmentResults() -> SegmentResults.Builder {
            builderResult.segmentResults.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> SegmentResults.Builder {
            builderResult = SegmentResults()
            return self
        }
        override public func clone() throws -> SegmentResults.Builder {
            return try SegmentResults.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> SegmentResults {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> SegmentResults {
            let returnMe:SegmentResults = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:SegmentResults) throws -> SegmentResults.Builder {
            if other == SegmentResults() {
                return self
            }
            if other.hasWorldId {
                worldId = other.worldId
            }
            if other.hasSegmentId {
                segmentId = other.segmentId
            }
            if other.hasEventSubgroupId {
                eventSubgroupId = other.eventSubgroupId
            }
            if !other.segmentResults.isEmpty  {
                 builderResult.segmentResults += other.segmentResults
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SegmentResults.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SegmentResults.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    worldId = try codedInputStream.readInt64()

                case 16:
                    segmentId = try codedInputStream.readInt64()

                case 24:
                    eventSubgroupId = try codedInputStream.readInt64()

                case 34:
                    let subBuilder = SegmentResult.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    segmentResults.append(subBuilder.buildPartial())

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SegmentResults.Builder {
            let resultDecodedBuilder = SegmentResults.Builder()
            if let jsonValueWorldId = jsonMap["worldId"] as? String {
                resultDecodedBuilder.worldId = Int64(jsonValueWorldId)!
            } else if let jsonValueWorldId = jsonMap["worldId"] as? Int {
                resultDecodedBuilder.worldId = Int64(jsonValueWorldId)
            }
            if let jsonValueSegmentId = jsonMap["segmentId"] as? String {
                resultDecodedBuilder.segmentId = Int64(jsonValueSegmentId)!
            } else if let jsonValueSegmentId = jsonMap["segmentId"] as? Int {
                resultDecodedBuilder.segmentId = Int64(jsonValueSegmentId)
            }
            if let jsonValueEventSubgroupId = jsonMap["eventSubgroupId"] as? String {
                resultDecodedBuilder.eventSubgroupId = Int64(jsonValueEventSubgroupId)!
            } else if let jsonValueEventSubgroupId = jsonMap["eventSubgroupId"] as? Int {
                resultDecodedBuilder.eventSubgroupId = Int64(jsonValueEventSubgroupId)
            }
            if let jsonValueSegmentResults = jsonMap["segmentResults"] as? Array<Dictionary<String,Any>> {
                var jsonArraySegmentResults:Array<SegmentResult> = []
                for oneValueSegmentResults in jsonValueSegmentResults {
                    let messageFromStringSegmentResults = try SegmentResult.Builder.decodeToBuilder(jsonMap:oneValueSegmentResults).build()

                    jsonArraySegmentResults.append(messageFromStringSegmentResults)
                }
                resultDecodedBuilder.segmentResults = jsonArraySegmentResults
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> SegmentResults.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try SegmentResults.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

/// string firstName=7;
/// string lastName=8;
/// string timestamp=17;
final public class UnknownMessage1 : GeneratedMessage {
    public typealias BuilderType = UnknownMessage1.Builder

    public static func == (lhs: UnknownMessage1, rhs: UnknownMessage1) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> UnknownMessage1.Builder {
        return UnknownMessage1.classBuilder() as! UnknownMessage1.Builder
    }
    public func getBuilder() -> UnknownMessage1.Builder {
        return classBuilder() as! UnknownMessage1.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UnknownMessage1.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UnknownMessage1.Builder()
    }
    public func toBuilder() throws -> UnknownMessage1.Builder {
        return try UnknownMessage1.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:UnknownMessage1) throws -> UnknownMessage1.Builder {
        return try UnknownMessage1.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
            return jsonMap
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> UnknownMessage1 {
        return try UnknownMessage1.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> UnknownMessage1 {
        return try UnknownMessage1.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "UnknownMessage1"
    }
    override public func className() -> String {
        return "UnknownMessage1"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:UnknownMessage1 = UnknownMessage1()
        public func getMessage() -> UnknownMessage1 {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> UnknownMessage1.Builder {
            builderResult = UnknownMessage1()
            return self
        }
        override public func clone() throws -> UnknownMessage1.Builder {
            return try UnknownMessage1.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> UnknownMessage1 {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> UnknownMessage1 {
            let returnMe:UnknownMessage1 = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:UnknownMessage1) throws -> UnknownMessage1.Builder {
            if other == UnknownMessage1() {
                return self
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> UnknownMessage1.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UnknownMessage1.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> UnknownMessage1.Builder {
            let resultDecodedBuilder = UnknownMessage1.Builder()
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> UnknownMessage1.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try UnknownMessage1.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

/// int64 tag1=1;
/// UnknownMessage1 tag4=4;
final public class UnknownMessage : GeneratedMessage {
    public typealias BuilderType = UnknownMessage.Builder

    public static func == (lhs: UnknownMessage, rhs: UnknownMessage) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> UnknownMessage.Builder {
        return UnknownMessage.classBuilder() as! UnknownMessage.Builder
    }
    public func getBuilder() -> UnknownMessage.Builder {
        return classBuilder() as! UnknownMessage.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UnknownMessage.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UnknownMessage.Builder()
    }
    public func toBuilder() throws -> UnknownMessage.Builder {
        return try UnknownMessage.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:UnknownMessage) throws -> UnknownMessage.Builder {
        return try UnknownMessage.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
            return jsonMap
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> UnknownMessage {
        return try UnknownMessage.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> UnknownMessage {
        return try UnknownMessage.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "UnknownMessage"
    }
    override public func className() -> String {
        return "UnknownMessage"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:UnknownMessage = UnknownMessage()
        public func getMessage() -> UnknownMessage {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> UnknownMessage.Builder {
            builderResult = UnknownMessage()
            return self
        }
        override public func clone() throws -> UnknownMessage.Builder {
            return try UnknownMessage.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> UnknownMessage {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> UnknownMessage {
            let returnMe:UnknownMessage = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:UnknownMessage) throws -> UnknownMessage.Builder {
            if other == UnknownMessage() {
                return self
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> UnknownMessage.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UnknownMessage.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> UnknownMessage.Builder {
            let resultDecodedBuilder = UnknownMessage.Builder()
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> UnknownMessage.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try UnknownMessage.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class ServerToClient : GeneratedMessage {
    public typealias BuilderType = ServerToClient.Builder

    public static func == (lhs: ServerToClient, rhs: ServerToClient) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasTag1 == rhs.hasTag1) && (!lhs.hasTag1 || lhs.tag1 == rhs.tag1)
        fieldCheck = fieldCheck && (lhs.hasRiderId == rhs.hasRiderId) && (!lhs.hasRiderId || lhs.riderId == rhs.riderId)
        fieldCheck = fieldCheck && (lhs.hasWorldTime == rhs.hasWorldTime) && (!lhs.hasWorldTime || lhs.worldTime == rhs.worldTime)
        fieldCheck = fieldCheck && (lhs.hasSeqno == rhs.hasSeqno) && (!lhs.hasSeqno || lhs.seqno == rhs.seqno)
        fieldCheck = fieldCheck && (lhs.playerStates == rhs.playerStates)
        fieldCheck = fieldCheck && (lhs.playerUpdates == rhs.playerUpdates)
        fieldCheck = fieldCheck && (lhs.hasTag11 == rhs.hasTag11) && (!lhs.hasTag11 || lhs.tag11 == rhs.tag11)
        fieldCheck = fieldCheck && (lhs.hasTag17 == rhs.hasTag17) && (!lhs.hasTag17 || lhs.tag17 == rhs.tag17)
        fieldCheck = fieldCheck && (lhs.hasNumMsgs == rhs.hasNumMsgs) && (!lhs.hasNumMsgs || lhs.numMsgs == rhs.numMsgs)
        fieldCheck = fieldCheck && (lhs.hasMsgnum == rhs.hasMsgnum) && (!lhs.hasMsgnum || lhs.msgnum == rhs.msgnum)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var tag1:Int32! = nil
    public fileprivate(set) var hasTag1:Bool = false

    public fileprivate(set) var riderId:Int32! = nil
    public fileprivate(set) var hasRiderId:Bool = false

    public fileprivate(set) var worldTime:Int64! = nil
    public fileprivate(set) var hasWorldTime:Bool = false

    public fileprivate(set) var seqno:Int32! = nil
    public fileprivate(set) var hasSeqno:Bool = false

    public fileprivate(set) var playerStates:Array<PlayerState>  = Array<PlayerState>()
    public fileprivate(set) var playerUpdates:Array<UnknownMessage>  = Array<UnknownMessage>()
    public fileprivate(set) var tag11:Int64! = nil
    public fileprivate(set) var hasTag11:Bool = false

    public fileprivate(set) var tag17:Int64! = nil
    public fileprivate(set) var hasTag17:Bool = false

    public fileprivate(set) var numMsgs:Int32! = nil
    public fileprivate(set) var hasNumMsgs:Bool = false

    public fileprivate(set) var msgnum:Int32! = nil
    public fileprivate(set) var hasMsgnum:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasTag1 {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:tag1)
        }
        if hasRiderId {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:riderId)
        }
        if hasWorldTime {
            try codedOutputStream.writeInt64(fieldNumber: 3, value:worldTime)
        }
        if hasSeqno {
            try codedOutputStream.writeInt32(fieldNumber: 4, value:seqno)
        }
        for oneElementPlayerStates in playerStates {
              try codedOutputStream.writeMessage(fieldNumber: 8, value:oneElementPlayerStates)
        }
        for oneElementPlayerUpdates in playerUpdates {
              try codedOutputStream.writeMessage(fieldNumber: 9, value:oneElementPlayerUpdates)
        }
        if hasTag11 {
            try codedOutputStream.writeInt64(fieldNumber: 11, value:tag11)
        }
        if hasTag17 {
            try codedOutputStream.writeInt64(fieldNumber: 17, value:tag17)
        }
        if hasNumMsgs {
            try codedOutputStream.writeInt32(fieldNumber: 18, value:numMsgs)
        }
        if hasMsgnum {
            try codedOutputStream.writeInt32(fieldNumber: 19, value:msgnum)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasTag1 {
            serialize_size += tag1.computeInt32Size(fieldNumber: 1)
        }
        if hasRiderId {
            serialize_size += riderId.computeInt32Size(fieldNumber: 2)
        }
        if hasWorldTime {
            serialize_size += worldTime.computeInt64Size(fieldNumber: 3)
        }
        if hasSeqno {
            serialize_size += seqno.computeInt32Size(fieldNumber: 4)
        }
        for oneElementPlayerStates in playerStates {
            serialize_size += oneElementPlayerStates.computeMessageSize(fieldNumber: 8)
        }
        for oneElementPlayerUpdates in playerUpdates {
            serialize_size += oneElementPlayerUpdates.computeMessageSize(fieldNumber: 9)
        }
        if hasTag11 {
            serialize_size += tag11.computeInt64Size(fieldNumber: 11)
        }
        if hasTag17 {
            serialize_size += tag17.computeInt64Size(fieldNumber: 17)
        }
        if hasNumMsgs {
            serialize_size += numMsgs.computeInt32Size(fieldNumber: 18)
        }
        if hasMsgnum {
            serialize_size += msgnum.computeInt32Size(fieldNumber: 19)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> ServerToClient.Builder {
        return ServerToClient.classBuilder() as! ServerToClient.Builder
    }
    public func getBuilder() -> ServerToClient.Builder {
        return classBuilder() as! ServerToClient.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ServerToClient.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ServerToClient.Builder()
    }
    public func toBuilder() throws -> ServerToClient.Builder {
        return try ServerToClient.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:ServerToClient) throws -> ServerToClient.Builder {
        return try ServerToClient.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasTag1 {
            jsonMap["tag1"] = Int(tag1)
        }
        if hasRiderId {
            jsonMap["riderId"] = Int(riderId)
        }
        if hasWorldTime {
            jsonMap["worldTime"] = "\(worldTime!)"
        }
        if hasSeqno {
            jsonMap["seqno"] = Int(seqno)
        }
        if !playerStates.isEmpty {
            var jsonArrayPlayerStates:Array<Dictionary<String,Any>> = []
            for oneValuePlayerStates in playerStates {
                let ecodedMessagePlayerStates = try oneValuePlayerStates.encode()
                jsonArrayPlayerStates.append(ecodedMessagePlayerStates)
            }
            jsonMap["playerStates"] = jsonArrayPlayerStates
        }
        if !playerUpdates.isEmpty {
            var jsonArrayPlayerUpdates:Array<Dictionary<String,Any>> = []
            for oneValuePlayerUpdates in playerUpdates {
                let ecodedMessagePlayerUpdates = try oneValuePlayerUpdates.encode()
                jsonArrayPlayerUpdates.append(ecodedMessagePlayerUpdates)
            }
            jsonMap["playerUpdates"] = jsonArrayPlayerUpdates
        }
        if hasTag11 {
            jsonMap["tag11"] = "\(tag11!)"
        }
        if hasTag17 {
            jsonMap["tag17"] = "\(tag17!)"
        }
        if hasNumMsgs {
            jsonMap["numMsgs"] = Int(numMsgs)
        }
        if hasMsgnum {
            jsonMap["msgnum"] = Int(msgnum)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ServerToClient {
        return try ServerToClient.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> ServerToClient {
        return try ServerToClient.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasTag1 {
            output += "\(indent) tag1: \(tag1) \n"
        }
        if hasRiderId {
            output += "\(indent) riderId: \(riderId) \n"
        }
        if hasWorldTime {
            output += "\(indent) worldTime: \(worldTime) \n"
        }
        if hasSeqno {
            output += "\(indent) seqno: \(seqno) \n"
        }
        var playerStatesElementIndex:Int = 0
        for oneElementPlayerStates in playerStates {
            output += "\(indent) playerStates[\(playerStatesElementIndex)] {\n"
            output += try oneElementPlayerStates.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            playerStatesElementIndex += 1
        }
        var playerUpdatesElementIndex:Int = 0
        for oneElementPlayerUpdates in playerUpdates {
            output += "\(indent) playerUpdates[\(playerUpdatesElementIndex)] {\n"
            output += try oneElementPlayerUpdates.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            playerUpdatesElementIndex += 1
        }
        if hasTag11 {
            output += "\(indent) tag11: \(tag11) \n"
        }
        if hasTag17 {
            output += "\(indent) tag17: \(tag17) \n"
        }
        if hasNumMsgs {
            output += "\(indent) numMsgs: \(numMsgs) \n"
        }
        if hasMsgnum {
            output += "\(indent) msgnum: \(msgnum) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasTag1 {
                hashCode = (hashCode &* 31) &+ tag1.hashValue
            }
            if hasRiderId {
                hashCode = (hashCode &* 31) &+ riderId.hashValue
            }
            if hasWorldTime {
                hashCode = (hashCode &* 31) &+ worldTime.hashValue
            }
            if hasSeqno {
                hashCode = (hashCode &* 31) &+ seqno.hashValue
            }
            for oneElementPlayerStates in playerStates {
                hashCode = (hashCode &* 31) &+ oneElementPlayerStates.hashValue
            }
            for oneElementPlayerUpdates in playerUpdates {
                hashCode = (hashCode &* 31) &+ oneElementPlayerUpdates.hashValue
            }
            if hasTag11 {
                hashCode = (hashCode &* 31) &+ tag11.hashValue
            }
            if hasTag17 {
                hashCode = (hashCode &* 31) &+ tag17.hashValue
            }
            if hasNumMsgs {
                hashCode = (hashCode &* 31) &+ numMsgs.hashValue
            }
            if hasMsgnum {
                hashCode = (hashCode &* 31) &+ msgnum.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ServerToClient"
    }
    override public func className() -> String {
        return "ServerToClient"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:ServerToClient = ServerToClient()
        public func getMessage() -> ServerToClient {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var tag1:Int32 {
            get {
                return builderResult.tag1
            }
            set (value) {
                builderResult.hasTag1 = true
                builderResult.tag1 = value
            }
        }
        public var hasTag1:Bool {
            get {
                return builderResult.hasTag1
            }
        }
        @discardableResult
        public func setTag1(_ value:Int32) -> ServerToClient.Builder {
            self.tag1 = value
            return self
        }
        @discardableResult
        public func clearTag1() -> ServerToClient.Builder{
            builderResult.hasTag1 = false
            builderResult.tag1 = nil
            return self
        }
        public var riderId:Int32 {
            get {
                return builderResult.riderId
            }
            set (value) {
                builderResult.hasRiderId = true
                builderResult.riderId = value
            }
        }
        public var hasRiderId:Bool {
            get {
                return builderResult.hasRiderId
            }
        }
        @discardableResult
        public func setRiderId(_ value:Int32) -> ServerToClient.Builder {
            self.riderId = value
            return self
        }
        @discardableResult
        public func clearRiderId() -> ServerToClient.Builder{
            builderResult.hasRiderId = false
            builderResult.riderId = nil
            return self
        }
        public var worldTime:Int64 {
            get {
                return builderResult.worldTime
            }
            set (value) {
                builderResult.hasWorldTime = true
                builderResult.worldTime = value
            }
        }
        public var hasWorldTime:Bool {
            get {
                return builderResult.hasWorldTime
            }
        }
        @discardableResult
        public func setWorldTime(_ value:Int64) -> ServerToClient.Builder {
            self.worldTime = value
            return self
        }
        @discardableResult
        public func clearWorldTime() -> ServerToClient.Builder{
            builderResult.hasWorldTime = false
            builderResult.worldTime = nil
            return self
        }
        public var seqno:Int32 {
            get {
                return builderResult.seqno
            }
            set (value) {
                builderResult.hasSeqno = true
                builderResult.seqno = value
            }
        }
        public var hasSeqno:Bool {
            get {
                return builderResult.hasSeqno
            }
        }
        @discardableResult
        public func setSeqno(_ value:Int32) -> ServerToClient.Builder {
            self.seqno = value
            return self
        }
        @discardableResult
        public func clearSeqno() -> ServerToClient.Builder{
            builderResult.hasSeqno = false
            builderResult.seqno = nil
            return self
        }
        public var playerStates:Array<PlayerState> {
            get {
                return builderResult.playerStates
            }
            set (value) {
                builderResult.playerStates = value
            }
        }
        @discardableResult
        public func setPlayerStates(_ value:Array<PlayerState>) -> ServerToClient.Builder {
            self.playerStates = value
            return self
        }
        @discardableResult
        public func clearPlayerStates() -> ServerToClient.Builder {
            builderResult.playerStates.removeAll(keepingCapacity: false)
            return self
        }
        public var playerUpdates:Array<UnknownMessage> {
            get {
                return builderResult.playerUpdates
            }
            set (value) {
                builderResult.playerUpdates = value
            }
        }
        @discardableResult
        public func setPlayerUpdates(_ value:Array<UnknownMessage>) -> ServerToClient.Builder {
            self.playerUpdates = value
            return self
        }
        @discardableResult
        public func clearPlayerUpdates() -> ServerToClient.Builder {
            builderResult.playerUpdates.removeAll(keepingCapacity: false)
            return self
        }
        public var tag11:Int64 {
            get {
                return builderResult.tag11
            }
            set (value) {
                builderResult.hasTag11 = true
                builderResult.tag11 = value
            }
        }
        public var hasTag11:Bool {
            get {
                return builderResult.hasTag11
            }
        }
        @discardableResult
        public func setTag11(_ value:Int64) -> ServerToClient.Builder {
            self.tag11 = value
            return self
        }
        @discardableResult
        public func clearTag11() -> ServerToClient.Builder{
            builderResult.hasTag11 = false
            builderResult.tag11 = nil
            return self
        }
        public var tag17:Int64 {
            get {
                return builderResult.tag17
            }
            set (value) {
                builderResult.hasTag17 = true
                builderResult.tag17 = value
            }
        }
        public var hasTag17:Bool {
            get {
                return builderResult.hasTag17
            }
        }
        @discardableResult
        public func setTag17(_ value:Int64) -> ServerToClient.Builder {
            self.tag17 = value
            return self
        }
        @discardableResult
        public func clearTag17() -> ServerToClient.Builder{
            builderResult.hasTag17 = false
            builderResult.tag17 = nil
            return self
        }
        public var numMsgs:Int32 {
            get {
                return builderResult.numMsgs
            }
            set (value) {
                builderResult.hasNumMsgs = true
                builderResult.numMsgs = value
            }
        }
        public var hasNumMsgs:Bool {
            get {
                return builderResult.hasNumMsgs
            }
        }
        @discardableResult
        public func setNumMsgs(_ value:Int32) -> ServerToClient.Builder {
            self.numMsgs = value
            return self
        }
        @discardableResult
        public func clearNumMsgs() -> ServerToClient.Builder{
            builderResult.hasNumMsgs = false
            builderResult.numMsgs = nil
            return self
        }
        public var msgnum:Int32 {
            get {
                return builderResult.msgnum
            }
            set (value) {
                builderResult.hasMsgnum = true
                builderResult.msgnum = value
            }
        }
        public var hasMsgnum:Bool {
            get {
                return builderResult.hasMsgnum
            }
        }
        @discardableResult
        public func setMsgnum(_ value:Int32) -> ServerToClient.Builder {
            self.msgnum = value
            return self
        }
        @discardableResult
        public func clearMsgnum() -> ServerToClient.Builder{
            builderResult.hasMsgnum = false
            builderResult.msgnum = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> ServerToClient.Builder {
            builderResult = ServerToClient()
            return self
        }
        override public func clone() throws -> ServerToClient.Builder {
            return try ServerToClient.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> ServerToClient {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> ServerToClient {
            let returnMe:ServerToClient = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:ServerToClient) throws -> ServerToClient.Builder {
            if other == ServerToClient() {
                return self
            }
            if other.hasTag1 {
                tag1 = other.tag1
            }
            if other.hasRiderId {
                riderId = other.riderId
            }
            if other.hasWorldTime {
                worldTime = other.worldTime
            }
            if other.hasSeqno {
                seqno = other.seqno
            }
            if !other.playerStates.isEmpty  {
                 builderResult.playerStates += other.playerStates
            }
            if !other.playerUpdates.isEmpty  {
                 builderResult.playerUpdates += other.playerUpdates
            }
            if other.hasTag11 {
                tag11 = other.tag11
            }
            if other.hasTag17 {
                tag17 = other.tag17
            }
            if other.hasNumMsgs {
                numMsgs = other.numMsgs
            }
            if other.hasMsgnum {
                msgnum = other.msgnum
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ServerToClient.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ServerToClient.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    tag1 = try codedInputStream.readInt32()

                case 16:
                    riderId = try codedInputStream.readInt32()

                case 24:
                    worldTime = try codedInputStream.readInt64()

                case 32:
                    seqno = try codedInputStream.readInt32()

                case 66:
                    let subBuilder = PlayerState.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    playerStates.append(subBuilder.buildPartial())

                case 74:
                    let subBuilder = UnknownMessage.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    playerUpdates.append(subBuilder.buildPartial())

                case 88:
                    tag11 = try codedInputStream.readInt64()

                case 136:
                    tag17 = try codedInputStream.readInt64()

                case 144:
                    numMsgs = try codedInputStream.readInt32()

                case 152:
                    msgnum = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ServerToClient.Builder {
            let resultDecodedBuilder = ServerToClient.Builder()
            if let jsonValueTag1 = jsonMap["tag1"] as? Int {
                resultDecodedBuilder.tag1 = Int32(jsonValueTag1)
            } else if let jsonValueTag1 = jsonMap["tag1"] as? String {
                resultDecodedBuilder.tag1 = Int32(jsonValueTag1)!
            }
            if let jsonValueRiderId = jsonMap["riderId"] as? Int {
                resultDecodedBuilder.riderId = Int32(jsonValueRiderId)
            } else if let jsonValueRiderId = jsonMap["riderId"] as? String {
                resultDecodedBuilder.riderId = Int32(jsonValueRiderId)!
            }
            if let jsonValueWorldTime = jsonMap["worldTime"] as? String {
                resultDecodedBuilder.worldTime = Int64(jsonValueWorldTime)!
            } else if let jsonValueWorldTime = jsonMap["worldTime"] as? Int {
                resultDecodedBuilder.worldTime = Int64(jsonValueWorldTime)
            }
            if let jsonValueSeqno = jsonMap["seqno"] as? Int {
                resultDecodedBuilder.seqno = Int32(jsonValueSeqno)
            } else if let jsonValueSeqno = jsonMap["seqno"] as? String {
                resultDecodedBuilder.seqno = Int32(jsonValueSeqno)!
            }
            if let jsonValuePlayerStates = jsonMap["playerStates"] as? Array<Dictionary<String,Any>> {
                var jsonArrayPlayerStates:Array<PlayerState> = []
                for oneValuePlayerStates in jsonValuePlayerStates {
                    let messageFromStringPlayerStates = try PlayerState.Builder.decodeToBuilder(jsonMap:oneValuePlayerStates).build()

                    jsonArrayPlayerStates.append(messageFromStringPlayerStates)
                }
                resultDecodedBuilder.playerStates = jsonArrayPlayerStates
            }
            if let jsonValuePlayerUpdates = jsonMap["playerUpdates"] as? Array<Dictionary<String,Any>> {
                var jsonArrayPlayerUpdates:Array<UnknownMessage> = []
                for oneValuePlayerUpdates in jsonValuePlayerUpdates {
                    let messageFromStringPlayerUpdates = try UnknownMessage.Builder.decodeToBuilder(jsonMap:oneValuePlayerUpdates).build()

                    jsonArrayPlayerUpdates.append(messageFromStringPlayerUpdates)
                }
                resultDecodedBuilder.playerUpdates = jsonArrayPlayerUpdates
            }
            if let jsonValueTag11 = jsonMap["tag11"] as? String {
                resultDecodedBuilder.tag11 = Int64(jsonValueTag11)!
            } else if let jsonValueTag11 = jsonMap["tag11"] as? Int {
                resultDecodedBuilder.tag11 = Int64(jsonValueTag11)
            }
            if let jsonValueTag17 = jsonMap["tag17"] as? String {
                resultDecodedBuilder.tag17 = Int64(jsonValueTag17)!
            } else if let jsonValueTag17 = jsonMap["tag17"] as? Int {
                resultDecodedBuilder.tag17 = Int64(jsonValueTag17)
            }
            if let jsonValueNumMsgs = jsonMap["numMsgs"] as? Int {
                resultDecodedBuilder.numMsgs = Int32(jsonValueNumMsgs)
            } else if let jsonValueNumMsgs = jsonMap["numMsgs"] as? String {
                resultDecodedBuilder.numMsgs = Int32(jsonValueNumMsgs)!
            }
            if let jsonValueMsgnum = jsonMap["msgnum"] as? Int {
                resultDecodedBuilder.msgnum = Int32(jsonValueMsgnum)
            } else if let jsonValueMsgnum = jsonMap["msgnum"] as? String {
                resultDecodedBuilder.msgnum = Int32(jsonValueMsgnum)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> ServerToClient.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try ServerToClient.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class WorldAttributes : GeneratedMessage {
    public typealias BuilderType = WorldAttributes.Builder

    public static func == (lhs: WorldAttributes, rhs: WorldAttributes) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasWorldId == rhs.hasWorldId) && (!lhs.hasWorldId || lhs.worldId == rhs.worldId)
        fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
        fieldCheck = fieldCheck && (lhs.hasTag3 == rhs.hasTag3) && (!lhs.hasTag3 || lhs.tag3 == rhs.tag3)
        fieldCheck = fieldCheck && (lhs.hasTag5 == rhs.hasTag5) && (!lhs.hasTag5 || lhs.tag5 == rhs.tag5)
        fieldCheck = fieldCheck && (lhs.hasWorldTime == rhs.hasWorldTime) && (!lhs.hasWorldTime || lhs.worldTime == rhs.worldTime)
        fieldCheck = fieldCheck && (lhs.hasClockTime == rhs.hasClockTime) && (!lhs.hasClockTime || lhs.clockTime == rhs.clockTime)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var worldId:Int32! = nil
    public fileprivate(set) var hasWorldId:Bool = false

    public fileprivate(set) var name:String! = nil
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var tag3:Int64! = nil
    public fileprivate(set) var hasTag3:Bool = false

    public fileprivate(set) var tag5:Int64! = nil
    public fileprivate(set) var hasTag5:Bool = false

    public fileprivate(set) var worldTime:Int64! = nil
    public fileprivate(set) var hasWorldTime:Bool = false

    public fileprivate(set) var clockTime:Int64! = nil
    public fileprivate(set) var hasClockTime:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasWorldId {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:worldId)
        }
        if hasName {
            try codedOutputStream.writeString(fieldNumber: 2, value:name)
        }
        if hasTag3 {
            try codedOutputStream.writeInt64(fieldNumber: 3, value:tag3)
        }
        if hasTag5 {
            try codedOutputStream.writeInt64(fieldNumber: 4, value:tag5)
        }
        if hasWorldTime {
            try codedOutputStream.writeInt64(fieldNumber: 6, value:worldTime)
        }
        if hasClockTime {
            try codedOutputStream.writeInt64(fieldNumber: 7, value:clockTime)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasWorldId {
            serialize_size += worldId.computeInt32Size(fieldNumber: 1)
        }
        if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 2)
        }
        if hasTag3 {
            serialize_size += tag3.computeInt64Size(fieldNumber: 3)
        }
        if hasTag5 {
            serialize_size += tag5.computeInt64Size(fieldNumber: 4)
        }
        if hasWorldTime {
            serialize_size += worldTime.computeInt64Size(fieldNumber: 6)
        }
        if hasClockTime {
            serialize_size += clockTime.computeInt64Size(fieldNumber: 7)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> WorldAttributes.Builder {
        return WorldAttributes.classBuilder() as! WorldAttributes.Builder
    }
    public func getBuilder() -> WorldAttributes.Builder {
        return classBuilder() as! WorldAttributes.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return WorldAttributes.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return WorldAttributes.Builder()
    }
    public func toBuilder() throws -> WorldAttributes.Builder {
        return try WorldAttributes.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:WorldAttributes) throws -> WorldAttributes.Builder {
        return try WorldAttributes.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasWorldId {
            jsonMap["worldId"] = Int(worldId)
        }
        if hasName {
            jsonMap["name"] = name
        }
        if hasTag3 {
            jsonMap["tag3"] = "\(tag3!)"
        }
        if hasTag5 {
            jsonMap["tag5"] = "\(tag5!)"
        }
        if hasWorldTime {
            jsonMap["worldTime"] = "\(worldTime!)"
        }
        if hasClockTime {
            jsonMap["clockTime"] = "\(clockTime!)"
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> WorldAttributes {
        return try WorldAttributes.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> WorldAttributes {
        return try WorldAttributes.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasWorldId {
            output += "\(indent) worldId: \(worldId) \n"
        }
        if hasName {
            output += "\(indent) name: \(name) \n"
        }
        if hasTag3 {
            output += "\(indent) tag3: \(tag3) \n"
        }
        if hasTag5 {
            output += "\(indent) tag5: \(tag5) \n"
        }
        if hasWorldTime {
            output += "\(indent) worldTime: \(worldTime) \n"
        }
        if hasClockTime {
            output += "\(indent) clockTime: \(clockTime) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasWorldId {
                hashCode = (hashCode &* 31) &+ worldId.hashValue
            }
            if hasName {
                hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasTag3 {
                hashCode = (hashCode &* 31) &+ tag3.hashValue
            }
            if hasTag5 {
                hashCode = (hashCode &* 31) &+ tag5.hashValue
            }
            if hasWorldTime {
                hashCode = (hashCode &* 31) &+ worldTime.hashValue
            }
            if hasClockTime {
                hashCode = (hashCode &* 31) &+ clockTime.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "WorldAttributes"
    }
    override public func className() -> String {
        return "WorldAttributes"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:WorldAttributes = WorldAttributes()
        public func getMessage() -> WorldAttributes {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var worldId:Int32 {
            get {
                return builderResult.worldId
            }
            set (value) {
                builderResult.hasWorldId = true
                builderResult.worldId = value
            }
        }
        public var hasWorldId:Bool {
            get {
                return builderResult.hasWorldId
            }
        }
        @discardableResult
        public func setWorldId(_ value:Int32) -> WorldAttributes.Builder {
            self.worldId = value
            return self
        }
        @discardableResult
        public func clearWorldId() -> WorldAttributes.Builder{
            builderResult.hasWorldId = false
            builderResult.worldId = nil
            return self
        }
        public var name:String {
            get {
                return builderResult.name
            }
            set (value) {
                builderResult.hasName = true
                builderResult.name = value
            }
        }
        public var hasName:Bool {
            get {
                return builderResult.hasName
            }
        }
        @discardableResult
        public func setName(_ value:String) -> WorldAttributes.Builder {
            self.name = value
            return self
        }
        @discardableResult
        public func clearName() -> WorldAttributes.Builder{
            builderResult.hasName = false
            builderResult.name = nil
            return self
        }
        public var tag3:Int64 {
            get {
                return builderResult.tag3
            }
            set (value) {
                builderResult.hasTag3 = true
                builderResult.tag3 = value
            }
        }
        public var hasTag3:Bool {
            get {
                return builderResult.hasTag3
            }
        }
        @discardableResult
        public func setTag3(_ value:Int64) -> WorldAttributes.Builder {
            self.tag3 = value
            return self
        }
        @discardableResult
        public func clearTag3() -> WorldAttributes.Builder{
            builderResult.hasTag3 = false
            builderResult.tag3 = nil
            return self
        }
        public var tag5:Int64 {
            get {
                return builderResult.tag5
            }
            set (value) {
                builderResult.hasTag5 = true
                builderResult.tag5 = value
            }
        }
        public var hasTag5:Bool {
            get {
                return builderResult.hasTag5
            }
        }
        @discardableResult
        public func setTag5(_ value:Int64) -> WorldAttributes.Builder {
            self.tag5 = value
            return self
        }
        @discardableResult
        public func clearTag5() -> WorldAttributes.Builder{
            builderResult.hasTag5 = false
            builderResult.tag5 = nil
            return self
        }
        public var worldTime:Int64 {
            get {
                return builderResult.worldTime
            }
            set (value) {
                builderResult.hasWorldTime = true
                builderResult.worldTime = value
            }
        }
        public var hasWorldTime:Bool {
            get {
                return builderResult.hasWorldTime
            }
        }
        @discardableResult
        public func setWorldTime(_ value:Int64) -> WorldAttributes.Builder {
            self.worldTime = value
            return self
        }
        @discardableResult
        public func clearWorldTime() -> WorldAttributes.Builder{
            builderResult.hasWorldTime = false
            builderResult.worldTime = nil
            return self
        }
        public var clockTime:Int64 {
            get {
                return builderResult.clockTime
            }
            set (value) {
                builderResult.hasClockTime = true
                builderResult.clockTime = value
            }
        }
        public var hasClockTime:Bool {
            get {
                return builderResult.hasClockTime
            }
        }
        @discardableResult
        public func setClockTime(_ value:Int64) -> WorldAttributes.Builder {
            self.clockTime = value
            return self
        }
        @discardableResult
        public func clearClockTime() -> WorldAttributes.Builder{
            builderResult.hasClockTime = false
            builderResult.clockTime = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> WorldAttributes.Builder {
            builderResult = WorldAttributes()
            return self
        }
        override public func clone() throws -> WorldAttributes.Builder {
            return try WorldAttributes.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> WorldAttributes {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> WorldAttributes {
            let returnMe:WorldAttributes = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:WorldAttributes) throws -> WorldAttributes.Builder {
            if other == WorldAttributes() {
                return self
            }
            if other.hasWorldId {
                worldId = other.worldId
            }
            if other.hasName {
                name = other.name
            }
            if other.hasTag3 {
                tag3 = other.tag3
            }
            if other.hasTag5 {
                tag5 = other.tag5
            }
            if other.hasWorldTime {
                worldTime = other.worldTime
            }
            if other.hasClockTime {
                clockTime = other.clockTime
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> WorldAttributes.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> WorldAttributes.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    worldId = try codedInputStream.readInt32()

                case 18:
                    name = try codedInputStream.readString()

                case 24:
                    tag3 = try codedInputStream.readInt64()

                case 32:
                    tag5 = try codedInputStream.readInt64()

                case 48:
                    worldTime = try codedInputStream.readInt64()

                case 56:
                    clockTime = try codedInputStream.readInt64()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> WorldAttributes.Builder {
            let resultDecodedBuilder = WorldAttributes.Builder()
            if let jsonValueWorldId = jsonMap["worldId"] as? Int {
                resultDecodedBuilder.worldId = Int32(jsonValueWorldId)
            } else if let jsonValueWorldId = jsonMap["worldId"] as? String {
                resultDecodedBuilder.worldId = Int32(jsonValueWorldId)!
            }
            if let jsonValueName = jsonMap["name"] as? String {
                resultDecodedBuilder.name = jsonValueName
            }
            if let jsonValueTag3 = jsonMap["tag3"] as? String {
                resultDecodedBuilder.tag3 = Int64(jsonValueTag3)!
            } else if let jsonValueTag3 = jsonMap["tag3"] as? Int {
                resultDecodedBuilder.tag3 = Int64(jsonValueTag3)
            }
            if let jsonValueTag5 = jsonMap["tag5"] as? String {
                resultDecodedBuilder.tag5 = Int64(jsonValueTag5)!
            } else if let jsonValueTag5 = jsonMap["tag5"] as? Int {
                resultDecodedBuilder.tag5 = Int64(jsonValueTag5)
            }
            if let jsonValueWorldTime = jsonMap["worldTime"] as? String {
                resultDecodedBuilder.worldTime = Int64(jsonValueWorldTime)!
            } else if let jsonValueWorldTime = jsonMap["worldTime"] as? Int {
                resultDecodedBuilder.worldTime = Int64(jsonValueWorldTime)
            }
            if let jsonValueClockTime = jsonMap["clockTime"] as? String {
                resultDecodedBuilder.clockTime = Int64(jsonValueClockTime)!
            } else if let jsonValueClockTime = jsonMap["clockTime"] as? Int {
                resultDecodedBuilder.clockTime = Int64(jsonValueClockTime)
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> WorldAttributes.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try WorldAttributes.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class WorldAttribute : GeneratedMessage {
    public typealias BuilderType = WorldAttribute.Builder

    public static func == (lhs: WorldAttribute, rhs: WorldAttribute) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasWorldTime == rhs.hasWorldTime) && (!lhs.hasWorldTime || lhs.worldTime == rhs.worldTime)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var worldTime:Int64! = nil
    public fileprivate(set) var hasWorldTime:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasWorldTime {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:worldTime)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasWorldTime {
            serialize_size += worldTime.computeInt64Size(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> WorldAttribute.Builder {
        return WorldAttribute.classBuilder() as! WorldAttribute.Builder
    }
    public func getBuilder() -> WorldAttribute.Builder {
        return classBuilder() as! WorldAttribute.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return WorldAttribute.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return WorldAttribute.Builder()
    }
    public func toBuilder() throws -> WorldAttribute.Builder {
        return try WorldAttribute.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:WorldAttribute) throws -> WorldAttribute.Builder {
        return try WorldAttribute.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasWorldTime {
            jsonMap["worldTime"] = "\(worldTime!)"
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> WorldAttribute {
        return try WorldAttribute.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> WorldAttribute {
        return try WorldAttribute.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasWorldTime {
            output += "\(indent) worldTime: \(worldTime) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasWorldTime {
                hashCode = (hashCode &* 31) &+ worldTime.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "WorldAttribute"
    }
    override public func className() -> String {
        return "WorldAttribute"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:WorldAttribute = WorldAttribute()
        public func getMessage() -> WorldAttribute {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var worldTime:Int64 {
            get {
                return builderResult.worldTime
            }
            set (value) {
                builderResult.hasWorldTime = true
                builderResult.worldTime = value
            }
        }
        public var hasWorldTime:Bool {
            get {
                return builderResult.hasWorldTime
            }
        }
        @discardableResult
        public func setWorldTime(_ value:Int64) -> WorldAttribute.Builder {
            self.worldTime = value
            return self
        }
        @discardableResult
        public func clearWorldTime() -> WorldAttribute.Builder{
            builderResult.hasWorldTime = false
            builderResult.worldTime = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> WorldAttribute.Builder {
            builderResult = WorldAttribute()
            return self
        }
        override public func clone() throws -> WorldAttribute.Builder {
            return try WorldAttribute.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> WorldAttribute {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> WorldAttribute {
            let returnMe:WorldAttribute = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:WorldAttribute) throws -> WorldAttribute.Builder {
            if other == WorldAttribute() {
                return self
            }
            if other.hasWorldTime {
                worldTime = other.worldTime
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> WorldAttribute.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> WorldAttribute.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 16:
                    worldTime = try codedInputStream.readInt64()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> WorldAttribute.Builder {
            let resultDecodedBuilder = WorldAttribute.Builder()
            if let jsonValueWorldTime = jsonMap["worldTime"] as? String {
                resultDecodedBuilder.worldTime = Int64(jsonValueWorldTime)!
            } else if let jsonValueWorldTime = jsonMap["worldTime"] as? Int {
                resultDecodedBuilder.worldTime = Int64(jsonValueWorldTime)
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> WorldAttribute.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try WorldAttribute.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class EventSubgroupProtobuf : GeneratedMessage {
    public typealias BuilderType = EventSubgroupProtobuf.Builder

    public static func == (lhs: EventSubgroupProtobuf, rhs: EventSubgroupProtobuf) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
        fieldCheck = fieldCheck && (lhs.hasRules == rhs.hasRules) && (!lhs.hasRules || lhs.rules == rhs.rules)
        fieldCheck = fieldCheck && (lhs.hasRoute == rhs.hasRoute) && (!lhs.hasRoute || lhs.route == rhs.route)
        fieldCheck = fieldCheck && (lhs.hasLaps == rhs.hasLaps) && (!lhs.hasLaps || lhs.laps == rhs.laps)
        fieldCheck = fieldCheck && (lhs.hasStartLocation == rhs.hasStartLocation) && (!lhs.hasStartLocation || lhs.startLocation == rhs.startLocation)
        fieldCheck = fieldCheck && (lhs.hasLabel == rhs.hasLabel) && (!lhs.hasLabel || lhs.label == rhs.label)
        fieldCheck = fieldCheck && (lhs.hasPaceType == rhs.hasPaceType) && (!lhs.hasPaceType || lhs.paceType == rhs.paceType)
        fieldCheck = fieldCheck && (lhs.hasJerseyHash == rhs.hasJerseyHash) && (!lhs.hasJerseyHash || lhs.jerseyHash == rhs.jerseyHash)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int32! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var name:String! = nil
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var rules:Int32! = nil
    public fileprivate(set) var hasRules:Bool = false

    public fileprivate(set) var route:Int32! = nil
    public fileprivate(set) var hasRoute:Bool = false

    public fileprivate(set) var laps:Int32! = nil
    public fileprivate(set) var hasLaps:Bool = false

    public fileprivate(set) var startLocation:Int32! = nil
    public fileprivate(set) var hasStartLocation:Bool = false

    public fileprivate(set) var label:Int32! = nil
    public fileprivate(set) var hasLabel:Bool = false

    public fileprivate(set) var paceType:Int32! = nil
    public fileprivate(set) var hasPaceType:Bool = false

    public fileprivate(set) var jerseyHash:Int32! = nil
    public fileprivate(set) var hasJerseyHash:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:id)
        }
        if hasName {
            try codedOutputStream.writeString(fieldNumber: 2, value:name)
        }
        if hasRules {
            try codedOutputStream.writeInt32(fieldNumber: 8, value:rules)
        }
        if hasRoute {
            try codedOutputStream.writeInt32(fieldNumber: 22, value:route)
        }
        if hasLaps {
            try codedOutputStream.writeInt32(fieldNumber: 25, value:laps)
        }
        if hasStartLocation {
            try codedOutputStream.writeInt32(fieldNumber: 29, value:startLocation)
        }
        if hasLabel {
            try codedOutputStream.writeInt32(fieldNumber: 30, value:label)
        }
        if hasPaceType {
            try codedOutputStream.writeInt32(fieldNumber: 31, value:paceType)
        }
        if hasJerseyHash {
            try codedOutputStream.writeInt32(fieldNumber: 36, value:jerseyHash)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt32Size(fieldNumber: 1)
        }
        if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 2)
        }
        if hasRules {
            serialize_size += rules.computeInt32Size(fieldNumber: 8)
        }
        if hasRoute {
            serialize_size += route.computeInt32Size(fieldNumber: 22)
        }
        if hasLaps {
            serialize_size += laps.computeInt32Size(fieldNumber: 25)
        }
        if hasStartLocation {
            serialize_size += startLocation.computeInt32Size(fieldNumber: 29)
        }
        if hasLabel {
            serialize_size += label.computeInt32Size(fieldNumber: 30)
        }
        if hasPaceType {
            serialize_size += paceType.computeInt32Size(fieldNumber: 31)
        }
        if hasJerseyHash {
            serialize_size += jerseyHash.computeInt32Size(fieldNumber: 36)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> EventSubgroupProtobuf.Builder {
        return EventSubgroupProtobuf.classBuilder() as! EventSubgroupProtobuf.Builder
    }
    public func getBuilder() -> EventSubgroupProtobuf.Builder {
        return classBuilder() as! EventSubgroupProtobuf.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return EventSubgroupProtobuf.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return EventSubgroupProtobuf.Builder()
    }
    public func toBuilder() throws -> EventSubgroupProtobuf.Builder {
        return try EventSubgroupProtobuf.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:EventSubgroupProtobuf) throws -> EventSubgroupProtobuf.Builder {
        return try EventSubgroupProtobuf.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasId {
            jsonMap["id"] = Int(id)
        }
        if hasName {
            jsonMap["name"] = name
        }
        if hasRules {
            jsonMap["rules"] = Int(rules)
        }
        if hasRoute {
            jsonMap["route"] = Int(route)
        }
        if hasLaps {
            jsonMap["laps"] = Int(laps)
        }
        if hasStartLocation {
            jsonMap["startLocation"] = Int(startLocation)
        }
        if hasLabel {
            jsonMap["label"] = Int(label)
        }
        if hasPaceType {
            jsonMap["paceType"] = Int(paceType)
        }
        if hasJerseyHash {
            jsonMap["jerseyHash"] = Int(jerseyHash)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> EventSubgroupProtobuf {
        return try EventSubgroupProtobuf.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> EventSubgroupProtobuf {
        return try EventSubgroupProtobuf.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasName {
            output += "\(indent) name: \(name) \n"
        }
        if hasRules {
            output += "\(indent) rules: \(rules) \n"
        }
        if hasRoute {
            output += "\(indent) route: \(route) \n"
        }
        if hasLaps {
            output += "\(indent) laps: \(laps) \n"
        }
        if hasStartLocation {
            output += "\(indent) startLocation: \(startLocation) \n"
        }
        if hasLabel {
            output += "\(indent) label: \(label) \n"
        }
        if hasPaceType {
            output += "\(indent) paceType: \(paceType) \n"
        }
        if hasJerseyHash {
            output += "\(indent) jerseyHash: \(jerseyHash) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasName {
                hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasRules {
                hashCode = (hashCode &* 31) &+ rules.hashValue
            }
            if hasRoute {
                hashCode = (hashCode &* 31) &+ route.hashValue
            }
            if hasLaps {
                hashCode = (hashCode &* 31) &+ laps.hashValue
            }
            if hasStartLocation {
                hashCode = (hashCode &* 31) &+ startLocation.hashValue
            }
            if hasLabel {
                hashCode = (hashCode &* 31) &+ label.hashValue
            }
            if hasPaceType {
                hashCode = (hashCode &* 31) &+ paceType.hashValue
            }
            if hasJerseyHash {
                hashCode = (hashCode &* 31) &+ jerseyHash.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "EventSubgroupProtobuf"
    }
    override public func className() -> String {
        return "EventSubgroupProtobuf"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:EventSubgroupProtobuf = EventSubgroupProtobuf()
        public func getMessage() -> EventSubgroupProtobuf {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int32 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int32) -> EventSubgroupProtobuf.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> EventSubgroupProtobuf.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var name:String {
            get {
                return builderResult.name
            }
            set (value) {
                builderResult.hasName = true
                builderResult.name = value
            }
        }
        public var hasName:Bool {
            get {
                return builderResult.hasName
            }
        }
        @discardableResult
        public func setName(_ value:String) -> EventSubgroupProtobuf.Builder {
            self.name = value
            return self
        }
        @discardableResult
        public func clearName() -> EventSubgroupProtobuf.Builder{
            builderResult.hasName = false
            builderResult.name = nil
            return self
        }
        public var rules:Int32 {
            get {
                return builderResult.rules
            }
            set (value) {
                builderResult.hasRules = true
                builderResult.rules = value
            }
        }
        public var hasRules:Bool {
            get {
                return builderResult.hasRules
            }
        }
        @discardableResult
        public func setRules(_ value:Int32) -> EventSubgroupProtobuf.Builder {
            self.rules = value
            return self
        }
        @discardableResult
        public func clearRules() -> EventSubgroupProtobuf.Builder{
            builderResult.hasRules = false
            builderResult.rules = nil
            return self
        }
        public var route:Int32 {
            get {
                return builderResult.route
            }
            set (value) {
                builderResult.hasRoute = true
                builderResult.route = value
            }
        }
        public var hasRoute:Bool {
            get {
                return builderResult.hasRoute
            }
        }
        @discardableResult
        public func setRoute(_ value:Int32) -> EventSubgroupProtobuf.Builder {
            self.route = value
            return self
        }
        @discardableResult
        public func clearRoute() -> EventSubgroupProtobuf.Builder{
            builderResult.hasRoute = false
            builderResult.route = nil
            return self
        }
        public var laps:Int32 {
            get {
                return builderResult.laps
            }
            set (value) {
                builderResult.hasLaps = true
                builderResult.laps = value
            }
        }
        public var hasLaps:Bool {
            get {
                return builderResult.hasLaps
            }
        }
        @discardableResult
        public func setLaps(_ value:Int32) -> EventSubgroupProtobuf.Builder {
            self.laps = value
            return self
        }
        @discardableResult
        public func clearLaps() -> EventSubgroupProtobuf.Builder{
            builderResult.hasLaps = false
            builderResult.laps = nil
            return self
        }
        public var startLocation:Int32 {
            get {
                return builderResult.startLocation
            }
            set (value) {
                builderResult.hasStartLocation = true
                builderResult.startLocation = value
            }
        }
        public var hasStartLocation:Bool {
            get {
                return builderResult.hasStartLocation
            }
        }
        @discardableResult
        public func setStartLocation(_ value:Int32) -> EventSubgroupProtobuf.Builder {
            self.startLocation = value
            return self
        }
        @discardableResult
        public func clearStartLocation() -> EventSubgroupProtobuf.Builder{
            builderResult.hasStartLocation = false
            builderResult.startLocation = nil
            return self
        }
        public var label:Int32 {
            get {
                return builderResult.label
            }
            set (value) {
                builderResult.hasLabel = true
                builderResult.label = value
            }
        }
        public var hasLabel:Bool {
            get {
                return builderResult.hasLabel
            }
        }
        @discardableResult
        public func setLabel(_ value:Int32) -> EventSubgroupProtobuf.Builder {
            self.label = value
            return self
        }
        @discardableResult
        public func clearLabel() -> EventSubgroupProtobuf.Builder{
            builderResult.hasLabel = false
            builderResult.label = nil
            return self
        }
        public var paceType:Int32 {
            get {
                return builderResult.paceType
            }
            set (value) {
                builderResult.hasPaceType = true
                builderResult.paceType = value
            }
        }
        public var hasPaceType:Bool {
            get {
                return builderResult.hasPaceType
            }
        }
        @discardableResult
        public func setPaceType(_ value:Int32) -> EventSubgroupProtobuf.Builder {
            self.paceType = value
            return self
        }
        @discardableResult
        public func clearPaceType() -> EventSubgroupProtobuf.Builder{
            builderResult.hasPaceType = false
            builderResult.paceType = nil
            return self
        }
        public var jerseyHash:Int32 {
            get {
                return builderResult.jerseyHash
            }
            set (value) {
                builderResult.hasJerseyHash = true
                builderResult.jerseyHash = value
            }
        }
        public var hasJerseyHash:Bool {
            get {
                return builderResult.hasJerseyHash
            }
        }
        @discardableResult
        public func setJerseyHash(_ value:Int32) -> EventSubgroupProtobuf.Builder {
            self.jerseyHash = value
            return self
        }
        @discardableResult
        public func clearJerseyHash() -> EventSubgroupProtobuf.Builder{
            builderResult.hasJerseyHash = false
            builderResult.jerseyHash = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> EventSubgroupProtobuf.Builder {
            builderResult = EventSubgroupProtobuf()
            return self
        }
        override public func clone() throws -> EventSubgroupProtobuf.Builder {
            return try EventSubgroupProtobuf.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> EventSubgroupProtobuf {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> EventSubgroupProtobuf {
            let returnMe:EventSubgroupProtobuf = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:EventSubgroupProtobuf) throws -> EventSubgroupProtobuf.Builder {
            if other == EventSubgroupProtobuf() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasName {
                name = other.name
            }
            if other.hasRules {
                rules = other.rules
            }
            if other.hasRoute {
                route = other.route
            }
            if other.hasLaps {
                laps = other.laps
            }
            if other.hasStartLocation {
                startLocation = other.startLocation
            }
            if other.hasLabel {
                label = other.label
            }
            if other.hasPaceType {
                paceType = other.paceType
            }
            if other.hasJerseyHash {
                jerseyHash = other.jerseyHash
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> EventSubgroupProtobuf.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EventSubgroupProtobuf.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt32()

                case 18:
                    name = try codedInputStream.readString()

                case 64:
                    rules = try codedInputStream.readInt32()

                case 176:
                    route = try codedInputStream.readInt32()

                case 200:
                    laps = try codedInputStream.readInt32()

                case 232:
                    startLocation = try codedInputStream.readInt32()

                case 240:
                    label = try codedInputStream.readInt32()

                case 248:
                    paceType = try codedInputStream.readInt32()

                case 288:
                    jerseyHash = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> EventSubgroupProtobuf.Builder {
            let resultDecodedBuilder = EventSubgroupProtobuf.Builder()
            if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int32(jsonValueId)
            } else if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int32(jsonValueId)!
            }
            if let jsonValueName = jsonMap["name"] as? String {
                resultDecodedBuilder.name = jsonValueName
            }
            if let jsonValueRules = jsonMap["rules"] as? Int {
                resultDecodedBuilder.rules = Int32(jsonValueRules)
            } else if let jsonValueRules = jsonMap["rules"] as? String {
                resultDecodedBuilder.rules = Int32(jsonValueRules)!
            }
            if let jsonValueRoute = jsonMap["route"] as? Int {
                resultDecodedBuilder.route = Int32(jsonValueRoute)
            } else if let jsonValueRoute = jsonMap["route"] as? String {
                resultDecodedBuilder.route = Int32(jsonValueRoute)!
            }
            if let jsonValueLaps = jsonMap["laps"] as? Int {
                resultDecodedBuilder.laps = Int32(jsonValueLaps)
            } else if let jsonValueLaps = jsonMap["laps"] as? String {
                resultDecodedBuilder.laps = Int32(jsonValueLaps)!
            }
            if let jsonValueStartLocation = jsonMap["startLocation"] as? Int {
                resultDecodedBuilder.startLocation = Int32(jsonValueStartLocation)
            } else if let jsonValueStartLocation = jsonMap["startLocation"] as? String {
                resultDecodedBuilder.startLocation = Int32(jsonValueStartLocation)!
            }
            if let jsonValueLabel = jsonMap["label"] as? Int {
                resultDecodedBuilder.label = Int32(jsonValueLabel)
            } else if let jsonValueLabel = jsonMap["label"] as? String {
                resultDecodedBuilder.label = Int32(jsonValueLabel)!
            }
            if let jsonValuePaceType = jsonMap["paceType"] as? Int {
                resultDecodedBuilder.paceType = Int32(jsonValuePaceType)
            } else if let jsonValuePaceType = jsonMap["paceType"] as? String {
                resultDecodedBuilder.paceType = Int32(jsonValuePaceType)!
            }
            if let jsonValueJerseyHash = jsonMap["jerseyHash"] as? Int {
                resultDecodedBuilder.jerseyHash = Int32(jsonValueJerseyHash)
            } else if let jsonValueJerseyHash = jsonMap["jerseyHash"] as? String {
                resultDecodedBuilder.jerseyHash = Int32(jsonValueJerseyHash)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> EventSubgroupProtobuf.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try EventSubgroupProtobuf.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class RiderAttributes : GeneratedMessage {
    public typealias BuilderType = RiderAttributes.Builder

    public static func == (lhs: RiderAttributes, rhs: RiderAttributes) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasF2 == rhs.hasF2) && (!lhs.hasF2 || lhs.f2 == rhs.f2)
        fieldCheck = fieldCheck && (lhs.hasF3 == rhs.hasF3) && (!lhs.hasF3 || lhs.f3 == rhs.f3)
        fieldCheck = fieldCheck && (lhs.hasAttributeMessage == rhs.hasAttributeMessage) && (!lhs.hasAttributeMessage || lhs.attributeMessage == rhs.attributeMessage)
        fieldCheck = fieldCheck && (lhs.hasTheirId == rhs.hasTheirId) && (!lhs.hasTheirId || lhs.theirId == rhs.theirId)
        fieldCheck = fieldCheck && (lhs.hasF13 == rhs.hasF13) && (!lhs.hasF13 || lhs.f13 == rhs.f13)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



    //Nested type declaration start

    final public class AttributeMessage : GeneratedMessage {
        public typealias BuilderType = RiderAttributes.AttributeMessage.Builder

        public static func == (lhs: RiderAttributes.AttributeMessage, rhs: RiderAttributes.AttributeMessage) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMyId == rhs.hasMyId) && (!lhs.hasMyId || lhs.myId == rhs.myId)
            fieldCheck = fieldCheck && (lhs.hasTheirId == rhs.hasTheirId) && (!lhs.hasTheirId || lhs.theirId == rhs.theirId)
            fieldCheck = fieldCheck && (lhs.hasFirstName == rhs.hasFirstName) && (!lhs.hasFirstName || lhs.firstName == rhs.firstName)
            fieldCheck = fieldCheck && (lhs.hasLastName == rhs.hasLastName) && (!lhs.hasLastName || lhs.lastName == rhs.lastName)
            fieldCheck = fieldCheck && (lhs.hasCountryCode == rhs.hasCountryCode) && (!lhs.hasCountryCode || lhs.countryCode == rhs.countryCode)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var myId:Int32! = nil
        public fileprivate(set) var hasMyId:Bool = false

        public fileprivate(set) var theirId:Int32! = nil
        public fileprivate(set) var hasTheirId:Bool = false

        public fileprivate(set) var firstName:String! = nil
        public fileprivate(set) var hasFirstName:Bool = false

        public fileprivate(set) var lastName:String! = nil
        public fileprivate(set) var hasLastName:Bool = false

        public fileprivate(set) var countryCode:Int32! = nil
        public fileprivate(set) var hasCountryCode:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMyId {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:myId)
            }
            if hasTheirId {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:theirId)
            }
            if hasFirstName {
                try codedOutputStream.writeString(fieldNumber: 3, value:firstName)
            }
            if hasLastName {
                try codedOutputStream.writeString(fieldNumber: 4, value:lastName)
            }
            if hasCountryCode {
                try codedOutputStream.writeInt32(fieldNumber: 5, value:countryCode)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMyId {
                serialize_size += myId.computeInt32Size(fieldNumber: 1)
            }
            if hasTheirId {
                serialize_size += theirId.computeInt32Size(fieldNumber: 2)
            }
            if hasFirstName {
                serialize_size += firstName.computeStringSize(fieldNumber: 3)
            }
            if hasLastName {
                serialize_size += lastName.computeStringSize(fieldNumber: 4)
            }
            if hasCountryCode {
                serialize_size += countryCode.computeInt32Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> RiderAttributes.AttributeMessage.Builder {
            return RiderAttributes.AttributeMessage.classBuilder() as! RiderAttributes.AttributeMessage.Builder
        }
        public func getBuilder() -> RiderAttributes.AttributeMessage.Builder {
            return classBuilder() as! RiderAttributes.AttributeMessage.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return RiderAttributes.AttributeMessage.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return RiderAttributes.AttributeMessage.Builder()
        }
        public func toBuilder() throws -> RiderAttributes.AttributeMessage.Builder {
            return try RiderAttributes.AttributeMessage.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:RiderAttributes.AttributeMessage) throws -> RiderAttributes.AttributeMessage.Builder {
            return try RiderAttributes.AttributeMessage.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            guard isInitialized() else {
                return jsonMap
            }
            if hasMyId {
                jsonMap["myId"] = Int(myId)
            }
            if hasTheirId {
                jsonMap["theirId"] = Int(theirId)
            }
            if hasFirstName {
                jsonMap["firstName"] = firstName
            }
            if hasLastName {
                jsonMap["lastName"] = lastName
            }
            if hasCountryCode {
                jsonMap["countryCode"] = Int(countryCode)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> RiderAttributes.AttributeMessage {
            return try RiderAttributes.AttributeMessage.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> RiderAttributes.AttributeMessage {
            return try RiderAttributes.AttributeMessage.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMyId {
                output += "\(indent) myId: \(myId) \n"
            }
            if hasTheirId {
                output += "\(indent) theirId: \(theirId) \n"
            }
            if hasFirstName {
                output += "\(indent) firstName: \(firstName) \n"
            }
            if hasLastName {
                output += "\(indent) lastName: \(lastName) \n"
            }
            if hasCountryCode {
                output += "\(indent) countryCode: \(countryCode) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMyId {
                    hashCode = (hashCode &* 31) &+ myId.hashValue
                }
                if hasTheirId {
                    hashCode = (hashCode &* 31) &+ theirId.hashValue
                }
                if hasFirstName {
                    hashCode = (hashCode &* 31) &+ firstName.hashValue
                }
                if hasLastName {
                    hashCode = (hashCode &* 31) &+ lastName.hashValue
                }
                if hasCountryCode {
                    hashCode = (hashCode &* 31) &+ countryCode.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "RiderAttributes.AttributeMessage"
        }
        override public func className() -> String {
            return "RiderAttributes.AttributeMessage"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:RiderAttributes.AttributeMessage = RiderAttributes.AttributeMessage()
            public func getMessage() -> RiderAttributes.AttributeMessage {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var myId:Int32 {
                get {
                    return builderResult.myId
                }
                set (value) {
                    builderResult.hasMyId = true
                    builderResult.myId = value
                }
            }
            public var hasMyId:Bool {
                get {
                    return builderResult.hasMyId
                }
            }
            @discardableResult
            public func setMyId(_ value:Int32) -> RiderAttributes.AttributeMessage.Builder {
                self.myId = value
                return self
            }
            @discardableResult
            public func clearMyId() -> RiderAttributes.AttributeMessage.Builder{
                builderResult.hasMyId = false
                builderResult.myId = nil
                return self
            }
            public var theirId:Int32 {
                get {
                    return builderResult.theirId
                }
                set (value) {
                    builderResult.hasTheirId = true
                    builderResult.theirId = value
                }
            }
            public var hasTheirId:Bool {
                get {
                    return builderResult.hasTheirId
                }
            }
            @discardableResult
            public func setTheirId(_ value:Int32) -> RiderAttributes.AttributeMessage.Builder {
                self.theirId = value
                return self
            }
            @discardableResult
            public func clearTheirId() -> RiderAttributes.AttributeMessage.Builder{
                builderResult.hasTheirId = false
                builderResult.theirId = nil
                return self
            }
            public var firstName:String {
                get {
                    return builderResult.firstName
                }
                set (value) {
                    builderResult.hasFirstName = true
                    builderResult.firstName = value
                }
            }
            public var hasFirstName:Bool {
                get {
                    return builderResult.hasFirstName
                }
            }
            @discardableResult
            public func setFirstName(_ value:String) -> RiderAttributes.AttributeMessage.Builder {
                self.firstName = value
                return self
            }
            @discardableResult
            public func clearFirstName() -> RiderAttributes.AttributeMessage.Builder{
                builderResult.hasFirstName = false
                builderResult.firstName = nil
                return self
            }
            public var lastName:String {
                get {
                    return builderResult.lastName
                }
                set (value) {
                    builderResult.hasLastName = true
                    builderResult.lastName = value
                }
            }
            public var hasLastName:Bool {
                get {
                    return builderResult.hasLastName
                }
            }
            @discardableResult
            public func setLastName(_ value:String) -> RiderAttributes.AttributeMessage.Builder {
                self.lastName = value
                return self
            }
            @discardableResult
            public func clearLastName() -> RiderAttributes.AttributeMessage.Builder{
                builderResult.hasLastName = false
                builderResult.lastName = nil
                return self
            }
            public var countryCode:Int32 {
                get {
                    return builderResult.countryCode
                }
                set (value) {
                    builderResult.hasCountryCode = true
                    builderResult.countryCode = value
                }
            }
            public var hasCountryCode:Bool {
                get {
                    return builderResult.hasCountryCode
                }
            }
            @discardableResult
            public func setCountryCode(_ value:Int32) -> RiderAttributes.AttributeMessage.Builder {
                self.countryCode = value
                return self
            }
            @discardableResult
            public func clearCountryCode() -> RiderAttributes.AttributeMessage.Builder{
                builderResult.hasCountryCode = false
                builderResult.countryCode = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> RiderAttributes.AttributeMessage.Builder {
                builderResult = RiderAttributes.AttributeMessage()
                return self
            }
            override public func clone() throws -> RiderAttributes.AttributeMessage.Builder {
                return try RiderAttributes.AttributeMessage.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> RiderAttributes.AttributeMessage {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> RiderAttributes.AttributeMessage {
                let returnMe:RiderAttributes.AttributeMessage = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:RiderAttributes.AttributeMessage) throws -> RiderAttributes.AttributeMessage.Builder {
                if other == RiderAttributes.AttributeMessage() {
                    return self
                }
                if other.hasMyId {
                    myId = other.myId
                }
                if other.hasTheirId {
                    theirId = other.theirId
                }
                if other.hasFirstName {
                    firstName = other.firstName
                }
                if other.hasLastName {
                    lastName = other.lastName
                }
                if other.hasCountryCode {
                    countryCode = other.countryCode
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> RiderAttributes.AttributeMessage.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RiderAttributes.AttributeMessage.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        myId = try codedInputStream.readInt32()

                    case 16:
                        theirId = try codedInputStream.readInt32()

                    case 26:
                        firstName = try codedInputStream.readString()

                    case 34:
                        lastName = try codedInputStream.readString()

                    case 40:
                        countryCode = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> RiderAttributes.AttributeMessage.Builder {
                let resultDecodedBuilder = RiderAttributes.AttributeMessage.Builder()
                if let jsonValueMyId = jsonMap["myId"] as? Int {
                    resultDecodedBuilder.myId = Int32(jsonValueMyId)
                } else if let jsonValueMyId = jsonMap["myId"] as? String {
                    resultDecodedBuilder.myId = Int32(jsonValueMyId)!
                }
                if let jsonValueTheirId = jsonMap["theirId"] as? Int {
                    resultDecodedBuilder.theirId = Int32(jsonValueTheirId)
                } else if let jsonValueTheirId = jsonMap["theirId"] as? String {
                    resultDecodedBuilder.theirId = Int32(jsonValueTheirId)!
                }
                if let jsonValueFirstName = jsonMap["firstName"] as? String {
                    resultDecodedBuilder.firstName = jsonValueFirstName
                }
                if let jsonValueLastName = jsonMap["lastName"] as? String {
                    resultDecodedBuilder.lastName = jsonValueLastName
                }
                if let jsonValueCountryCode = jsonMap["countryCode"] as? Int {
                    resultDecodedBuilder.countryCode = Int32(jsonValueCountryCode)
                } else if let jsonValueCountryCode = jsonMap["countryCode"] as? String {
                    resultDecodedBuilder.countryCode = Int32(jsonValueCountryCode)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> RiderAttributes.AttributeMessage.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try RiderAttributes.AttributeMessage.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    //Nested type declaration end

    public fileprivate(set) var f2:Int32! = nil
    public fileprivate(set) var hasF2:Bool = false

    public fileprivate(set) var f3:Int32! = nil
    public fileprivate(set) var hasF3:Bool = false

    public fileprivate(set) var attributeMessage:RiderAttributes.AttributeMessage!
    public fileprivate(set) var hasAttributeMessage:Bool = false
    public fileprivate(set) var theirId:Int32! = nil
    public fileprivate(set) var hasTheirId:Bool = false

    public fileprivate(set) var f13:Int32! = nil
    public fileprivate(set) var hasF13:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasF2 {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:f2)
        }
        if hasF3 {
            try codedOutputStream.writeInt32(fieldNumber: 3, value:f3)
        }
        if hasAttributeMessage {
            try codedOutputStream.writeMessage(fieldNumber: 4, value:attributeMessage)
        }
        if hasTheirId {
            try codedOutputStream.writeInt32(fieldNumber: 10, value:theirId)
        }
        if hasF13 {
            try codedOutputStream.writeInt32(fieldNumber: 13, value:f13)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasF2 {
            serialize_size += f2.computeInt32Size(fieldNumber: 2)
        }
        if hasF3 {
            serialize_size += f3.computeInt32Size(fieldNumber: 3)
        }
        if hasAttributeMessage {
            if let varSizeattributeMessage = attributeMessage?.computeMessageSize(fieldNumber: 4) {
                serialize_size += varSizeattributeMessage
            }
        }
        if hasTheirId {
            serialize_size += theirId.computeInt32Size(fieldNumber: 10)
        }
        if hasF13 {
            serialize_size += f13.computeInt32Size(fieldNumber: 13)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> RiderAttributes.Builder {
        return RiderAttributes.classBuilder() as! RiderAttributes.Builder
    }
    public func getBuilder() -> RiderAttributes.Builder {
        return classBuilder() as! RiderAttributes.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return RiderAttributes.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return RiderAttributes.Builder()
    }
    public func toBuilder() throws -> RiderAttributes.Builder {
        return try RiderAttributes.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:RiderAttributes) throws -> RiderAttributes.Builder {
        return try RiderAttributes.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasF2 {
            jsonMap["f2"] = Int(f2)
        }
        if hasF3 {
            jsonMap["f3"] = Int(f3)
        }
        if hasAttributeMessage {
            jsonMap["attributeMessage"] = try attributeMessage.encode()
        }
        if hasTheirId {
            jsonMap["theirId"] = Int(theirId)
        }
        if hasF13 {
            jsonMap["f13"] = Int(f13)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> RiderAttributes {
        return try RiderAttributes.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> RiderAttributes {
        return try RiderAttributes.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasF2 {
            output += "\(indent) f2: \(f2) \n"
        }
        if hasF3 {
            output += "\(indent) f3: \(f3) \n"
        }
        if hasAttributeMessage {
            output += "\(indent) attributeMessage {\n"
            if let outDescAttributeMessage = attributeMessage {
                output += try outDescAttributeMessage.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasTheirId {
            output += "\(indent) theirId: \(theirId) \n"
        }
        if hasF13 {
            output += "\(indent) f13: \(f13) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasF2 {
                hashCode = (hashCode &* 31) &+ f2.hashValue
            }
            if hasF3 {
                hashCode = (hashCode &* 31) &+ f3.hashValue
            }
            if hasAttributeMessage {
                if let hashValueattributeMessage = attributeMessage?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueattributeMessage
                }
            }
            if hasTheirId {
                hashCode = (hashCode &* 31) &+ theirId.hashValue
            }
            if hasF13 {
                hashCode = (hashCode &* 31) &+ f13.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "RiderAttributes"
    }
    override public func className() -> String {
        return "RiderAttributes"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:RiderAttributes = RiderAttributes()
        public func getMessage() -> RiderAttributes {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var f2:Int32 {
            get {
                return builderResult.f2
            }
            set (value) {
                builderResult.hasF2 = true
                builderResult.f2 = value
            }
        }
        public var hasF2:Bool {
            get {
                return builderResult.hasF2
            }
        }
        @discardableResult
        public func setF2(_ value:Int32) -> RiderAttributes.Builder {
            self.f2 = value
            return self
        }
        @discardableResult
        public func clearF2() -> RiderAttributes.Builder{
            builderResult.hasF2 = false
            builderResult.f2 = nil
            return self
        }
        public var f3:Int32 {
            get {
                return builderResult.f3
            }
            set (value) {
                builderResult.hasF3 = true
                builderResult.f3 = value
            }
        }
        public var hasF3:Bool {
            get {
                return builderResult.hasF3
            }
        }
        @discardableResult
        public func setF3(_ value:Int32) -> RiderAttributes.Builder {
            self.f3 = value
            return self
        }
        @discardableResult
        public func clearF3() -> RiderAttributes.Builder{
            builderResult.hasF3 = false
            builderResult.f3 = nil
            return self
        }
        public var attributeMessage:RiderAttributes.AttributeMessage! {
            get {
                if attributeMessageBuilder_ != nil {
                    builderResult.attributeMessage = attributeMessageBuilder_.getMessage()
                }
                return builderResult.attributeMessage
            }
            set (value) {
                builderResult.hasAttributeMessage = value != nil
                builderResult.attributeMessage = value
            }
        }
        public var hasAttributeMessage:Bool {
            get {
                return builderResult.hasAttributeMessage
            }
        }
        fileprivate var attributeMessageBuilder_:RiderAttributes.AttributeMessage.Builder! {
            didSet {
                builderResult.hasAttributeMessage = true
            }
        }
        public func getAttributeMessageBuilder() -> RiderAttributes.AttributeMessage.Builder {
            if attributeMessageBuilder_ == nil {
                attributeMessageBuilder_ = RiderAttributes.AttributeMessage.Builder()
                builderResult.attributeMessage = attributeMessageBuilder_.getMessage()
                if attributeMessage != nil {
                    try! attributeMessageBuilder_.mergeFrom(other: attributeMessage)
                }
            }
            return attributeMessageBuilder_
        }
        @discardableResult
        public func setAttributeMessage(_ value:RiderAttributes.AttributeMessage!) -> RiderAttributes.Builder {
            self.attributeMessage = value
            return self
        }
        @discardableResult
        public func mergeAttributeMessage(value:RiderAttributes.AttributeMessage) throws -> RiderAttributes.Builder {
            if builderResult.hasAttributeMessage {
                builderResult.attributeMessage = try RiderAttributes.AttributeMessage.builderWithPrototype(prototype:builderResult.attributeMessage).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.attributeMessage = value
            }
            builderResult.hasAttributeMessage = true
            return self
        }
        @discardableResult
        public func clearAttributeMessage() -> RiderAttributes.Builder {
            attributeMessageBuilder_ = nil
            builderResult.hasAttributeMessage = false
            builderResult.attributeMessage = nil
            return self
        }
        public var theirId:Int32 {
            get {
                return builderResult.theirId
            }
            set (value) {
                builderResult.hasTheirId = true
                builderResult.theirId = value
            }
        }
        public var hasTheirId:Bool {
            get {
                return builderResult.hasTheirId
            }
        }
        @discardableResult
        public func setTheirId(_ value:Int32) -> RiderAttributes.Builder {
            self.theirId = value
            return self
        }
        @discardableResult
        public func clearTheirId() -> RiderAttributes.Builder{
            builderResult.hasTheirId = false
            builderResult.theirId = nil
            return self
        }
        public var f13:Int32 {
            get {
                return builderResult.f13
            }
            set (value) {
                builderResult.hasF13 = true
                builderResult.f13 = value
            }
        }
        public var hasF13:Bool {
            get {
                return builderResult.hasF13
            }
        }
        @discardableResult
        public func setF13(_ value:Int32) -> RiderAttributes.Builder {
            self.f13 = value
            return self
        }
        @discardableResult
        public func clearF13() -> RiderAttributes.Builder{
            builderResult.hasF13 = false
            builderResult.f13 = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> RiderAttributes.Builder {
            builderResult = RiderAttributes()
            return self
        }
        override public func clone() throws -> RiderAttributes.Builder {
            return try RiderAttributes.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> RiderAttributes {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> RiderAttributes {
            let returnMe:RiderAttributes = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:RiderAttributes) throws -> RiderAttributes.Builder {
            if other == RiderAttributes() {
                return self
            }
            if other.hasF2 {
                f2 = other.f2
            }
            if other.hasF3 {
                f3 = other.f3
            }
            if (other.hasAttributeMessage) {
                try mergeAttributeMessage(value: other.attributeMessage)
            }
            if other.hasTheirId {
                theirId = other.theirId
            }
            if other.hasF13 {
                f13 = other.f13
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> RiderAttributes.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RiderAttributes.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 16:
                    f2 = try codedInputStream.readInt32()

                case 24:
                    f3 = try codedInputStream.readInt32()

                case 34:
                    let subBuilder:RiderAttributes.AttributeMessage.Builder = RiderAttributes.AttributeMessage.Builder()
                    if hasAttributeMessage {
                        try subBuilder.mergeFrom(other: attributeMessage)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    attributeMessage = subBuilder.buildPartial()

                case 80:
                    theirId = try codedInputStream.readInt32()

                case 104:
                    f13 = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> RiderAttributes.Builder {
            let resultDecodedBuilder = RiderAttributes.Builder()
            if let jsonValueF2 = jsonMap["f2"] as? Int {
                resultDecodedBuilder.f2 = Int32(jsonValueF2)
            } else if let jsonValueF2 = jsonMap["f2"] as? String {
                resultDecodedBuilder.f2 = Int32(jsonValueF2)!
            }
            if let jsonValueF3 = jsonMap["f3"] as? Int {
                resultDecodedBuilder.f3 = Int32(jsonValueF3)
            } else if let jsonValueF3 = jsonMap["f3"] as? String {
                resultDecodedBuilder.f3 = Int32(jsonValueF3)!
            }
            if let jsonValueAttributeMessage = jsonMap["attributeMessage"] as? Dictionary<String,Any> {
                resultDecodedBuilder.attributeMessage = try RiderAttributes.AttributeMessage.Builder.decodeToBuilder(jsonMap:jsonValueAttributeMessage).build()

            }
            if let jsonValueTheirId = jsonMap["theirId"] as? Int {
                resultDecodedBuilder.theirId = Int32(jsonValueTheirId)
            } else if let jsonValueTheirId = jsonMap["theirId"] as? String {
                resultDecodedBuilder.theirId = Int32(jsonValueTheirId)!
            }
            if let jsonValueF13 = jsonMap["f13"] as? Int {
                resultDecodedBuilder.f13 = Int32(jsonValueF13)
            } else if let jsonValueF13 = jsonMap["f13"] as? String {
                resultDecodedBuilder.f13 = Int32(jsonValueF13)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> RiderAttributes.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try RiderAttributes.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Profiles : GeneratedMessage {
    public typealias BuilderType = Profiles.Builder

    public static func == (lhs: Profiles, rhs: Profiles) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.profiles == rhs.profiles)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var profiles:Array<Profile>  = Array<Profile>()
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        for oneElementProfiles in profiles {
              try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementProfiles)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        for oneElementProfiles in profiles {
            serialize_size += oneElementProfiles.computeMessageSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Profiles.Builder {
        return Profiles.classBuilder() as! Profiles.Builder
    }
    public func getBuilder() -> Profiles.Builder {
        return classBuilder() as! Profiles.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Profiles.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Profiles.Builder()
    }
    public func toBuilder() throws -> Profiles.Builder {
        return try Profiles.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Profiles) throws -> Profiles.Builder {
        return try Profiles.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if !profiles.isEmpty {
            var jsonArrayProfiles:Array<Dictionary<String,Any>> = []
            for oneValueProfiles in profiles {
                let ecodedMessageProfiles = try oneValueProfiles.encode()
                jsonArrayProfiles.append(ecodedMessageProfiles)
            }
            jsonMap["profiles"] = jsonArrayProfiles
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Profiles {
        return try Profiles.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Profiles {
        return try Profiles.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        var profilesElementIndex:Int = 0
        for oneElementProfiles in profiles {
            output += "\(indent) profiles[\(profilesElementIndex)] {\n"
            output += try oneElementProfiles.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            profilesElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementProfiles in profiles {
                hashCode = (hashCode &* 31) &+ oneElementProfiles.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Profiles"
    }
    override public func className() -> String {
        return "Profiles"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Profiles = Profiles()
        public func getMessage() -> Profiles {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var profiles:Array<Profile> {
            get {
                return builderResult.profiles
            }
            set (value) {
                builderResult.profiles = value
            }
        }
        @discardableResult
        public func setProfiles(_ value:Array<Profile>) -> Profiles.Builder {
            self.profiles = value
            return self
        }
        @discardableResult
        public func clearProfiles() -> Profiles.Builder {
            builderResult.profiles.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Profiles.Builder {
            builderResult = Profiles()
            return self
        }
        override public func clone() throws -> Profiles.Builder {
            return try Profiles.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Profiles {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Profiles {
            let returnMe:Profiles = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Profiles) throws -> Profiles.Builder {
            if other == Profiles() {
                return self
            }
            if !other.profiles.isEmpty  {
                 builderResult.profiles += other.profiles
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Profiles.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Profiles.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder = Profile.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    profiles.append(subBuilder.buildPartial())

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Profiles.Builder {
            let resultDecodedBuilder = Profiles.Builder()
            if let jsonValueProfiles = jsonMap["profiles"] as? Array<Dictionary<String,Any>> {
                var jsonArrayProfiles:Array<Profile> = []
                for oneValueProfiles in jsonValueProfiles {
                    let messageFromStringProfiles = try Profile.Builder.decodeToBuilder(jsonMap:oneValueProfiles).build()

                    jsonArrayProfiles.append(messageFromStringProfiles)
                }
                resultDecodedBuilder.profiles = jsonArrayProfiles
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Profiles.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Profiles.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Profile : GeneratedMessage {
    public typealias BuilderType = Profile.Builder

    public static func == (lhs: Profile, rhs: Profile) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasFirstName == rhs.hasFirstName) && (!lhs.hasFirstName || lhs.firstName == rhs.firstName)
        fieldCheck = fieldCheck && (lhs.hasLastName == rhs.hasLastName) && (!lhs.hasLastName || lhs.lastName == rhs.lastName)
        fieldCheck = fieldCheck && (lhs.hasMale == rhs.hasMale) && (!lhs.hasMale || lhs.male == rhs.male)
        fieldCheck = fieldCheck && (lhs.hasWeight == rhs.hasWeight) && (!lhs.hasWeight || lhs.weight == rhs.weight)
        fieldCheck = fieldCheck && (lhs.hasBodyType == rhs.hasBodyType) && (!lhs.hasBodyType || lhs.bodyType == rhs.bodyType)
        fieldCheck = fieldCheck && (lhs.hasCountryCode == rhs.hasCountryCode) && (!lhs.hasCountryCode || lhs.countryCode == rhs.countryCode)
        fieldCheck = fieldCheck && (lhs.hasTotalDistance == rhs.hasTotalDistance) && (!lhs.hasTotalDistance || lhs.totalDistance == rhs.totalDistance)
        fieldCheck = fieldCheck && (lhs.hasTotalDistanceClimbed == rhs.hasTotalDistanceClimbed) && (!lhs.hasTotalDistanceClimbed || lhs.totalDistanceClimbed == rhs.totalDistanceClimbed)
        fieldCheck = fieldCheck && (lhs.hasTotalTimeInMinutes == rhs.hasTotalTimeInMinutes) && (!lhs.hasTotalTimeInMinutes || lhs.totalTimeInMinutes == rhs.totalTimeInMinutes)
        fieldCheck = fieldCheck && (lhs.hasTotalWattHours == rhs.hasTotalWattHours) && (!lhs.hasTotalWattHours || lhs.totalWattHours == rhs.totalWattHours)
        fieldCheck = fieldCheck && (lhs.hasHeight == rhs.hasHeight) && (!lhs.hasHeight || lhs.height == rhs.height)
        fieldCheck = fieldCheck && (lhs.hasTotalExperiencePoints == rhs.hasTotalExperiencePoints) && (!lhs.hasTotalExperiencePoints || lhs.totalExperiencePoints == rhs.totalExperiencePoints)
        fieldCheck = fieldCheck && (lhs.hasAchievementLevel == rhs.hasAchievementLevel) && (!lhs.hasAchievementLevel || lhs.achievementLevel == rhs.achievementLevel)
        fieldCheck = fieldCheck && (lhs.hasPowerSource == rhs.hasPowerSource) && (!lhs.hasPowerSource || lhs.powerSource == rhs.powerSource)
        fieldCheck = fieldCheck && (lhs.hasAge == rhs.hasAge) && (!lhs.hasAge || lhs.age == rhs.age)
        fieldCheck = fieldCheck && (lhs.hasLaunchedGameClient == rhs.hasLaunchedGameClient) && (!lhs.hasLaunchedGameClient || lhs.launchedGameClient == rhs.launchedGameClient)
        fieldCheck = fieldCheck && (lhs.hasCurrentActivityId == rhs.hasCurrentActivityId) && (!lhs.hasCurrentActivityId || lhs.currentActivityId == rhs.currentActivityId)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int32! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var firstName:String! = nil
    public fileprivate(set) var hasFirstName:Bool = false

    public fileprivate(set) var lastName:String! = nil
    public fileprivate(set) var hasLastName:Bool = false

    public fileprivate(set) var male:Int32! = nil
    public fileprivate(set) var hasMale:Bool = false

    public fileprivate(set) var weight:Int32! = nil
    public fileprivate(set) var hasWeight:Bool = false

    public fileprivate(set) var bodyType:Int32! = nil
    public fileprivate(set) var hasBodyType:Bool = false

    public fileprivate(set) var countryCode:Int32! = nil
    public fileprivate(set) var hasCountryCode:Bool = false

    public fileprivate(set) var totalDistance:Int32! = nil
    public fileprivate(set) var hasTotalDistance:Bool = false

    public fileprivate(set) var totalDistanceClimbed:Int32! = nil
    public fileprivate(set) var hasTotalDistanceClimbed:Bool = false

    public fileprivate(set) var totalTimeInMinutes:Int32! = nil
    public fileprivate(set) var hasTotalTimeInMinutes:Bool = false

    public fileprivate(set) var totalWattHours:Int32! = nil
    public fileprivate(set) var hasTotalWattHours:Bool = false

    public fileprivate(set) var height:Int32! = nil
    public fileprivate(set) var hasHeight:Bool = false

    public fileprivate(set) var totalExperiencePoints:Int32! = nil
    public fileprivate(set) var hasTotalExperiencePoints:Bool = false

    public fileprivate(set) var achievementLevel:Int32! = nil
    public fileprivate(set) var hasAchievementLevel:Bool = false

    public fileprivate(set) var powerSource:Int32! = nil
    public fileprivate(set) var hasPowerSource:Bool = false

    public fileprivate(set) var age:Int32! = nil
    public fileprivate(set) var hasAge:Bool = false

    public fileprivate(set) var launchedGameClient:String! = nil
    public fileprivate(set) var hasLaunchedGameClient:Bool = false

    public fileprivate(set) var currentActivityId:Int32! = nil
    public fileprivate(set) var hasCurrentActivityId:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:id)
        }
        if hasFirstName {
            try codedOutputStream.writeString(fieldNumber: 4, value:firstName)
        }
        if hasLastName {
            try codedOutputStream.writeString(fieldNumber: 5, value:lastName)
        }
        if hasMale {
            try codedOutputStream.writeInt32(fieldNumber: 6, value:male)
        }
        if hasWeight {
            try codedOutputStream.writeInt32(fieldNumber: 9, value:weight)
        }
        if hasBodyType {
            try codedOutputStream.writeInt32(fieldNumber: 12, value:bodyType)
        }
        if hasCountryCode {
            try codedOutputStream.writeInt32(fieldNumber: 34, value:countryCode)
        }
        if hasTotalDistance {
            try codedOutputStream.writeInt32(fieldNumber: 35, value:totalDistance)
        }
        if hasTotalDistanceClimbed {
            try codedOutputStream.writeInt32(fieldNumber: 36, value:totalDistanceClimbed)
        }
        if hasTotalTimeInMinutes {
            try codedOutputStream.writeInt32(fieldNumber: 37, value:totalTimeInMinutes)
        }
        if hasTotalWattHours {
            try codedOutputStream.writeInt32(fieldNumber: 41, value:totalWattHours)
        }
        if hasHeight {
            try codedOutputStream.writeInt32(fieldNumber: 42, value:height)
        }
        if hasTotalExperiencePoints {
            try codedOutputStream.writeInt32(fieldNumber: 46, value:totalExperiencePoints)
        }
        if hasAchievementLevel {
            try codedOutputStream.writeInt32(fieldNumber: 49, value:achievementLevel)
        }
        if hasPowerSource {
            try codedOutputStream.writeInt32(fieldNumber: 52, value:powerSource)
        }
        if hasAge {
            try codedOutputStream.writeInt32(fieldNumber: 55, value:age)
        }
        if hasLaunchedGameClient {
            try codedOutputStream.writeString(fieldNumber: 108, value:launchedGameClient)
        }
        if hasCurrentActivityId {
            try codedOutputStream.writeInt32(fieldNumber: 109, value:currentActivityId)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt32Size(fieldNumber: 1)
        }
        if hasFirstName {
            serialize_size += firstName.computeStringSize(fieldNumber: 4)
        }
        if hasLastName {
            serialize_size += lastName.computeStringSize(fieldNumber: 5)
        }
        if hasMale {
            serialize_size += male.computeInt32Size(fieldNumber: 6)
        }
        if hasWeight {
            serialize_size += weight.computeInt32Size(fieldNumber: 9)
        }
        if hasBodyType {
            serialize_size += bodyType.computeInt32Size(fieldNumber: 12)
        }
        if hasCountryCode {
            serialize_size += countryCode.computeInt32Size(fieldNumber: 34)
        }
        if hasTotalDistance {
            serialize_size += totalDistance.computeInt32Size(fieldNumber: 35)
        }
        if hasTotalDistanceClimbed {
            serialize_size += totalDistanceClimbed.computeInt32Size(fieldNumber: 36)
        }
        if hasTotalTimeInMinutes {
            serialize_size += totalTimeInMinutes.computeInt32Size(fieldNumber: 37)
        }
        if hasTotalWattHours {
            serialize_size += totalWattHours.computeInt32Size(fieldNumber: 41)
        }
        if hasHeight {
            serialize_size += height.computeInt32Size(fieldNumber: 42)
        }
        if hasTotalExperiencePoints {
            serialize_size += totalExperiencePoints.computeInt32Size(fieldNumber: 46)
        }
        if hasAchievementLevel {
            serialize_size += achievementLevel.computeInt32Size(fieldNumber: 49)
        }
        if hasPowerSource {
            serialize_size += powerSource.computeInt32Size(fieldNumber: 52)
        }
        if hasAge {
            serialize_size += age.computeInt32Size(fieldNumber: 55)
        }
        if hasLaunchedGameClient {
            serialize_size += launchedGameClient.computeStringSize(fieldNumber: 108)
        }
        if hasCurrentActivityId {
            serialize_size += currentActivityId.computeInt32Size(fieldNumber: 109)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Profile.Builder {
        return Profile.classBuilder() as! Profile.Builder
    }
    public func getBuilder() -> Profile.Builder {
        return classBuilder() as! Profile.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Profile.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Profile.Builder()
    }
    public func toBuilder() throws -> Profile.Builder {
        return try Profile.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Profile) throws -> Profile.Builder {
        return try Profile.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasId {
            jsonMap["id"] = Int(id)
        }
        if hasFirstName {
            jsonMap["firstName"] = firstName
        }
        if hasLastName {
            jsonMap["lastName"] = lastName
        }
        if hasMale {
            jsonMap["male"] = Int(male)
        }
        if hasWeight {
            jsonMap["weight"] = Int(weight)
        }
        if hasBodyType {
            jsonMap["bodyType"] = Int(bodyType)
        }
        if hasCountryCode {
            jsonMap["countryCode"] = Int(countryCode)
        }
        if hasTotalDistance {
            jsonMap["totalDistance"] = Int(totalDistance)
        }
        if hasTotalDistanceClimbed {
            jsonMap["totalDistanceClimbed"] = Int(totalDistanceClimbed)
        }
        if hasTotalTimeInMinutes {
            jsonMap["totalTimeInMinutes"] = Int(totalTimeInMinutes)
        }
        if hasTotalWattHours {
            jsonMap["totalWattHours"] = Int(totalWattHours)
        }
        if hasHeight {
            jsonMap["height"] = Int(height)
        }
        if hasTotalExperiencePoints {
            jsonMap["totalExperiencePoints"] = Int(totalExperiencePoints)
        }
        if hasAchievementLevel {
            jsonMap["achievementLevel"] = Int(achievementLevel)
        }
        if hasPowerSource {
            jsonMap["powerSource"] = Int(powerSource)
        }
        if hasAge {
            jsonMap["age"] = Int(age)
        }
        if hasLaunchedGameClient {
            jsonMap["launchedGameClient"] = launchedGameClient
        }
        if hasCurrentActivityId {
            jsonMap["currentActivityId"] = Int(currentActivityId)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Profile {
        return try Profile.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Profile {
        return try Profile.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasFirstName {
            output += "\(indent) firstName: \(firstName) \n"
        }
        if hasLastName {
            output += "\(indent) lastName: \(lastName) \n"
        }
        if hasMale {
            output += "\(indent) male: \(male) \n"
        }
        if hasWeight {
            output += "\(indent) weight: \(weight) \n"
        }
        if hasBodyType {
            output += "\(indent) bodyType: \(bodyType) \n"
        }
        if hasCountryCode {
            output += "\(indent) countryCode: \(countryCode) \n"
        }
        if hasTotalDistance {
            output += "\(indent) totalDistance: \(totalDistance) \n"
        }
        if hasTotalDistanceClimbed {
            output += "\(indent) totalDistanceClimbed: \(totalDistanceClimbed) \n"
        }
        if hasTotalTimeInMinutes {
            output += "\(indent) totalTimeInMinutes: \(totalTimeInMinutes) \n"
        }
        if hasTotalWattHours {
            output += "\(indent) totalWattHours: \(totalWattHours) \n"
        }
        if hasHeight {
            output += "\(indent) height: \(height) \n"
        }
        if hasTotalExperiencePoints {
            output += "\(indent) totalExperiencePoints: \(totalExperiencePoints) \n"
        }
        if hasAchievementLevel {
            output += "\(indent) achievementLevel: \(achievementLevel) \n"
        }
        if hasPowerSource {
            output += "\(indent) powerSource: \(powerSource) \n"
        }
        if hasAge {
            output += "\(indent) age: \(age) \n"
        }
        if hasLaunchedGameClient {
            output += "\(indent) launchedGameClient: \(launchedGameClient) \n"
        }
        if hasCurrentActivityId {
            output += "\(indent) currentActivityId: \(currentActivityId) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasFirstName {
                hashCode = (hashCode &* 31) &+ firstName.hashValue
            }
            if hasLastName {
                hashCode = (hashCode &* 31) &+ lastName.hashValue
            }
            if hasMale {
                hashCode = (hashCode &* 31) &+ male.hashValue
            }
            if hasWeight {
                hashCode = (hashCode &* 31) &+ weight.hashValue
            }
            if hasBodyType {
                hashCode = (hashCode &* 31) &+ bodyType.hashValue
            }
            if hasCountryCode {
                hashCode = (hashCode &* 31) &+ countryCode.hashValue
            }
            if hasTotalDistance {
                hashCode = (hashCode &* 31) &+ totalDistance.hashValue
            }
            if hasTotalDistanceClimbed {
                hashCode = (hashCode &* 31) &+ totalDistanceClimbed.hashValue
            }
            if hasTotalTimeInMinutes {
                hashCode = (hashCode &* 31) &+ totalTimeInMinutes.hashValue
            }
            if hasTotalWattHours {
                hashCode = (hashCode &* 31) &+ totalWattHours.hashValue
            }
            if hasHeight {
                hashCode = (hashCode &* 31) &+ height.hashValue
            }
            if hasTotalExperiencePoints {
                hashCode = (hashCode &* 31) &+ totalExperiencePoints.hashValue
            }
            if hasAchievementLevel {
                hashCode = (hashCode &* 31) &+ achievementLevel.hashValue
            }
            if hasPowerSource {
                hashCode = (hashCode &* 31) &+ powerSource.hashValue
            }
            if hasAge {
                hashCode = (hashCode &* 31) &+ age.hashValue
            }
            if hasLaunchedGameClient {
                hashCode = (hashCode &* 31) &+ launchedGameClient.hashValue
            }
            if hasCurrentActivityId {
                hashCode = (hashCode &* 31) &+ currentActivityId.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Profile"
    }
    override public func className() -> String {
        return "Profile"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Profile = Profile()
        public func getMessage() -> Profile {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int32 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int32) -> Profile.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> Profile.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var firstName:String {
            get {
                return builderResult.firstName
            }
            set (value) {
                builderResult.hasFirstName = true
                builderResult.firstName = value
            }
        }
        public var hasFirstName:Bool {
            get {
                return builderResult.hasFirstName
            }
        }
        @discardableResult
        public func setFirstName(_ value:String) -> Profile.Builder {
            self.firstName = value
            return self
        }
        @discardableResult
        public func clearFirstName() -> Profile.Builder{
            builderResult.hasFirstName = false
            builderResult.firstName = nil
            return self
        }
        public var lastName:String {
            get {
                return builderResult.lastName
            }
            set (value) {
                builderResult.hasLastName = true
                builderResult.lastName = value
            }
        }
        public var hasLastName:Bool {
            get {
                return builderResult.hasLastName
            }
        }
        @discardableResult
        public func setLastName(_ value:String) -> Profile.Builder {
            self.lastName = value
            return self
        }
        @discardableResult
        public func clearLastName() -> Profile.Builder{
            builderResult.hasLastName = false
            builderResult.lastName = nil
            return self
        }
        public var male:Int32 {
            get {
                return builderResult.male
            }
            set (value) {
                builderResult.hasMale = true
                builderResult.male = value
            }
        }
        public var hasMale:Bool {
            get {
                return builderResult.hasMale
            }
        }
        @discardableResult
        public func setMale(_ value:Int32) -> Profile.Builder {
            self.male = value
            return self
        }
        @discardableResult
        public func clearMale() -> Profile.Builder{
            builderResult.hasMale = false
            builderResult.male = nil
            return self
        }
        public var weight:Int32 {
            get {
                return builderResult.weight
            }
            set (value) {
                builderResult.hasWeight = true
                builderResult.weight = value
            }
        }
        public var hasWeight:Bool {
            get {
                return builderResult.hasWeight
            }
        }
        @discardableResult
        public func setWeight(_ value:Int32) -> Profile.Builder {
            self.weight = value
            return self
        }
        @discardableResult
        public func clearWeight() -> Profile.Builder{
            builderResult.hasWeight = false
            builderResult.weight = nil
            return self
        }
        public var bodyType:Int32 {
            get {
                return builderResult.bodyType
            }
            set (value) {
                builderResult.hasBodyType = true
                builderResult.bodyType = value
            }
        }
        public var hasBodyType:Bool {
            get {
                return builderResult.hasBodyType
            }
        }
        @discardableResult
        public func setBodyType(_ value:Int32) -> Profile.Builder {
            self.bodyType = value
            return self
        }
        @discardableResult
        public func clearBodyType() -> Profile.Builder{
            builderResult.hasBodyType = false
            builderResult.bodyType = nil
            return self
        }
        public var countryCode:Int32 {
            get {
                return builderResult.countryCode
            }
            set (value) {
                builderResult.hasCountryCode = true
                builderResult.countryCode = value
            }
        }
        public var hasCountryCode:Bool {
            get {
                return builderResult.hasCountryCode
            }
        }
        @discardableResult
        public func setCountryCode(_ value:Int32) -> Profile.Builder {
            self.countryCode = value
            return self
        }
        @discardableResult
        public func clearCountryCode() -> Profile.Builder{
            builderResult.hasCountryCode = false
            builderResult.countryCode = nil
            return self
        }
        public var totalDistance:Int32 {
            get {
                return builderResult.totalDistance
            }
            set (value) {
                builderResult.hasTotalDistance = true
                builderResult.totalDistance = value
            }
        }
        public var hasTotalDistance:Bool {
            get {
                return builderResult.hasTotalDistance
            }
        }
        @discardableResult
        public func setTotalDistance(_ value:Int32) -> Profile.Builder {
            self.totalDistance = value
            return self
        }
        @discardableResult
        public func clearTotalDistance() -> Profile.Builder{
            builderResult.hasTotalDistance = false
            builderResult.totalDistance = nil
            return self
        }
        public var totalDistanceClimbed:Int32 {
            get {
                return builderResult.totalDistanceClimbed
            }
            set (value) {
                builderResult.hasTotalDistanceClimbed = true
                builderResult.totalDistanceClimbed = value
            }
        }
        public var hasTotalDistanceClimbed:Bool {
            get {
                return builderResult.hasTotalDistanceClimbed
            }
        }
        @discardableResult
        public func setTotalDistanceClimbed(_ value:Int32) -> Profile.Builder {
            self.totalDistanceClimbed = value
            return self
        }
        @discardableResult
        public func clearTotalDistanceClimbed() -> Profile.Builder{
            builderResult.hasTotalDistanceClimbed = false
            builderResult.totalDistanceClimbed = nil
            return self
        }
        public var totalTimeInMinutes:Int32 {
            get {
                return builderResult.totalTimeInMinutes
            }
            set (value) {
                builderResult.hasTotalTimeInMinutes = true
                builderResult.totalTimeInMinutes = value
            }
        }
        public var hasTotalTimeInMinutes:Bool {
            get {
                return builderResult.hasTotalTimeInMinutes
            }
        }
        @discardableResult
        public func setTotalTimeInMinutes(_ value:Int32) -> Profile.Builder {
            self.totalTimeInMinutes = value
            return self
        }
        @discardableResult
        public func clearTotalTimeInMinutes() -> Profile.Builder{
            builderResult.hasTotalTimeInMinutes = false
            builderResult.totalTimeInMinutes = nil
            return self
        }
        public var totalWattHours:Int32 {
            get {
                return builderResult.totalWattHours
            }
            set (value) {
                builderResult.hasTotalWattHours = true
                builderResult.totalWattHours = value
            }
        }
        public var hasTotalWattHours:Bool {
            get {
                return builderResult.hasTotalWattHours
            }
        }
        @discardableResult
        public func setTotalWattHours(_ value:Int32) -> Profile.Builder {
            self.totalWattHours = value
            return self
        }
        @discardableResult
        public func clearTotalWattHours() -> Profile.Builder{
            builderResult.hasTotalWattHours = false
            builderResult.totalWattHours = nil
            return self
        }
        public var height:Int32 {
            get {
                return builderResult.height
            }
            set (value) {
                builderResult.hasHeight = true
                builderResult.height = value
            }
        }
        public var hasHeight:Bool {
            get {
                return builderResult.hasHeight
            }
        }
        @discardableResult
        public func setHeight(_ value:Int32) -> Profile.Builder {
            self.height = value
            return self
        }
        @discardableResult
        public func clearHeight() -> Profile.Builder{
            builderResult.hasHeight = false
            builderResult.height = nil
            return self
        }
        public var totalExperiencePoints:Int32 {
            get {
                return builderResult.totalExperiencePoints
            }
            set (value) {
                builderResult.hasTotalExperiencePoints = true
                builderResult.totalExperiencePoints = value
            }
        }
        public var hasTotalExperiencePoints:Bool {
            get {
                return builderResult.hasTotalExperiencePoints
            }
        }
        @discardableResult
        public func setTotalExperiencePoints(_ value:Int32) -> Profile.Builder {
            self.totalExperiencePoints = value
            return self
        }
        @discardableResult
        public func clearTotalExperiencePoints() -> Profile.Builder{
            builderResult.hasTotalExperiencePoints = false
            builderResult.totalExperiencePoints = nil
            return self
        }
        public var achievementLevel:Int32 {
            get {
                return builderResult.achievementLevel
            }
            set (value) {
                builderResult.hasAchievementLevel = true
                builderResult.achievementLevel = value
            }
        }
        public var hasAchievementLevel:Bool {
            get {
                return builderResult.hasAchievementLevel
            }
        }
        @discardableResult
        public func setAchievementLevel(_ value:Int32) -> Profile.Builder {
            self.achievementLevel = value
            return self
        }
        @discardableResult
        public func clearAchievementLevel() -> Profile.Builder{
            builderResult.hasAchievementLevel = false
            builderResult.achievementLevel = nil
            return self
        }
        public var powerSource:Int32 {
            get {
                return builderResult.powerSource
            }
            set (value) {
                builderResult.hasPowerSource = true
                builderResult.powerSource = value
            }
        }
        public var hasPowerSource:Bool {
            get {
                return builderResult.hasPowerSource
            }
        }
        @discardableResult
        public func setPowerSource(_ value:Int32) -> Profile.Builder {
            self.powerSource = value
            return self
        }
        @discardableResult
        public func clearPowerSource() -> Profile.Builder{
            builderResult.hasPowerSource = false
            builderResult.powerSource = nil
            return self
        }
        public var age:Int32 {
            get {
                return builderResult.age
            }
            set (value) {
                builderResult.hasAge = true
                builderResult.age = value
            }
        }
        public var hasAge:Bool {
            get {
                return builderResult.hasAge
            }
        }
        @discardableResult
        public func setAge(_ value:Int32) -> Profile.Builder {
            self.age = value
            return self
        }
        @discardableResult
        public func clearAge() -> Profile.Builder{
            builderResult.hasAge = false
            builderResult.age = nil
            return self
        }
        public var launchedGameClient:String {
            get {
                return builderResult.launchedGameClient
            }
            set (value) {
                builderResult.hasLaunchedGameClient = true
                builderResult.launchedGameClient = value
            }
        }
        public var hasLaunchedGameClient:Bool {
            get {
                return builderResult.hasLaunchedGameClient
            }
        }
        @discardableResult
        public func setLaunchedGameClient(_ value:String) -> Profile.Builder {
            self.launchedGameClient = value
            return self
        }
        @discardableResult
        public func clearLaunchedGameClient() -> Profile.Builder{
            builderResult.hasLaunchedGameClient = false
            builderResult.launchedGameClient = nil
            return self
        }
        public var currentActivityId:Int32 {
            get {
                return builderResult.currentActivityId
            }
            set (value) {
                builderResult.hasCurrentActivityId = true
                builderResult.currentActivityId = value
            }
        }
        public var hasCurrentActivityId:Bool {
            get {
                return builderResult.hasCurrentActivityId
            }
        }
        @discardableResult
        public func setCurrentActivityId(_ value:Int32) -> Profile.Builder {
            self.currentActivityId = value
            return self
        }
        @discardableResult
        public func clearCurrentActivityId() -> Profile.Builder{
            builderResult.hasCurrentActivityId = false
            builderResult.currentActivityId = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Profile.Builder {
            builderResult = Profile()
            return self
        }
        override public func clone() throws -> Profile.Builder {
            return try Profile.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Profile {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Profile {
            let returnMe:Profile = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Profile) throws -> Profile.Builder {
            if other == Profile() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasFirstName {
                firstName = other.firstName
            }
            if other.hasLastName {
                lastName = other.lastName
            }
            if other.hasMale {
                male = other.male
            }
            if other.hasWeight {
                weight = other.weight
            }
            if other.hasBodyType {
                bodyType = other.bodyType
            }
            if other.hasCountryCode {
                countryCode = other.countryCode
            }
            if other.hasTotalDistance {
                totalDistance = other.totalDistance
            }
            if other.hasTotalDistanceClimbed {
                totalDistanceClimbed = other.totalDistanceClimbed
            }
            if other.hasTotalTimeInMinutes {
                totalTimeInMinutes = other.totalTimeInMinutes
            }
            if other.hasTotalWattHours {
                totalWattHours = other.totalWattHours
            }
            if other.hasHeight {
                height = other.height
            }
            if other.hasTotalExperiencePoints {
                totalExperiencePoints = other.totalExperiencePoints
            }
            if other.hasAchievementLevel {
                achievementLevel = other.achievementLevel
            }
            if other.hasPowerSource {
                powerSource = other.powerSource
            }
            if other.hasAge {
                age = other.age
            }
            if other.hasLaunchedGameClient {
                launchedGameClient = other.launchedGameClient
            }
            if other.hasCurrentActivityId {
                currentActivityId = other.currentActivityId
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Profile.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Profile.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt32()

                case 34:
                    firstName = try codedInputStream.readString()

                case 42:
                    lastName = try codedInputStream.readString()

                case 48:
                    male = try codedInputStream.readInt32()

                case 72:
                    weight = try codedInputStream.readInt32()

                case 96:
                    bodyType = try codedInputStream.readInt32()

                case 272:
                    countryCode = try codedInputStream.readInt32()

                case 280:
                    totalDistance = try codedInputStream.readInt32()

                case 288:
                    totalDistanceClimbed = try codedInputStream.readInt32()

                case 296:
                    totalTimeInMinutes = try codedInputStream.readInt32()

                case 328:
                    totalWattHours = try codedInputStream.readInt32()

                case 336:
                    height = try codedInputStream.readInt32()

                case 368:
                    totalExperiencePoints = try codedInputStream.readInt32()

                case 392:
                    achievementLevel = try codedInputStream.readInt32()

                case 416:
                    powerSource = try codedInputStream.readInt32()

                case 440:
                    age = try codedInputStream.readInt32()

                case 866:
                    launchedGameClient = try codedInputStream.readString()

                case 872:
                    currentActivityId = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Profile.Builder {
            let resultDecodedBuilder = Profile.Builder()
            if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int32(jsonValueId)
            } else if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int32(jsonValueId)!
            }
            if let jsonValueFirstName = jsonMap["firstName"] as? String {
                resultDecodedBuilder.firstName = jsonValueFirstName
            }
            if let jsonValueLastName = jsonMap["lastName"] as? String {
                resultDecodedBuilder.lastName = jsonValueLastName
            }
            if let jsonValueMale = jsonMap["male"] as? Int {
                resultDecodedBuilder.male = Int32(jsonValueMale)
            } else if let jsonValueMale = jsonMap["male"] as? String {
                resultDecodedBuilder.male = Int32(jsonValueMale)!
            }
            if let jsonValueWeight = jsonMap["weight"] as? Int {
                resultDecodedBuilder.weight = Int32(jsonValueWeight)
            } else if let jsonValueWeight = jsonMap["weight"] as? String {
                resultDecodedBuilder.weight = Int32(jsonValueWeight)!
            }
            if let jsonValueBodyType = jsonMap["bodyType"] as? Int {
                resultDecodedBuilder.bodyType = Int32(jsonValueBodyType)
            } else if let jsonValueBodyType = jsonMap["bodyType"] as? String {
                resultDecodedBuilder.bodyType = Int32(jsonValueBodyType)!
            }
            if let jsonValueCountryCode = jsonMap["countryCode"] as? Int {
                resultDecodedBuilder.countryCode = Int32(jsonValueCountryCode)
            } else if let jsonValueCountryCode = jsonMap["countryCode"] as? String {
                resultDecodedBuilder.countryCode = Int32(jsonValueCountryCode)!
            }
            if let jsonValueTotalDistance = jsonMap["totalDistance"] as? Int {
                resultDecodedBuilder.totalDistance = Int32(jsonValueTotalDistance)
            } else if let jsonValueTotalDistance = jsonMap["totalDistance"] as? String {
                resultDecodedBuilder.totalDistance = Int32(jsonValueTotalDistance)!
            }
            if let jsonValueTotalDistanceClimbed = jsonMap["totalDistanceClimbed"] as? Int {
                resultDecodedBuilder.totalDistanceClimbed = Int32(jsonValueTotalDistanceClimbed)
            } else if let jsonValueTotalDistanceClimbed = jsonMap["totalDistanceClimbed"] as? String {
                resultDecodedBuilder.totalDistanceClimbed = Int32(jsonValueTotalDistanceClimbed)!
            }
            if let jsonValueTotalTimeInMinutes = jsonMap["totalTimeInMinutes"] as? Int {
                resultDecodedBuilder.totalTimeInMinutes = Int32(jsonValueTotalTimeInMinutes)
            } else if let jsonValueTotalTimeInMinutes = jsonMap["totalTimeInMinutes"] as? String {
                resultDecodedBuilder.totalTimeInMinutes = Int32(jsonValueTotalTimeInMinutes)!
            }
            if let jsonValueTotalWattHours = jsonMap["totalWattHours"] as? Int {
                resultDecodedBuilder.totalWattHours = Int32(jsonValueTotalWattHours)
            } else if let jsonValueTotalWattHours = jsonMap["totalWattHours"] as? String {
                resultDecodedBuilder.totalWattHours = Int32(jsonValueTotalWattHours)!
            }
            if let jsonValueHeight = jsonMap["height"] as? Int {
                resultDecodedBuilder.height = Int32(jsonValueHeight)
            } else if let jsonValueHeight = jsonMap["height"] as? String {
                resultDecodedBuilder.height = Int32(jsonValueHeight)!
            }
            if let jsonValueTotalExperiencePoints = jsonMap["totalExperiencePoints"] as? Int {
                resultDecodedBuilder.totalExperiencePoints = Int32(jsonValueTotalExperiencePoints)
            } else if let jsonValueTotalExperiencePoints = jsonMap["totalExperiencePoints"] as? String {
                resultDecodedBuilder.totalExperiencePoints = Int32(jsonValueTotalExperiencePoints)!
            }
            if let jsonValueAchievementLevel = jsonMap["achievementLevel"] as? Int {
                resultDecodedBuilder.achievementLevel = Int32(jsonValueAchievementLevel)
            } else if let jsonValueAchievementLevel = jsonMap["achievementLevel"] as? String {
                resultDecodedBuilder.achievementLevel = Int32(jsonValueAchievementLevel)!
            }
            if let jsonValuePowerSource = jsonMap["powerSource"] as? Int {
                resultDecodedBuilder.powerSource = Int32(jsonValuePowerSource)
            } else if let jsonValuePowerSource = jsonMap["powerSource"] as? String {
                resultDecodedBuilder.powerSource = Int32(jsonValuePowerSource)!
            }
            if let jsonValueAge = jsonMap["age"] as? Int {
                resultDecodedBuilder.age = Int32(jsonValueAge)
            } else if let jsonValueAge = jsonMap["age"] as? String {
                resultDecodedBuilder.age = Int32(jsonValueAge)!
            }
            if let jsonValueLaunchedGameClient = jsonMap["launchedGameClient"] as? String {
                resultDecodedBuilder.launchedGameClient = jsonValueLaunchedGameClient
            }
            if let jsonValueCurrentActivityId = jsonMap["currentActivityId"] as? Int {
                resultDecodedBuilder.currentActivityId = Int32(jsonValueCurrentActivityId)
            } else if let jsonValueCurrentActivityId = jsonMap["currentActivityId"] as? String {
                resultDecodedBuilder.currentActivityId = Int32(jsonValueCurrentActivityId)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Profile.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Profile.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Vector3 : GeneratedMessage {
    public typealias BuilderType = Vector3.Builder

    public static func == (lhs: Vector3, rhs: Vector3) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasX == rhs.hasX) && (!lhs.hasX || lhs.x == rhs.x)
        fieldCheck = fieldCheck && (lhs.hasY == rhs.hasY) && (!lhs.hasY || lhs.y == rhs.y)
        fieldCheck = fieldCheck && (lhs.hasZ == rhs.hasZ) && (!lhs.hasZ || lhs.z == rhs.z)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var x:Float! = nil
    public fileprivate(set) var hasX:Bool = false

    public fileprivate(set) var y:Float! = nil
    public fileprivate(set) var hasY:Bool = false

    public fileprivate(set) var z:Float! = nil
    public fileprivate(set) var hasZ:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasX {
            try codedOutputStream.writeFloat(fieldNumber: 1, value:x)
        }
        if hasY {
            try codedOutputStream.writeFloat(fieldNumber: 2, value:y)
        }
        if hasZ {
            try codedOutputStream.writeFloat(fieldNumber: 3, value:z)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasX {
            serialize_size += x.computeFloatSize(fieldNumber: 1)
        }
        if hasY {
            serialize_size += y.computeFloatSize(fieldNumber: 2)
        }
        if hasZ {
            serialize_size += z.computeFloatSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Vector3.Builder {
        return Vector3.classBuilder() as! Vector3.Builder
    }
    public func getBuilder() -> Vector3.Builder {
        return classBuilder() as! Vector3.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Vector3.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Vector3.Builder()
    }
    public func toBuilder() throws -> Vector3.Builder {
        return try Vector3.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Vector3) throws -> Vector3.Builder {
        return try Vector3.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasX {
            jsonMap["x"] = Float(x)
        }
        if hasY {
            jsonMap["y"] = Float(y)
        }
        if hasZ {
            jsonMap["z"] = Float(z)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Vector3 {
        return try Vector3.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Vector3 {
        return try Vector3.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasX {
            output += "\(indent) x: \(x) \n"
        }
        if hasY {
            output += "\(indent) y: \(y) \n"
        }
        if hasZ {
            output += "\(indent) z: \(z) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasX {
                hashCode = (hashCode &* 31) &+ x.hashValue
            }
            if hasY {
                hashCode = (hashCode &* 31) &+ y.hashValue
            }
            if hasZ {
                hashCode = (hashCode &* 31) &+ z.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Vector3"
    }
    override public func className() -> String {
        return "Vector3"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Vector3 = Vector3()
        public func getMessage() -> Vector3 {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var x:Float {
            get {
                return builderResult.x
            }
            set (value) {
                builderResult.hasX = true
                builderResult.x = value
            }
        }
        public var hasX:Bool {
            get {
                return builderResult.hasX
            }
        }
        @discardableResult
        public func setX(_ value:Float) -> Vector3.Builder {
            self.x = value
            return self
        }
        @discardableResult
        public func clearX() -> Vector3.Builder{
            builderResult.hasX = false
            builderResult.x = nil
            return self
        }
        public var y:Float {
            get {
                return builderResult.y
            }
            set (value) {
                builderResult.hasY = true
                builderResult.y = value
            }
        }
        public var hasY:Bool {
            get {
                return builderResult.hasY
            }
        }
        @discardableResult
        public func setY(_ value:Float) -> Vector3.Builder {
            self.y = value
            return self
        }
        @discardableResult
        public func clearY() -> Vector3.Builder{
            builderResult.hasY = false
            builderResult.y = nil
            return self
        }
        public var z:Float {
            get {
                return builderResult.z
            }
            set (value) {
                builderResult.hasZ = true
                builderResult.z = value
            }
        }
        public var hasZ:Bool {
            get {
                return builderResult.hasZ
            }
        }
        @discardableResult
        public func setZ(_ value:Float) -> Vector3.Builder {
            self.z = value
            return self
        }
        @discardableResult
        public func clearZ() -> Vector3.Builder{
            builderResult.hasZ = false
            builderResult.z = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Vector3.Builder {
            builderResult = Vector3()
            return self
        }
        override public func clone() throws -> Vector3.Builder {
            return try Vector3.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Vector3 {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Vector3 {
            let returnMe:Vector3 = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Vector3) throws -> Vector3.Builder {
            if other == Vector3() {
                return self
            }
            if other.hasX {
                x = other.x
            }
            if other.hasY {
                y = other.y
            }
            if other.hasZ {
                z = other.z
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Vector3.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Vector3.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 13:
                    x = try codedInputStream.readFloat()

                case 21:
                    y = try codedInputStream.readFloat()

                case 29:
                    z = try codedInputStream.readFloat()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Vector3.Builder {
            let resultDecodedBuilder = Vector3.Builder()
            if let jsonValueX = jsonMap["x"] as? Float {
                resultDecodedBuilder.x = Float(jsonValueX)
            } else if let jsonValueX = jsonMap["x"] as? String {
                resultDecodedBuilder.x = Float(jsonValueX)!
            }
            if let jsonValueY = jsonMap["y"] as? Float {
                resultDecodedBuilder.y = Float(jsonValueY)
            } else if let jsonValueY = jsonMap["y"] as? String {
                resultDecodedBuilder.y = Float(jsonValueY)!
            }
            if let jsonValueZ = jsonMap["z"] as? Float {
                resultDecodedBuilder.z = Float(jsonValueZ)
            } else if let jsonValueZ = jsonMap["z"] as? String {
                resultDecodedBuilder.z = Float(jsonValueZ)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Vector3.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Vector3.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class PlayerInfo : GeneratedMessage {
    public typealias BuilderType = PlayerInfo.Builder

    public static func == (lhs: PlayerInfo, rhs: PlayerInfo) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasF2 == rhs.hasF2) && (!lhs.hasF2 || lhs.f2 == rhs.f2)
        fieldCheck = fieldCheck && (lhs.hasPosition == rhs.hasPosition) && (!lhs.hasPosition || lhs.position == rhs.position)
        fieldCheck = fieldCheck && (lhs.hasProfile == rhs.hasProfile) && (!lhs.hasProfile || lhs.profile == rhs.profile)
        fieldCheck = fieldCheck && (lhs.hasId2 == rhs.hasId2) && (!lhs.hasId2 || lhs.id2 == rhs.id2)
        fieldCheck = fieldCheck && (lhs.hasF7 == rhs.hasF7) && (!lhs.hasF7 || lhs.f7 == rhs.f7)
        fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
        fieldCheck = fieldCheck && (lhs.hasCountryCode == rhs.hasCountryCode) && (!lhs.hasCountryCode || lhs.countryCode == rhs.countryCode)
        fieldCheck = fieldCheck && (lhs.hasWorldTime == rhs.hasWorldTime) && (!lhs.hasWorldTime || lhs.worldTime == rhs.worldTime)
        fieldCheck = fieldCheck && (lhs.hasF16 == rhs.hasF16) && (!lhs.hasF16 || lhs.f16 == rhs.f16)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int32! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var f2:Int32! = nil
    public fileprivate(set) var hasF2:Bool = false

    public fileprivate(set) var position:Vector3!
    public fileprivate(set) var hasPosition:Bool = false
    public fileprivate(set) var profile:String! = nil
    public fileprivate(set) var hasProfile:Bool = false

    public fileprivate(set) var id2:Int32! = nil
    public fileprivate(set) var hasId2:Bool = false

    public fileprivate(set) var f7:Int32! = nil
    public fileprivate(set) var hasF7:Bool = false

    public fileprivate(set) var name:String! = nil
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var countryCode:Int32! = nil
    public fileprivate(set) var hasCountryCode:Bool = false

    public fileprivate(set) var worldTime:UInt32! = nil
    public fileprivate(set) var hasWorldTime:Bool = false

    public fileprivate(set) var f16:Int32! = nil
    public fileprivate(set) var hasF16:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:id)
        }
        if hasF2 {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:f2)
        }
        if hasPosition {
            try codedOutputStream.writeMessage(fieldNumber: 3, value:position)
        }
        if hasProfile {
            try codedOutputStream.writeString(fieldNumber: 5, value:profile)
        }
        if hasId2 {
            try codedOutputStream.writeInt32(fieldNumber: 6, value:id2)
        }
        if hasF7 {
            try codedOutputStream.writeInt32(fieldNumber: 7, value:f7)
        }
        if hasName {
            try codedOutputStream.writeString(fieldNumber: 11, value:name)
        }
        if hasCountryCode {
            try codedOutputStream.writeInt32(fieldNumber: 12, value:countryCode)
        }
        if hasWorldTime {
            try codedOutputStream.writeFixed32(fieldNumber: 13, value:worldTime)
        }
        if hasF16 {
            try codedOutputStream.writeInt32(fieldNumber: 16, value:f16)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt32Size(fieldNumber: 1)
        }
        if hasF2 {
            serialize_size += f2.computeInt32Size(fieldNumber: 2)
        }
        if hasPosition {
            if let varSizeposition = position?.computeMessageSize(fieldNumber: 3) {
                serialize_size += varSizeposition
            }
        }
        if hasProfile {
            serialize_size += profile.computeStringSize(fieldNumber: 5)
        }
        if hasId2 {
            serialize_size += id2.computeInt32Size(fieldNumber: 6)
        }
        if hasF7 {
            serialize_size += f7.computeInt32Size(fieldNumber: 7)
        }
        if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 11)
        }
        if hasCountryCode {
            serialize_size += countryCode.computeInt32Size(fieldNumber: 12)
        }
        if hasWorldTime {
            serialize_size += worldTime.computeFixed32Size(fieldNumber: 13)
        }
        if hasF16 {
            serialize_size += f16.computeInt32Size(fieldNumber: 16)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> PlayerInfo.Builder {
        return PlayerInfo.classBuilder() as! PlayerInfo.Builder
    }
    public func getBuilder() -> PlayerInfo.Builder {
        return classBuilder() as! PlayerInfo.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PlayerInfo.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PlayerInfo.Builder()
    }
    public func toBuilder() throws -> PlayerInfo.Builder {
        return try PlayerInfo.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:PlayerInfo) throws -> PlayerInfo.Builder {
        return try PlayerInfo.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasId {
            jsonMap["id"] = Int(id)
        }
        if hasF2 {
            jsonMap["f2"] = Int(f2)
        }
        if hasPosition {
            jsonMap["position"] = try position.encode()
        }
        if hasProfile {
            jsonMap["profile"] = profile
        }
        if hasId2 {
            jsonMap["id2"] = Int(id2)
        }
        if hasF7 {
            jsonMap["f7"] = Int(f7)
        }
        if hasName {
            jsonMap["name"] = name
        }
        if hasCountryCode {
            jsonMap["countryCode"] = Int(countryCode)
        }
        if hasWorldTime {
            jsonMap["worldTime"] = UInt(worldTime)
        }
        if hasF16 {
            jsonMap["f16"] = Int(f16)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> PlayerInfo {
        return try PlayerInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> PlayerInfo {
        return try PlayerInfo.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasF2 {
            output += "\(indent) f2: \(f2) \n"
        }
        if hasPosition {
            output += "\(indent) position {\n"
            if let outDescPosition = position {
                output += try outDescPosition.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasProfile {
            output += "\(indent) profile: \(profile) \n"
        }
        if hasId2 {
            output += "\(indent) id2: \(id2) \n"
        }
        if hasF7 {
            output += "\(indent) f7: \(f7) \n"
        }
        if hasName {
            output += "\(indent) name: \(name) \n"
        }
        if hasCountryCode {
            output += "\(indent) countryCode: \(countryCode) \n"
        }
        if hasWorldTime {
            output += "\(indent) worldTime: \(worldTime) \n"
        }
        if hasF16 {
            output += "\(indent) f16: \(f16) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasF2 {
                hashCode = (hashCode &* 31) &+ f2.hashValue
            }
            if hasPosition {
                if let hashValueposition = position?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueposition
                }
            }
            if hasProfile {
                hashCode = (hashCode &* 31) &+ profile.hashValue
            }
            if hasId2 {
                hashCode = (hashCode &* 31) &+ id2.hashValue
            }
            if hasF7 {
                hashCode = (hashCode &* 31) &+ f7.hashValue
            }
            if hasName {
                hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasCountryCode {
                hashCode = (hashCode &* 31) &+ countryCode.hashValue
            }
            if hasWorldTime {
                hashCode = (hashCode &* 31) &+ worldTime.hashValue
            }
            if hasF16 {
                hashCode = (hashCode &* 31) &+ f16.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "PlayerInfo"
    }
    override public func className() -> String {
        return "PlayerInfo"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PlayerInfo = PlayerInfo()
        public func getMessage() -> PlayerInfo {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int32 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int32) -> PlayerInfo.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> PlayerInfo.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var f2:Int32 {
            get {
                return builderResult.f2
            }
            set (value) {
                builderResult.hasF2 = true
                builderResult.f2 = value
            }
        }
        public var hasF2:Bool {
            get {
                return builderResult.hasF2
            }
        }
        @discardableResult
        public func setF2(_ value:Int32) -> PlayerInfo.Builder {
            self.f2 = value
            return self
        }
        @discardableResult
        public func clearF2() -> PlayerInfo.Builder{
            builderResult.hasF2 = false
            builderResult.f2 = nil
            return self
        }
        public var position:Vector3! {
            get {
                if positionBuilder_ != nil {
                    builderResult.position = positionBuilder_.getMessage()
                }
                return builderResult.position
            }
            set (value) {
                builderResult.hasPosition = value != nil
                builderResult.position = value
            }
        }
        public var hasPosition:Bool {
            get {
                return builderResult.hasPosition
            }
        }
        fileprivate var positionBuilder_:Vector3.Builder! {
            didSet {
                builderResult.hasPosition = true
            }
        }
        public func getPositionBuilder() -> Vector3.Builder {
            if positionBuilder_ == nil {
                positionBuilder_ = Vector3.Builder()
                builderResult.position = positionBuilder_.getMessage()
                if position != nil {
                    try! positionBuilder_.mergeFrom(other: position)
                }
            }
            return positionBuilder_
        }
        @discardableResult
        public func setPosition(_ value:Vector3!) -> PlayerInfo.Builder {
            self.position = value
            return self
        }
        @discardableResult
        public func mergePosition(value:Vector3) throws -> PlayerInfo.Builder {
            if builderResult.hasPosition {
                builderResult.position = try Vector3.builderWithPrototype(prototype:builderResult.position).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.position = value
            }
            builderResult.hasPosition = true
            return self
        }
        @discardableResult
        public func clearPosition() -> PlayerInfo.Builder {
            positionBuilder_ = nil
            builderResult.hasPosition = false
            builderResult.position = nil
            return self
        }
        public var profile:String {
            get {
                return builderResult.profile
            }
            set (value) {
                builderResult.hasProfile = true
                builderResult.profile = value
            }
        }
        public var hasProfile:Bool {
            get {
                return builderResult.hasProfile
            }
        }
        @discardableResult
        public func setProfile(_ value:String) -> PlayerInfo.Builder {
            self.profile = value
            return self
        }
        @discardableResult
        public func clearProfile() -> PlayerInfo.Builder{
            builderResult.hasProfile = false
            builderResult.profile = nil
            return self
        }
        public var id2:Int32 {
            get {
                return builderResult.id2
            }
            set (value) {
                builderResult.hasId2 = true
                builderResult.id2 = value
            }
        }
        public var hasId2:Bool {
            get {
                return builderResult.hasId2
            }
        }
        @discardableResult
        public func setId2(_ value:Int32) -> PlayerInfo.Builder {
            self.id2 = value
            return self
        }
        @discardableResult
        public func clearId2() -> PlayerInfo.Builder{
            builderResult.hasId2 = false
            builderResult.id2 = nil
            return self
        }
        public var f7:Int32 {
            get {
                return builderResult.f7
            }
            set (value) {
                builderResult.hasF7 = true
                builderResult.f7 = value
            }
        }
        public var hasF7:Bool {
            get {
                return builderResult.hasF7
            }
        }
        @discardableResult
        public func setF7(_ value:Int32) -> PlayerInfo.Builder {
            self.f7 = value
            return self
        }
        @discardableResult
        public func clearF7() -> PlayerInfo.Builder{
            builderResult.hasF7 = false
            builderResult.f7 = nil
            return self
        }
        public var name:String {
            get {
                return builderResult.name
            }
            set (value) {
                builderResult.hasName = true
                builderResult.name = value
            }
        }
        public var hasName:Bool {
            get {
                return builderResult.hasName
            }
        }
        @discardableResult
        public func setName(_ value:String) -> PlayerInfo.Builder {
            self.name = value
            return self
        }
        @discardableResult
        public func clearName() -> PlayerInfo.Builder{
            builderResult.hasName = false
            builderResult.name = nil
            return self
        }
        public var countryCode:Int32 {
            get {
                return builderResult.countryCode
            }
            set (value) {
                builderResult.hasCountryCode = true
                builderResult.countryCode = value
            }
        }
        public var hasCountryCode:Bool {
            get {
                return builderResult.hasCountryCode
            }
        }
        @discardableResult
        public func setCountryCode(_ value:Int32) -> PlayerInfo.Builder {
            self.countryCode = value
            return self
        }
        @discardableResult
        public func clearCountryCode() -> PlayerInfo.Builder{
            builderResult.hasCountryCode = false
            builderResult.countryCode = nil
            return self
        }
        public var worldTime:UInt32 {
            get {
                return builderResult.worldTime
            }
            set (value) {
                builderResult.hasWorldTime = true
                builderResult.worldTime = value
            }
        }
        public var hasWorldTime:Bool {
            get {
                return builderResult.hasWorldTime
            }
        }
        @discardableResult
        public func setWorldTime(_ value:UInt32) -> PlayerInfo.Builder {
            self.worldTime = value
            return self
        }
        @discardableResult
        public func clearWorldTime() -> PlayerInfo.Builder{
            builderResult.hasWorldTime = false
            builderResult.worldTime = nil
            return self
        }
        public var f16:Int32 {
            get {
                return builderResult.f16
            }
            set (value) {
                builderResult.hasF16 = true
                builderResult.f16 = value
            }
        }
        public var hasF16:Bool {
            get {
                return builderResult.hasF16
            }
        }
        @discardableResult
        public func setF16(_ value:Int32) -> PlayerInfo.Builder {
            self.f16 = value
            return self
        }
        @discardableResult
        public func clearF16() -> PlayerInfo.Builder{
            builderResult.hasF16 = false
            builderResult.f16 = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> PlayerInfo.Builder {
            builderResult = PlayerInfo()
            return self
        }
        override public func clone() throws -> PlayerInfo.Builder {
            return try PlayerInfo.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> PlayerInfo {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> PlayerInfo {
            let returnMe:PlayerInfo = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:PlayerInfo) throws -> PlayerInfo.Builder {
            if other == PlayerInfo() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasF2 {
                f2 = other.f2
            }
            if (other.hasPosition) {
                try mergePosition(value: other.position)
            }
            if other.hasProfile {
                profile = other.profile
            }
            if other.hasId2 {
                id2 = other.id2
            }
            if other.hasF7 {
                f7 = other.f7
            }
            if other.hasName {
                name = other.name
            }
            if other.hasCountryCode {
                countryCode = other.countryCode
            }
            if other.hasWorldTime {
                worldTime = other.worldTime
            }
            if other.hasF16 {
                f16 = other.f16
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PlayerInfo.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PlayerInfo.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt32()

                case 16:
                    f2 = try codedInputStream.readInt32()

                case 26:
                    let subBuilder:Vector3.Builder = Vector3.Builder()
                    if hasPosition {
                        try subBuilder.mergeFrom(other: position)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    position = subBuilder.buildPartial()

                case 42:
                    profile = try codedInputStream.readString()

                case 48:
                    id2 = try codedInputStream.readInt32()

                case 56:
                    f7 = try codedInputStream.readInt32()

                case 90:
                    name = try codedInputStream.readString()

                case 96:
                    countryCode = try codedInputStream.readInt32()

                case 109:
                    worldTime = try codedInputStream.readFixed32()

                case 128:
                    f16 = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PlayerInfo.Builder {
            let resultDecodedBuilder = PlayerInfo.Builder()
            if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int32(jsonValueId)
            } else if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int32(jsonValueId)!
            }
            if let jsonValueF2 = jsonMap["f2"] as? Int {
                resultDecodedBuilder.f2 = Int32(jsonValueF2)
            } else if let jsonValueF2 = jsonMap["f2"] as? String {
                resultDecodedBuilder.f2 = Int32(jsonValueF2)!
            }
            if let jsonValuePosition = jsonMap["position"] as? Dictionary<String,Any> {
                resultDecodedBuilder.position = try Vector3.Builder.decodeToBuilder(jsonMap:jsonValuePosition).build()

            }
            if let jsonValueProfile = jsonMap["profile"] as? String {
                resultDecodedBuilder.profile = jsonValueProfile
            }
            if let jsonValueId2 = jsonMap["id2"] as? Int {
                resultDecodedBuilder.id2 = Int32(jsonValueId2)
            } else if let jsonValueId2 = jsonMap["id2"] as? String {
                resultDecodedBuilder.id2 = Int32(jsonValueId2)!
            }
            if let jsonValueF7 = jsonMap["f7"] as? Int {
                resultDecodedBuilder.f7 = Int32(jsonValueF7)
            } else if let jsonValueF7 = jsonMap["f7"] as? String {
                resultDecodedBuilder.f7 = Int32(jsonValueF7)!
            }
            if let jsonValueName = jsonMap["name"] as? String {
                resultDecodedBuilder.name = jsonValueName
            }
            if let jsonValueCountryCode = jsonMap["countryCode"] as? Int {
                resultDecodedBuilder.countryCode = Int32(jsonValueCountryCode)
            } else if let jsonValueCountryCode = jsonMap["countryCode"] as? String {
                resultDecodedBuilder.countryCode = Int32(jsonValueCountryCode)!
            }
            if let jsonValueWorldTime = jsonMap["worldTime"] as? UInt {
                resultDecodedBuilder.worldTime = UInt32(jsonValueWorldTime)
            } else if let jsonValueWorldTime = jsonMap["worldTime"] as? String {
                resultDecodedBuilder.worldTime = UInt32(jsonValueWorldTime)!
            }
            if let jsonValueF16 = jsonMap["f16"] as? Int {
                resultDecodedBuilder.f16 = Int32(jsonValueF16)
            } else if let jsonValueF16 = jsonMap["f16"] as? String {
                resultDecodedBuilder.f16 = Int32(jsonValueF16)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> PlayerInfo.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PlayerInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Gtpc2161 : GeneratedMessage {
    public typealias BuilderType = Gtpc2161.Builder

    public static func == (lhs: Gtpc2161, rhs: Gtpc2161) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasSeqno == rhs.hasSeqno) && (!lhs.hasSeqno || lhs.seqno == rhs.seqno)
        fieldCheck = fieldCheck && (lhs.playerInfos == rhs.playerInfos)
        fieldCheck = fieldCheck && (lhs.hasF3 == rhs.hasF3) && (!lhs.hasF3 || lhs.f3 == rhs.f3)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var seqno:Int32! = nil
    public fileprivate(set) var hasSeqno:Bool = false

    public fileprivate(set) var playerInfos:Array<PlayerInfo>  = Array<PlayerInfo>()
    public fileprivate(set) var f3:Int32! = nil
    public fileprivate(set) var hasF3:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasSeqno {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:seqno)
        }
        for oneElementPlayerInfos in playerInfos {
              try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementPlayerInfos)
        }
        if hasF3 {
            try codedOutputStream.writeInt32(fieldNumber: 3, value:f3)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasSeqno {
            serialize_size += seqno.computeInt32Size(fieldNumber: 1)
        }
        for oneElementPlayerInfos in playerInfos {
            serialize_size += oneElementPlayerInfos.computeMessageSize(fieldNumber: 2)
        }
        if hasF3 {
            serialize_size += f3.computeInt32Size(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Gtpc2161.Builder {
        return Gtpc2161.classBuilder() as! Gtpc2161.Builder
    }
    public func getBuilder() -> Gtpc2161.Builder {
        return classBuilder() as! Gtpc2161.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Gtpc2161.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Gtpc2161.Builder()
    }
    public func toBuilder() throws -> Gtpc2161.Builder {
        return try Gtpc2161.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Gtpc2161) throws -> Gtpc2161.Builder {
        return try Gtpc2161.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasSeqno {
            jsonMap["seqno"] = Int(seqno)
        }
        if !playerInfos.isEmpty {
            var jsonArrayPlayerInfos:Array<Dictionary<String,Any>> = []
            for oneValuePlayerInfos in playerInfos {
                let ecodedMessagePlayerInfos = try oneValuePlayerInfos.encode()
                jsonArrayPlayerInfos.append(ecodedMessagePlayerInfos)
            }
            jsonMap["playerInfos"] = jsonArrayPlayerInfos
        }
        if hasF3 {
            jsonMap["f3"] = Int(f3)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Gtpc2161 {
        return try Gtpc2161.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Gtpc2161 {
        return try Gtpc2161.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasSeqno {
            output += "\(indent) seqno: \(seqno) \n"
        }
        var playerInfosElementIndex:Int = 0
        for oneElementPlayerInfos in playerInfos {
            output += "\(indent) playerInfos[\(playerInfosElementIndex)] {\n"
            output += try oneElementPlayerInfos.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            playerInfosElementIndex += 1
        }
        if hasF3 {
            output += "\(indent) f3: \(f3) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSeqno {
                hashCode = (hashCode &* 31) &+ seqno.hashValue
            }
            for oneElementPlayerInfos in playerInfos {
                hashCode = (hashCode &* 31) &+ oneElementPlayerInfos.hashValue
            }
            if hasF3 {
                hashCode = (hashCode &* 31) &+ f3.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Gtpc2161"
    }
    override public func className() -> String {
        return "Gtpc2161"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Gtpc2161 = Gtpc2161()
        public func getMessage() -> Gtpc2161 {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var seqno:Int32 {
            get {
                return builderResult.seqno
            }
            set (value) {
                builderResult.hasSeqno = true
                builderResult.seqno = value
            }
        }
        public var hasSeqno:Bool {
            get {
                return builderResult.hasSeqno
            }
        }
        @discardableResult
        public func setSeqno(_ value:Int32) -> Gtpc2161.Builder {
            self.seqno = value
            return self
        }
        @discardableResult
        public func clearSeqno() -> Gtpc2161.Builder{
            builderResult.hasSeqno = false
            builderResult.seqno = nil
            return self
        }
        public var playerInfos:Array<PlayerInfo> {
            get {
                return builderResult.playerInfos
            }
            set (value) {
                builderResult.playerInfos = value
            }
        }
        @discardableResult
        public func setPlayerInfos(_ value:Array<PlayerInfo>) -> Gtpc2161.Builder {
            self.playerInfos = value
            return self
        }
        @discardableResult
        public func clearPlayerInfos() -> Gtpc2161.Builder {
            builderResult.playerInfos.removeAll(keepingCapacity: false)
            return self
        }
        public var f3:Int32 {
            get {
                return builderResult.f3
            }
            set (value) {
                builderResult.hasF3 = true
                builderResult.f3 = value
            }
        }
        public var hasF3:Bool {
            get {
                return builderResult.hasF3
            }
        }
        @discardableResult
        public func setF3(_ value:Int32) -> Gtpc2161.Builder {
            self.f3 = value
            return self
        }
        @discardableResult
        public func clearF3() -> Gtpc2161.Builder{
            builderResult.hasF3 = false
            builderResult.f3 = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Gtpc2161.Builder {
            builderResult = Gtpc2161()
            return self
        }
        override public func clone() throws -> Gtpc2161.Builder {
            return try Gtpc2161.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Gtpc2161 {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Gtpc2161 {
            let returnMe:Gtpc2161 = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Gtpc2161) throws -> Gtpc2161.Builder {
            if other == Gtpc2161() {
                return self
            }
            if other.hasSeqno {
                seqno = other.seqno
            }
            if !other.playerInfos.isEmpty  {
                 builderResult.playerInfos += other.playerInfos
            }
            if other.hasF3 {
                f3 = other.f3
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Gtpc2161.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc2161.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    seqno = try codedInputStream.readInt32()

                case 18:
                    let subBuilder = PlayerInfo.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    playerInfos.append(subBuilder.buildPartial())

                case 24:
                    f3 = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Gtpc2161.Builder {
            let resultDecodedBuilder = Gtpc2161.Builder()
            if let jsonValueSeqno = jsonMap["seqno"] as? Int {
                resultDecodedBuilder.seqno = Int32(jsonValueSeqno)
            } else if let jsonValueSeqno = jsonMap["seqno"] as? String {
                resultDecodedBuilder.seqno = Int32(jsonValueSeqno)!
            }
            if let jsonValuePlayerInfos = jsonMap["playerInfos"] as? Array<Dictionary<String,Any>> {
                var jsonArrayPlayerInfos:Array<PlayerInfo> = []
                for oneValuePlayerInfos in jsonValuePlayerInfos {
                    let messageFromStringPlayerInfos = try PlayerInfo.Builder.decodeToBuilder(jsonMap:oneValuePlayerInfos).build()

                    jsonArrayPlayerInfos.append(messageFromStringPlayerInfos)
                }
                resultDecodedBuilder.playerInfos = jsonArrayPlayerInfos
            }
            if let jsonValueF3 = jsonMap["f3"] as? Int {
                resultDecodedBuilder.f3 = Int32(jsonValueF3)
            } else if let jsonValueF3 = jsonMap["f3"] as? String {
                resultDecodedBuilder.f3 = Int32(jsonValueF3)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Gtpc2161.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Gtpc2161.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Gtpc216 : GeneratedMessage {
    public typealias BuilderType = Gtpc216.Builder

    public static func == (lhs: Gtpc216, rhs: Gtpc216) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.gtpc2161 == rhs.gtpc2161)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var gtpc2161:Array<Gtpc2161>  = Array<Gtpc2161>()
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        for oneElementGtpc2161 in gtpc2161 {
              try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementGtpc2161)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        for oneElementGtpc2161 in gtpc2161 {
            serialize_size += oneElementGtpc2161.computeMessageSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Gtpc216.Builder {
        return Gtpc216.classBuilder() as! Gtpc216.Builder
    }
    public func getBuilder() -> Gtpc216.Builder {
        return classBuilder() as! Gtpc216.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Gtpc216.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Gtpc216.Builder()
    }
    public func toBuilder() throws -> Gtpc216.Builder {
        return try Gtpc216.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Gtpc216) throws -> Gtpc216.Builder {
        return try Gtpc216.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if !gtpc2161.isEmpty {
            var jsonArrayGtpc2161:Array<Dictionary<String,Any>> = []
            for oneValueGtpc2161 in gtpc2161 {
                let ecodedMessageGtpc2161 = try oneValueGtpc2161.encode()
                jsonArrayGtpc2161.append(ecodedMessageGtpc2161)
            }
            jsonMap["gtpc2161"] = jsonArrayGtpc2161
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Gtpc216 {
        return try Gtpc216.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Gtpc216 {
        return try Gtpc216.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        var gtpc2161ElementIndex:Int = 0
        for oneElementGtpc2161 in gtpc2161 {
            output += "\(indent) gtpc2161[\(gtpc2161ElementIndex)] {\n"
            output += try oneElementGtpc2161.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            gtpc2161ElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementGtpc2161 in gtpc2161 {
                hashCode = (hashCode &* 31) &+ oneElementGtpc2161.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Gtpc216"
    }
    override public func className() -> String {
        return "Gtpc216"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Gtpc216 = Gtpc216()
        public func getMessage() -> Gtpc216 {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var gtpc2161:Array<Gtpc2161> {
            get {
                return builderResult.gtpc2161
            }
            set (value) {
                builderResult.gtpc2161 = value
            }
        }
        @discardableResult
        public func setGtpc2161(_ value:Array<Gtpc2161>) -> Gtpc216.Builder {
            self.gtpc2161 = value
            return self
        }
        @discardableResult
        public func clearGtpc2161() -> Gtpc216.Builder {
            builderResult.gtpc2161.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Gtpc216.Builder {
            builderResult = Gtpc216()
            return self
        }
        override public func clone() throws -> Gtpc216.Builder {
            return try Gtpc216.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Gtpc216 {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Gtpc216 {
            let returnMe:Gtpc216 = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Gtpc216) throws -> Gtpc216.Builder {
            if other == Gtpc216() {
                return self
            }
            if !other.gtpc2161.isEmpty  {
                 builderResult.gtpc2161 += other.gtpc2161
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Gtpc216.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc216.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder = Gtpc2161.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    gtpc2161.append(subBuilder.buildPartial())

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Gtpc216.Builder {
            let resultDecodedBuilder = Gtpc216.Builder()
            if let jsonValueGtpc2161 = jsonMap["gtpc2161"] as? Array<Dictionary<String,Any>> {
                var jsonArrayGtpc2161:Array<Gtpc2161> = []
                for oneValueGtpc2161 in jsonValueGtpc2161 {
                    let messageFromStringGtpc2161 = try Gtpc2161.Builder.decodeToBuilder(jsonMap:oneValueGtpc2161).build()

                    jsonArrayGtpc2161.append(messageFromStringGtpc2161)
                }
                resultDecodedBuilder.gtpc2161 = jsonArrayGtpc2161
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Gtpc216.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Gtpc216.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Gtpc214 : GeneratedMessage {
    public typealias BuilderType = Gtpc214.Builder

    public static func == (lhs: Gtpc214, rhs: Gtpc214) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasF1 == rhs.hasF1) && (!lhs.hasF1 || lhs.f1 == rhs.f1)
        fieldCheck = fieldCheck && (lhs.hasF6 == rhs.hasF6) && (!lhs.hasF6 || lhs.f6 == rhs.f6)
        fieldCheck = fieldCheck && (lhs.hasF7 == rhs.hasF7) && (!lhs.hasF7 || lhs.f7 == rhs.f7)
        fieldCheck = fieldCheck && (lhs.hasF8 == rhs.hasF8) && (!lhs.hasF8 || lhs.f8 == rhs.f8)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var f1:Int32! = nil
    public fileprivate(set) var hasF1:Bool = false

    public fileprivate(set) var f6:String! = nil
    public fileprivate(set) var hasF6:Bool = false

    public fileprivate(set) var f7:Int32! = nil
    public fileprivate(set) var hasF7:Bool = false

    public fileprivate(set) var f8:Int32! = nil
    public fileprivate(set) var hasF8:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasF1 {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:f1)
        }
        if hasF6 {
            try codedOutputStream.writeString(fieldNumber: 6, value:f6)
        }
        if hasF7 {
            try codedOutputStream.writeInt32(fieldNumber: 7, value:f7)
        }
        if hasF8 {
            try codedOutputStream.writeInt32(fieldNumber: 8, value:f8)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasF1 {
            serialize_size += f1.computeInt32Size(fieldNumber: 1)
        }
        if hasF6 {
            serialize_size += f6.computeStringSize(fieldNumber: 6)
        }
        if hasF7 {
            serialize_size += f7.computeInt32Size(fieldNumber: 7)
        }
        if hasF8 {
            serialize_size += f8.computeInt32Size(fieldNumber: 8)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Gtpc214.Builder {
        return Gtpc214.classBuilder() as! Gtpc214.Builder
    }
    public func getBuilder() -> Gtpc214.Builder {
        return classBuilder() as! Gtpc214.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Gtpc214.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Gtpc214.Builder()
    }
    public func toBuilder() throws -> Gtpc214.Builder {
        return try Gtpc214.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Gtpc214) throws -> Gtpc214.Builder {
        return try Gtpc214.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasF1 {
            jsonMap["f1"] = Int(f1)
        }
        if hasF6 {
            jsonMap["f6"] = f6
        }
        if hasF7 {
            jsonMap["f7"] = Int(f7)
        }
        if hasF8 {
            jsonMap["f8"] = Int(f8)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Gtpc214 {
        return try Gtpc214.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Gtpc214 {
        return try Gtpc214.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasF1 {
            output += "\(indent) f1: \(f1) \n"
        }
        if hasF6 {
            output += "\(indent) f6: \(f6) \n"
        }
        if hasF7 {
            output += "\(indent) f7: \(f7) \n"
        }
        if hasF8 {
            output += "\(indent) f8: \(f8) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasF1 {
                hashCode = (hashCode &* 31) &+ f1.hashValue
            }
            if hasF6 {
                hashCode = (hashCode &* 31) &+ f6.hashValue
            }
            if hasF7 {
                hashCode = (hashCode &* 31) &+ f7.hashValue
            }
            if hasF8 {
                hashCode = (hashCode &* 31) &+ f8.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Gtpc214"
    }
    override public func className() -> String {
        return "Gtpc214"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Gtpc214 = Gtpc214()
        public func getMessage() -> Gtpc214 {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var f1:Int32 {
            get {
                return builderResult.f1
            }
            set (value) {
                builderResult.hasF1 = true
                builderResult.f1 = value
            }
        }
        public var hasF1:Bool {
            get {
                return builderResult.hasF1
            }
        }
        @discardableResult
        public func setF1(_ value:Int32) -> Gtpc214.Builder {
            self.f1 = value
            return self
        }
        @discardableResult
        public func clearF1() -> Gtpc214.Builder{
            builderResult.hasF1 = false
            builderResult.f1 = nil
            return self
        }
        public var f6:String {
            get {
                return builderResult.f6
            }
            set (value) {
                builderResult.hasF6 = true
                builderResult.f6 = value
            }
        }
        public var hasF6:Bool {
            get {
                return builderResult.hasF6
            }
        }
        @discardableResult
        public func setF6(_ value:String) -> Gtpc214.Builder {
            self.f6 = value
            return self
        }
        @discardableResult
        public func clearF6() -> Gtpc214.Builder{
            builderResult.hasF6 = false
            builderResult.f6 = nil
            return self
        }
        public var f7:Int32 {
            get {
                return builderResult.f7
            }
            set (value) {
                builderResult.hasF7 = true
                builderResult.f7 = value
            }
        }
        public var hasF7:Bool {
            get {
                return builderResult.hasF7
            }
        }
        @discardableResult
        public func setF7(_ value:Int32) -> Gtpc214.Builder {
            self.f7 = value
            return self
        }
        @discardableResult
        public func clearF7() -> Gtpc214.Builder{
            builderResult.hasF7 = false
            builderResult.f7 = nil
            return self
        }
        public var f8:Int32 {
            get {
                return builderResult.f8
            }
            set (value) {
                builderResult.hasF8 = true
                builderResult.f8 = value
            }
        }
        public var hasF8:Bool {
            get {
                return builderResult.hasF8
            }
        }
        @discardableResult
        public func setF8(_ value:Int32) -> Gtpc214.Builder {
            self.f8 = value
            return self
        }
        @discardableResult
        public func clearF8() -> Gtpc214.Builder{
            builderResult.hasF8 = false
            builderResult.f8 = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Gtpc214.Builder {
            builderResult = Gtpc214()
            return self
        }
        override public func clone() throws -> Gtpc214.Builder {
            return try Gtpc214.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Gtpc214 {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Gtpc214 {
            let returnMe:Gtpc214 = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Gtpc214) throws -> Gtpc214.Builder {
            if other == Gtpc214() {
                return self
            }
            if other.hasF1 {
                f1 = other.f1
            }
            if other.hasF6 {
                f6 = other.f6
            }
            if other.hasF7 {
                f7 = other.f7
            }
            if other.hasF8 {
                f8 = other.f8
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Gtpc214.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc214.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    f1 = try codedInputStream.readInt32()

                case 50:
                    f6 = try codedInputStream.readString()

                case 56:
                    f7 = try codedInputStream.readInt32()

                case 64:
                    f8 = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Gtpc214.Builder {
            let resultDecodedBuilder = Gtpc214.Builder()
            if let jsonValueF1 = jsonMap["f1"] as? Int {
                resultDecodedBuilder.f1 = Int32(jsonValueF1)
            } else if let jsonValueF1 = jsonMap["f1"] as? String {
                resultDecodedBuilder.f1 = Int32(jsonValueF1)!
            }
            if let jsonValueF6 = jsonMap["f6"] as? String {
                resultDecodedBuilder.f6 = jsonValueF6
            }
            if let jsonValueF7 = jsonMap["f7"] as? Int {
                resultDecodedBuilder.f7 = Int32(jsonValueF7)
            } else if let jsonValueF7 = jsonMap["f7"] as? String {
                resultDecodedBuilder.f7 = Int32(jsonValueF7)!
            }
            if let jsonValueF8 = jsonMap["f8"] as? Int {
                resultDecodedBuilder.f8 = Int32(jsonValueF8)
            } else if let jsonValueF8 = jsonMap["f8"] as? String {
                resultDecodedBuilder.f8 = Int32(jsonValueF8)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Gtpc214.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Gtpc214.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Gtpc218 : GeneratedMessage {
    public typealias BuilderType = Gtpc218.Builder

    public static func == (lhs: Gtpc218, rhs: Gtpc218) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasF1 == rhs.hasF1) && (!lhs.hasF1 || lhs.f1 == rhs.f1)
        fieldCheck = fieldCheck && (lhs.hasF2 == rhs.hasF2) && (!lhs.hasF2 || lhs.f2 == rhs.f2)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var f1:Int32! = nil
    public fileprivate(set) var hasF1:Bool = false

    public fileprivate(set) var f2:Int32! = nil
    public fileprivate(set) var hasF2:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasF1 {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:f1)
        }
        if hasF2 {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:f2)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasF1 {
            serialize_size += f1.computeInt32Size(fieldNumber: 1)
        }
        if hasF2 {
            serialize_size += f2.computeInt32Size(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Gtpc218.Builder {
        return Gtpc218.classBuilder() as! Gtpc218.Builder
    }
    public func getBuilder() -> Gtpc218.Builder {
        return classBuilder() as! Gtpc218.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Gtpc218.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Gtpc218.Builder()
    }
    public func toBuilder() throws -> Gtpc218.Builder {
        return try Gtpc218.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Gtpc218) throws -> Gtpc218.Builder {
        return try Gtpc218.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasF1 {
            jsonMap["f1"] = Int(f1)
        }
        if hasF2 {
            jsonMap["f2"] = Int(f2)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Gtpc218 {
        return try Gtpc218.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Gtpc218 {
        return try Gtpc218.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasF1 {
            output += "\(indent) f1: \(f1) \n"
        }
        if hasF2 {
            output += "\(indent) f2: \(f2) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasF1 {
                hashCode = (hashCode &* 31) &+ f1.hashValue
            }
            if hasF2 {
                hashCode = (hashCode &* 31) &+ f2.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Gtpc218"
    }
    override public func className() -> String {
        return "Gtpc218"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Gtpc218 = Gtpc218()
        public func getMessage() -> Gtpc218 {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var f1:Int32 {
            get {
                return builderResult.f1
            }
            set (value) {
                builderResult.hasF1 = true
                builderResult.f1 = value
            }
        }
        public var hasF1:Bool {
            get {
                return builderResult.hasF1
            }
        }
        @discardableResult
        public func setF1(_ value:Int32) -> Gtpc218.Builder {
            self.f1 = value
            return self
        }
        @discardableResult
        public func clearF1() -> Gtpc218.Builder{
            builderResult.hasF1 = false
            builderResult.f1 = nil
            return self
        }
        public var f2:Int32 {
            get {
                return builderResult.f2
            }
            set (value) {
                builderResult.hasF2 = true
                builderResult.f2 = value
            }
        }
        public var hasF2:Bool {
            get {
                return builderResult.hasF2
            }
        }
        @discardableResult
        public func setF2(_ value:Int32) -> Gtpc218.Builder {
            self.f2 = value
            return self
        }
        @discardableResult
        public func clearF2() -> Gtpc218.Builder{
            builderResult.hasF2 = false
            builderResult.f2 = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Gtpc218.Builder {
            builderResult = Gtpc218()
            return self
        }
        override public func clone() throws -> Gtpc218.Builder {
            return try Gtpc218.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Gtpc218 {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Gtpc218 {
            let returnMe:Gtpc218 = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Gtpc218) throws -> Gtpc218.Builder {
            if other == Gtpc218() {
                return self
            }
            if other.hasF1 {
                f1 = other.f1
            }
            if other.hasF2 {
                f2 = other.f2
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Gtpc218.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc218.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    f1 = try codedInputStream.readInt32()

                case 16:
                    f2 = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Gtpc218.Builder {
            let resultDecodedBuilder = Gtpc218.Builder()
            if let jsonValueF1 = jsonMap["f1"] as? Int {
                resultDecodedBuilder.f1 = Int32(jsonValueF1)
            } else if let jsonValueF1 = jsonMap["f1"] as? String {
                resultDecodedBuilder.f1 = Int32(jsonValueF1)!
            }
            if let jsonValueF2 = jsonMap["f2"] as? Int {
                resultDecodedBuilder.f2 = Int32(jsonValueF2)
            } else if let jsonValueF2 = jsonMap["f2"] as? String {
                resultDecodedBuilder.f2 = Int32(jsonValueF2)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Gtpc218.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Gtpc218.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Gtpc21 : GeneratedMessage {
    public typealias BuilderType = Gtpc21.Builder

    public static func == (lhs: Gtpc21, rhs: Gtpc21) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasF1 == rhs.hasF1) && (!lhs.hasF1 || lhs.f1 == rhs.f1)
        fieldCheck = fieldCheck && (lhs.hasGtpc214 == rhs.hasGtpc214) && (!lhs.hasGtpc214 || lhs.gtpc214 == rhs.gtpc214)
        fieldCheck = fieldCheck && (lhs.hasGtpc216 == rhs.hasGtpc216) && (!lhs.hasGtpc216 || lhs.gtpc216 == rhs.gtpc216)
        fieldCheck = fieldCheck && (lhs.hasGtpc218 == rhs.hasGtpc218) && (!lhs.hasGtpc218 || lhs.gtpc218 == rhs.gtpc218)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var f1:Int32! = nil
    public fileprivate(set) var hasF1:Bool = false

    public fileprivate(set) var gtpc214:Gtpc214!
    public fileprivate(set) var hasGtpc214:Bool = false
    public fileprivate(set) var gtpc216:Gtpc216!
    public fileprivate(set) var hasGtpc216:Bool = false
    public fileprivate(set) var gtpc218:Gtpc218!
    public fileprivate(set) var hasGtpc218:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasF1 {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:f1)
        }
        if hasGtpc214 {
            try codedOutputStream.writeMessage(fieldNumber: 4, value:gtpc214)
        }
        if hasGtpc216 {
            try codedOutputStream.writeMessage(fieldNumber: 6, value:gtpc216)
        }
        if hasGtpc218 {
            try codedOutputStream.writeMessage(fieldNumber: 8, value:gtpc218)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasF1 {
            serialize_size += f1.computeInt32Size(fieldNumber: 1)
        }
        if hasGtpc214 {
            if let varSizegtpc214 = gtpc214?.computeMessageSize(fieldNumber: 4) {
                serialize_size += varSizegtpc214
            }
        }
        if hasGtpc216 {
            if let varSizegtpc216 = gtpc216?.computeMessageSize(fieldNumber: 6) {
                serialize_size += varSizegtpc216
            }
        }
        if hasGtpc218 {
            if let varSizegtpc218 = gtpc218?.computeMessageSize(fieldNumber: 8) {
                serialize_size += varSizegtpc218
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Gtpc21.Builder {
        return Gtpc21.classBuilder() as! Gtpc21.Builder
    }
    public func getBuilder() -> Gtpc21.Builder {
        return classBuilder() as! Gtpc21.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Gtpc21.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Gtpc21.Builder()
    }
    public func toBuilder() throws -> Gtpc21.Builder {
        return try Gtpc21.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Gtpc21) throws -> Gtpc21.Builder {
        return try Gtpc21.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasF1 {
            jsonMap["f1"] = Int(f1)
        }
        if hasGtpc214 {
            jsonMap["gtpc214"] = try gtpc214.encode()
        }
        if hasGtpc216 {
            jsonMap["gtpc216"] = try gtpc216.encode()
        }
        if hasGtpc218 {
            jsonMap["gtpc218"] = try gtpc218.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Gtpc21 {
        return try Gtpc21.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Gtpc21 {
        return try Gtpc21.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasF1 {
            output += "\(indent) f1: \(f1) \n"
        }
        if hasGtpc214 {
            output += "\(indent) gtpc214 {\n"
            if let outDescGtpc214 = gtpc214 {
                output += try outDescGtpc214.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasGtpc216 {
            output += "\(indent) gtpc216 {\n"
            if let outDescGtpc216 = gtpc216 {
                output += try outDescGtpc216.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasGtpc218 {
            output += "\(indent) gtpc218 {\n"
            if let outDescGtpc218 = gtpc218 {
                output += try outDescGtpc218.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasF1 {
                hashCode = (hashCode &* 31) &+ f1.hashValue
            }
            if hasGtpc214 {
                if let hashValuegtpc214 = gtpc214?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegtpc214
                }
            }
            if hasGtpc216 {
                if let hashValuegtpc216 = gtpc216?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegtpc216
                }
            }
            if hasGtpc218 {
                if let hashValuegtpc218 = gtpc218?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegtpc218
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Gtpc21"
    }
    override public func className() -> String {
        return "Gtpc21"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Gtpc21 = Gtpc21()
        public func getMessage() -> Gtpc21 {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var f1:Int32 {
            get {
                return builderResult.f1
            }
            set (value) {
                builderResult.hasF1 = true
                builderResult.f1 = value
            }
        }
        public var hasF1:Bool {
            get {
                return builderResult.hasF1
            }
        }
        @discardableResult
        public func setF1(_ value:Int32) -> Gtpc21.Builder {
            self.f1 = value
            return self
        }
        @discardableResult
        public func clearF1() -> Gtpc21.Builder{
            builderResult.hasF1 = false
            builderResult.f1 = nil
            return self
        }
        public var gtpc214:Gtpc214! {
            get {
                if gtpc214Builder_ != nil {
                    builderResult.gtpc214 = gtpc214Builder_.getMessage()
                }
                return builderResult.gtpc214
            }
            set (value) {
                builderResult.hasGtpc214 = value != nil
                builderResult.gtpc214 = value
            }
        }
        public var hasGtpc214:Bool {
            get {
                return builderResult.hasGtpc214
            }
        }
        fileprivate var gtpc214Builder_:Gtpc214.Builder! {
            didSet {
                builderResult.hasGtpc214 = true
            }
        }
        public func getGtpc214Builder() -> Gtpc214.Builder {
            if gtpc214Builder_ == nil {
                gtpc214Builder_ = Gtpc214.Builder()
                builderResult.gtpc214 = gtpc214Builder_.getMessage()
                if gtpc214 != nil {
                    try! gtpc214Builder_.mergeFrom(other: gtpc214)
                }
            }
            return gtpc214Builder_
        }
        @discardableResult
        public func setGtpc214(_ value:Gtpc214!) -> Gtpc21.Builder {
            self.gtpc214 = value
            return self
        }
        @discardableResult
        public func mergeGtpc214(value:Gtpc214) throws -> Gtpc21.Builder {
            if builderResult.hasGtpc214 {
                builderResult.gtpc214 = try Gtpc214.builderWithPrototype(prototype:builderResult.gtpc214).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.gtpc214 = value
            }
            builderResult.hasGtpc214 = true
            return self
        }
        @discardableResult
        public func clearGtpc214() -> Gtpc21.Builder {
            gtpc214Builder_ = nil
            builderResult.hasGtpc214 = false
            builderResult.gtpc214 = nil
            return self
        }
        public var gtpc216:Gtpc216! {
            get {
                if gtpc216Builder_ != nil {
                    builderResult.gtpc216 = gtpc216Builder_.getMessage()
                }
                return builderResult.gtpc216
            }
            set (value) {
                builderResult.hasGtpc216 = value != nil
                builderResult.gtpc216 = value
            }
        }
        public var hasGtpc216:Bool {
            get {
                return builderResult.hasGtpc216
            }
        }
        fileprivate var gtpc216Builder_:Gtpc216.Builder! {
            didSet {
                builderResult.hasGtpc216 = true
            }
        }
        public func getGtpc216Builder() -> Gtpc216.Builder {
            if gtpc216Builder_ == nil {
                gtpc216Builder_ = Gtpc216.Builder()
                builderResult.gtpc216 = gtpc216Builder_.getMessage()
                if gtpc216 != nil {
                    try! gtpc216Builder_.mergeFrom(other: gtpc216)
                }
            }
            return gtpc216Builder_
        }
        @discardableResult
        public func setGtpc216(_ value:Gtpc216!) -> Gtpc21.Builder {
            self.gtpc216 = value
            return self
        }
        @discardableResult
        public func mergeGtpc216(value:Gtpc216) throws -> Gtpc21.Builder {
            if builderResult.hasGtpc216 {
                builderResult.gtpc216 = try Gtpc216.builderWithPrototype(prototype:builderResult.gtpc216).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.gtpc216 = value
            }
            builderResult.hasGtpc216 = true
            return self
        }
        @discardableResult
        public func clearGtpc216() -> Gtpc21.Builder {
            gtpc216Builder_ = nil
            builderResult.hasGtpc216 = false
            builderResult.gtpc216 = nil
            return self
        }
        public var gtpc218:Gtpc218! {
            get {
                if gtpc218Builder_ != nil {
                    builderResult.gtpc218 = gtpc218Builder_.getMessage()
                }
                return builderResult.gtpc218
            }
            set (value) {
                builderResult.hasGtpc218 = value != nil
                builderResult.gtpc218 = value
            }
        }
        public var hasGtpc218:Bool {
            get {
                return builderResult.hasGtpc218
            }
        }
        fileprivate var gtpc218Builder_:Gtpc218.Builder! {
            didSet {
                builderResult.hasGtpc218 = true
            }
        }
        public func getGtpc218Builder() -> Gtpc218.Builder {
            if gtpc218Builder_ == nil {
                gtpc218Builder_ = Gtpc218.Builder()
                builderResult.gtpc218 = gtpc218Builder_.getMessage()
                if gtpc218 != nil {
                    try! gtpc218Builder_.mergeFrom(other: gtpc218)
                }
            }
            return gtpc218Builder_
        }
        @discardableResult
        public func setGtpc218(_ value:Gtpc218!) -> Gtpc21.Builder {
            self.gtpc218 = value
            return self
        }
        @discardableResult
        public func mergeGtpc218(value:Gtpc218) throws -> Gtpc21.Builder {
            if builderResult.hasGtpc218 {
                builderResult.gtpc218 = try Gtpc218.builderWithPrototype(prototype:builderResult.gtpc218).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.gtpc218 = value
            }
            builderResult.hasGtpc218 = true
            return self
        }
        @discardableResult
        public func clearGtpc218() -> Gtpc21.Builder {
            gtpc218Builder_ = nil
            builderResult.hasGtpc218 = false
            builderResult.gtpc218 = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Gtpc21.Builder {
            builderResult = Gtpc21()
            return self
        }
        override public func clone() throws -> Gtpc21.Builder {
            return try Gtpc21.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Gtpc21 {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Gtpc21 {
            let returnMe:Gtpc21 = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Gtpc21) throws -> Gtpc21.Builder {
            if other == Gtpc21() {
                return self
            }
            if other.hasF1 {
                f1 = other.f1
            }
            if (other.hasGtpc214) {
                try mergeGtpc214(value: other.gtpc214)
            }
            if (other.hasGtpc216) {
                try mergeGtpc216(value: other.gtpc216)
            }
            if (other.hasGtpc218) {
                try mergeGtpc218(value: other.gtpc218)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Gtpc21.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc21.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    f1 = try codedInputStream.readInt32()

                case 34:
                    let subBuilder:Gtpc214.Builder = Gtpc214.Builder()
                    if hasGtpc214 {
                        try subBuilder.mergeFrom(other: gtpc214)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    gtpc214 = subBuilder.buildPartial()

                case 50:
                    let subBuilder:Gtpc216.Builder = Gtpc216.Builder()
                    if hasGtpc216 {
                        try subBuilder.mergeFrom(other: gtpc216)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    gtpc216 = subBuilder.buildPartial()

                case 66:
                    let subBuilder:Gtpc218.Builder = Gtpc218.Builder()
                    if hasGtpc218 {
                        try subBuilder.mergeFrom(other: gtpc218)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    gtpc218 = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Gtpc21.Builder {
            let resultDecodedBuilder = Gtpc21.Builder()
            if let jsonValueF1 = jsonMap["f1"] as? Int {
                resultDecodedBuilder.f1 = Int32(jsonValueF1)
            } else if let jsonValueF1 = jsonMap["f1"] as? String {
                resultDecodedBuilder.f1 = Int32(jsonValueF1)!
            }
            if let jsonValueGtpc214 = jsonMap["gtpc214"] as? Dictionary<String,Any> {
                resultDecodedBuilder.gtpc214 = try Gtpc214.Builder.decodeToBuilder(jsonMap:jsonValueGtpc214).build()

            }
            if let jsonValueGtpc216 = jsonMap["gtpc216"] as? Dictionary<String,Any> {
                resultDecodedBuilder.gtpc216 = try Gtpc216.Builder.decodeToBuilder(jsonMap:jsonValueGtpc216).build()

            }
            if let jsonValueGtpc218 = jsonMap["gtpc218"] as? Dictionary<String,Any> {
                resultDecodedBuilder.gtpc218 = try Gtpc218.Builder.decodeToBuilder(jsonMap:jsonValueGtpc218).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Gtpc21.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Gtpc21.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class GameToPhoneCommand : GeneratedMessage {
    public typealias BuilderType = GameToPhoneCommand.Builder

    public static func == (lhs: GameToPhoneCommand, rhs: GameToPhoneCommand) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasSeqno == rhs.hasSeqno) && (!lhs.hasSeqno || lhs.seqno == rhs.seqno)
        fieldCheck = fieldCheck && (lhs.hasF2 == rhs.hasF2) && (!lhs.hasF2 || lhs.f2 == rhs.f2)
        fieldCheck = fieldCheck && (lhs.hasGtpc21 == rhs.hasGtpc21) && (!lhs.hasGtpc21 || lhs.gtpc21 == rhs.gtpc21)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var seqno:Int32! = nil
    public fileprivate(set) var hasSeqno:Bool = false

    public fileprivate(set) var f2:Int32! = nil
    public fileprivate(set) var hasF2:Bool = false

    public fileprivate(set) var gtpc21:Gtpc21!
    public fileprivate(set) var hasGtpc21:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasSeqno {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:seqno)
        }
        if hasF2 {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:f2)
        }
        if hasGtpc21 {
            try codedOutputStream.writeMessage(fieldNumber: 21, value:gtpc21)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasSeqno {
            serialize_size += seqno.computeInt32Size(fieldNumber: 1)
        }
        if hasF2 {
            serialize_size += f2.computeInt32Size(fieldNumber: 2)
        }
        if hasGtpc21 {
            if let varSizegtpc21 = gtpc21?.computeMessageSize(fieldNumber: 21) {
                serialize_size += varSizegtpc21
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> GameToPhoneCommand.Builder {
        return GameToPhoneCommand.classBuilder() as! GameToPhoneCommand.Builder
    }
    public func getBuilder() -> GameToPhoneCommand.Builder {
        return classBuilder() as! GameToPhoneCommand.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return GameToPhoneCommand.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return GameToPhoneCommand.Builder()
    }
    public func toBuilder() throws -> GameToPhoneCommand.Builder {
        return try GameToPhoneCommand.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:GameToPhoneCommand) throws -> GameToPhoneCommand.Builder {
        return try GameToPhoneCommand.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasSeqno {
            jsonMap["seqno"] = Int(seqno)
        }
        if hasF2 {
            jsonMap["f2"] = Int(f2)
        }
        if hasGtpc21 {
            jsonMap["gtpc21"] = try gtpc21.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GameToPhoneCommand {
        return try GameToPhoneCommand.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> GameToPhoneCommand {
        return try GameToPhoneCommand.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasSeqno {
            output += "\(indent) seqno: \(seqno) \n"
        }
        if hasF2 {
            output += "\(indent) f2: \(f2) \n"
        }
        if hasGtpc21 {
            output += "\(indent) gtpc21 {\n"
            if let outDescGtpc21 = gtpc21 {
                output += try outDescGtpc21.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSeqno {
                hashCode = (hashCode &* 31) &+ seqno.hashValue
            }
            if hasF2 {
                hashCode = (hashCode &* 31) &+ f2.hashValue
            }
            if hasGtpc21 {
                if let hashValuegtpc21 = gtpc21?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegtpc21
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "GameToPhoneCommand"
    }
    override public func className() -> String {
        return "GameToPhoneCommand"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:GameToPhoneCommand = GameToPhoneCommand()
        public func getMessage() -> GameToPhoneCommand {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var seqno:Int32 {
            get {
                return builderResult.seqno
            }
            set (value) {
                builderResult.hasSeqno = true
                builderResult.seqno = value
            }
        }
        public var hasSeqno:Bool {
            get {
                return builderResult.hasSeqno
            }
        }
        @discardableResult
        public func setSeqno(_ value:Int32) -> GameToPhoneCommand.Builder {
            self.seqno = value
            return self
        }
        @discardableResult
        public func clearSeqno() -> GameToPhoneCommand.Builder{
            builderResult.hasSeqno = false
            builderResult.seqno = nil
            return self
        }
        public var f2:Int32 {
            get {
                return builderResult.f2
            }
            set (value) {
                builderResult.hasF2 = true
                builderResult.f2 = value
            }
        }
        public var hasF2:Bool {
            get {
                return builderResult.hasF2
            }
        }
        @discardableResult
        public func setF2(_ value:Int32) -> GameToPhoneCommand.Builder {
            self.f2 = value
            return self
        }
        @discardableResult
        public func clearF2() -> GameToPhoneCommand.Builder{
            builderResult.hasF2 = false
            builderResult.f2 = nil
            return self
        }
        public var gtpc21:Gtpc21! {
            get {
                if gtpc21Builder_ != nil {
                    builderResult.gtpc21 = gtpc21Builder_.getMessage()
                }
                return builderResult.gtpc21
            }
            set (value) {
                builderResult.hasGtpc21 = value != nil
                builderResult.gtpc21 = value
            }
        }
        public var hasGtpc21:Bool {
            get {
                return builderResult.hasGtpc21
            }
        }
        fileprivate var gtpc21Builder_:Gtpc21.Builder! {
            didSet {
                builderResult.hasGtpc21 = true
            }
        }
        public func getGtpc21Builder() -> Gtpc21.Builder {
            if gtpc21Builder_ == nil {
                gtpc21Builder_ = Gtpc21.Builder()
                builderResult.gtpc21 = gtpc21Builder_.getMessage()
                if gtpc21 != nil {
                    try! gtpc21Builder_.mergeFrom(other: gtpc21)
                }
            }
            return gtpc21Builder_
        }
        @discardableResult
        public func setGtpc21(_ value:Gtpc21!) -> GameToPhoneCommand.Builder {
            self.gtpc21 = value
            return self
        }
        @discardableResult
        public func mergeGtpc21(value:Gtpc21) throws -> GameToPhoneCommand.Builder {
            if builderResult.hasGtpc21 {
                builderResult.gtpc21 = try Gtpc21.builderWithPrototype(prototype:builderResult.gtpc21).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.gtpc21 = value
            }
            builderResult.hasGtpc21 = true
            return self
        }
        @discardableResult
        public func clearGtpc21() -> GameToPhoneCommand.Builder {
            gtpc21Builder_ = nil
            builderResult.hasGtpc21 = false
            builderResult.gtpc21 = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> GameToPhoneCommand.Builder {
            builderResult = GameToPhoneCommand()
            return self
        }
        override public func clone() throws -> GameToPhoneCommand.Builder {
            return try GameToPhoneCommand.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> GameToPhoneCommand {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> GameToPhoneCommand {
            let returnMe:GameToPhoneCommand = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:GameToPhoneCommand) throws -> GameToPhoneCommand.Builder {
            if other == GameToPhoneCommand() {
                return self
            }
            if other.hasSeqno {
                seqno = other.seqno
            }
            if other.hasF2 {
                f2 = other.f2
            }
            if (other.hasGtpc21) {
                try mergeGtpc21(value: other.gtpc21)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GameToPhoneCommand.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GameToPhoneCommand.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    seqno = try codedInputStream.readInt32()

                case 16:
                    f2 = try codedInputStream.readInt32()

                case 170:
                    let subBuilder:Gtpc21.Builder = Gtpc21.Builder()
                    if hasGtpc21 {
                        try subBuilder.mergeFrom(other: gtpc21)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    gtpc21 = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GameToPhoneCommand.Builder {
            let resultDecodedBuilder = GameToPhoneCommand.Builder()
            if let jsonValueSeqno = jsonMap["seqno"] as? Int {
                resultDecodedBuilder.seqno = Int32(jsonValueSeqno)
            } else if let jsonValueSeqno = jsonMap["seqno"] as? String {
                resultDecodedBuilder.seqno = Int32(jsonValueSeqno)!
            }
            if let jsonValueF2 = jsonMap["f2"] as? Int {
                resultDecodedBuilder.f2 = Int32(jsonValueF2)
            } else if let jsonValueF2 = jsonMap["f2"] as? String {
                resultDecodedBuilder.f2 = Int32(jsonValueF2)!
            }
            if let jsonValueGtpc21 = jsonMap["gtpc21"] as? Dictionary<String,Any> {
                resultDecodedBuilder.gtpc21 = try Gtpc21.Builder.decodeToBuilder(jsonMap:jsonValueGtpc21).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> GameToPhoneCommand.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try GameToPhoneCommand.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class GameToPhone : GeneratedMessage {
    public typealias BuilderType = GameToPhone.Builder

    public static func == (lhs: GameToPhone, rhs: GameToPhone) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasF1 == rhs.hasF1) && (!lhs.hasF1 || lhs.f1 == rhs.f1)
        fieldCheck = fieldCheck && (lhs.hasF2 == rhs.hasF2) && (!lhs.hasF2 || lhs.f2 == rhs.f2)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasF4 == rhs.hasF4) && (!lhs.hasF4 || lhs.f4 == rhs.f4)
        fieldCheck = fieldCheck && (lhs.hasF6 == rhs.hasF6) && (!lhs.hasF6 || lhs.f6 == rhs.f6)
        fieldCheck = fieldCheck && (lhs.hasF7 == rhs.hasF7) && (!lhs.hasF7 || lhs.f7 == rhs.f7)
        fieldCheck = fieldCheck && (lhs.commands == rhs.commands)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var f1:Int32! = nil
    public fileprivate(set) var hasF1:Bool = false

    public fileprivate(set) var f2:Int32! = nil
    public fileprivate(set) var hasF2:Bool = false

    public fileprivate(set) var id:Int32! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var f4:Int32! = nil
    public fileprivate(set) var hasF4:Bool = false

    public fileprivate(set) var f6:Int32! = nil
    public fileprivate(set) var hasF6:Bool = false

    public fileprivate(set) var f7:Int32! = nil
    public fileprivate(set) var hasF7:Bool = false

    public fileprivate(set) var commands:Array<GameToPhoneCommand>  = Array<GameToPhoneCommand>()
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasF1 {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:f1)
        }
        if hasF2 {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:f2)
        }
        if hasId {
            try codedOutputStream.writeInt32(fieldNumber: 3, value:id)
        }
        if hasF4 {
            try codedOutputStream.writeInt32(fieldNumber: 4, value:f4)
        }
        if hasF6 {
            try codedOutputStream.writeInt32(fieldNumber: 6, value:f6)
        }
        if hasF7 {
            try codedOutputStream.writeInt32(fieldNumber: 7, value:f7)
        }
        for oneElementCommands in commands {
              try codedOutputStream.writeMessage(fieldNumber: 11, value:oneElementCommands)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasF1 {
            serialize_size += f1.computeInt32Size(fieldNumber: 1)
        }
        if hasF2 {
            serialize_size += f2.computeInt32Size(fieldNumber: 2)
        }
        if hasId {
            serialize_size += id.computeInt32Size(fieldNumber: 3)
        }
        if hasF4 {
            serialize_size += f4.computeInt32Size(fieldNumber: 4)
        }
        if hasF6 {
            serialize_size += f6.computeInt32Size(fieldNumber: 6)
        }
        if hasF7 {
            serialize_size += f7.computeInt32Size(fieldNumber: 7)
        }
        for oneElementCommands in commands {
            serialize_size += oneElementCommands.computeMessageSize(fieldNumber: 11)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> GameToPhone.Builder {
        return GameToPhone.classBuilder() as! GameToPhone.Builder
    }
    public func getBuilder() -> GameToPhone.Builder {
        return classBuilder() as! GameToPhone.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return GameToPhone.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return GameToPhone.Builder()
    }
    public func toBuilder() throws -> GameToPhone.Builder {
        return try GameToPhone.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:GameToPhone) throws -> GameToPhone.Builder {
        return try GameToPhone.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasF1 {
            jsonMap["f1"] = Int(f1)
        }
        if hasF2 {
            jsonMap["f2"] = Int(f2)
        }
        if hasId {
            jsonMap["id"] = Int(id)
        }
        if hasF4 {
            jsonMap["f4"] = Int(f4)
        }
        if hasF6 {
            jsonMap["f6"] = Int(f6)
        }
        if hasF7 {
            jsonMap["f7"] = Int(f7)
        }
        if !commands.isEmpty {
            var jsonArrayCommands:Array<Dictionary<String,Any>> = []
            for oneValueCommands in commands {
                let ecodedMessageCommands = try oneValueCommands.encode()
                jsonArrayCommands.append(ecodedMessageCommands)
            }
            jsonMap["commands"] = jsonArrayCommands
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GameToPhone {
        return try GameToPhone.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> GameToPhone {
        return try GameToPhone.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasF1 {
            output += "\(indent) f1: \(f1) \n"
        }
        if hasF2 {
            output += "\(indent) f2: \(f2) \n"
        }
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasF4 {
            output += "\(indent) f4: \(f4) \n"
        }
        if hasF6 {
            output += "\(indent) f6: \(f6) \n"
        }
        if hasF7 {
            output += "\(indent) f7: \(f7) \n"
        }
        var commandsElementIndex:Int = 0
        for oneElementCommands in commands {
            output += "\(indent) commands[\(commandsElementIndex)] {\n"
            output += try oneElementCommands.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            commandsElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasF1 {
                hashCode = (hashCode &* 31) &+ f1.hashValue
            }
            if hasF2 {
                hashCode = (hashCode &* 31) &+ f2.hashValue
            }
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasF4 {
                hashCode = (hashCode &* 31) &+ f4.hashValue
            }
            if hasF6 {
                hashCode = (hashCode &* 31) &+ f6.hashValue
            }
            if hasF7 {
                hashCode = (hashCode &* 31) &+ f7.hashValue
            }
            for oneElementCommands in commands {
                hashCode = (hashCode &* 31) &+ oneElementCommands.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "GameToPhone"
    }
    override public func className() -> String {
        return "GameToPhone"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:GameToPhone = GameToPhone()
        public func getMessage() -> GameToPhone {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var f1:Int32 {
            get {
                return builderResult.f1
            }
            set (value) {
                builderResult.hasF1 = true
                builderResult.f1 = value
            }
        }
        public var hasF1:Bool {
            get {
                return builderResult.hasF1
            }
        }
        @discardableResult
        public func setF1(_ value:Int32) -> GameToPhone.Builder {
            self.f1 = value
            return self
        }
        @discardableResult
        public func clearF1() -> GameToPhone.Builder{
            builderResult.hasF1 = false
            builderResult.f1 = nil
            return self
        }
        public var f2:Int32 {
            get {
                return builderResult.f2
            }
            set (value) {
                builderResult.hasF2 = true
                builderResult.f2 = value
            }
        }
        public var hasF2:Bool {
            get {
                return builderResult.hasF2
            }
        }
        @discardableResult
        public func setF2(_ value:Int32) -> GameToPhone.Builder {
            self.f2 = value
            return self
        }
        @discardableResult
        public func clearF2() -> GameToPhone.Builder{
            builderResult.hasF2 = false
            builderResult.f2 = nil
            return self
        }
        public var id:Int32 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int32) -> GameToPhone.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> GameToPhone.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var f4:Int32 {
            get {
                return builderResult.f4
            }
            set (value) {
                builderResult.hasF4 = true
                builderResult.f4 = value
            }
        }
        public var hasF4:Bool {
            get {
                return builderResult.hasF4
            }
        }
        @discardableResult
        public func setF4(_ value:Int32) -> GameToPhone.Builder {
            self.f4 = value
            return self
        }
        @discardableResult
        public func clearF4() -> GameToPhone.Builder{
            builderResult.hasF4 = false
            builderResult.f4 = nil
            return self
        }
        public var f6:Int32 {
            get {
                return builderResult.f6
            }
            set (value) {
                builderResult.hasF6 = true
                builderResult.f6 = value
            }
        }
        public var hasF6:Bool {
            get {
                return builderResult.hasF6
            }
        }
        @discardableResult
        public func setF6(_ value:Int32) -> GameToPhone.Builder {
            self.f6 = value
            return self
        }
        @discardableResult
        public func clearF6() -> GameToPhone.Builder{
            builderResult.hasF6 = false
            builderResult.f6 = nil
            return self
        }
        public var f7:Int32 {
            get {
                return builderResult.f7
            }
            set (value) {
                builderResult.hasF7 = true
                builderResult.f7 = value
            }
        }
        public var hasF7:Bool {
            get {
                return builderResult.hasF7
            }
        }
        @discardableResult
        public func setF7(_ value:Int32) -> GameToPhone.Builder {
            self.f7 = value
            return self
        }
        @discardableResult
        public func clearF7() -> GameToPhone.Builder{
            builderResult.hasF7 = false
            builderResult.f7 = nil
            return self
        }
        public var commands:Array<GameToPhoneCommand> {
            get {
                return builderResult.commands
            }
            set (value) {
                builderResult.commands = value
            }
        }
        @discardableResult
        public func setCommands(_ value:Array<GameToPhoneCommand>) -> GameToPhone.Builder {
            self.commands = value
            return self
        }
        @discardableResult
        public func clearCommands() -> GameToPhone.Builder {
            builderResult.commands.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> GameToPhone.Builder {
            builderResult = GameToPhone()
            return self
        }
        override public func clone() throws -> GameToPhone.Builder {
            return try GameToPhone.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> GameToPhone {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> GameToPhone {
            let returnMe:GameToPhone = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:GameToPhone) throws -> GameToPhone.Builder {
            if other == GameToPhone() {
                return self
            }
            if other.hasF1 {
                f1 = other.f1
            }
            if other.hasF2 {
                f2 = other.f2
            }
            if other.hasId {
                id = other.id
            }
            if other.hasF4 {
                f4 = other.f4
            }
            if other.hasF6 {
                f6 = other.f6
            }
            if other.hasF7 {
                f7 = other.f7
            }
            if !other.commands.isEmpty  {
                 builderResult.commands += other.commands
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GameToPhone.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GameToPhone.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    f1 = try codedInputStream.readInt32()

                case 16:
                    f2 = try codedInputStream.readInt32()

                case 24:
                    id = try codedInputStream.readInt32()

                case 32:
                    f4 = try codedInputStream.readInt32()

                case 48:
                    f6 = try codedInputStream.readInt32()

                case 56:
                    f7 = try codedInputStream.readInt32()

                case 90:
                    let subBuilder = GameToPhoneCommand.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    commands.append(subBuilder.buildPartial())

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GameToPhone.Builder {
            let resultDecodedBuilder = GameToPhone.Builder()
            if let jsonValueF1 = jsonMap["f1"] as? Int {
                resultDecodedBuilder.f1 = Int32(jsonValueF1)
            } else if let jsonValueF1 = jsonMap["f1"] as? String {
                resultDecodedBuilder.f1 = Int32(jsonValueF1)!
            }
            if let jsonValueF2 = jsonMap["f2"] as? Int {
                resultDecodedBuilder.f2 = Int32(jsonValueF2)
            } else if let jsonValueF2 = jsonMap["f2"] as? String {
                resultDecodedBuilder.f2 = Int32(jsonValueF2)!
            }
            if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int32(jsonValueId)
            } else if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int32(jsonValueId)!
            }
            if let jsonValueF4 = jsonMap["f4"] as? Int {
                resultDecodedBuilder.f4 = Int32(jsonValueF4)
            } else if let jsonValueF4 = jsonMap["f4"] as? String {
                resultDecodedBuilder.f4 = Int32(jsonValueF4)!
            }
            if let jsonValueF6 = jsonMap["f6"] as? Int {
                resultDecodedBuilder.f6 = Int32(jsonValueF6)
            } else if let jsonValueF6 = jsonMap["f6"] as? String {
                resultDecodedBuilder.f6 = Int32(jsonValueF6)!
            }
            if let jsonValueF7 = jsonMap["f7"] as? Int {
                resultDecodedBuilder.f7 = Int32(jsonValueF7)
            } else if let jsonValueF7 = jsonMap["f7"] as? String {
                resultDecodedBuilder.f7 = Int32(jsonValueF7)!
            }
            if let jsonValueCommands = jsonMap["commands"] as? Array<Dictionary<String,Any>> {
                var jsonArrayCommands:Array<GameToPhoneCommand> = []
                for oneValueCommands in jsonValueCommands {
                    let messageFromStringCommands = try GameToPhoneCommand.Builder.decodeToBuilder(jsonMap:oneValueCommands).build()

                    jsonArrayCommands.append(messageFromStringCommands)
                }
                resultDecodedBuilder.commands = jsonArrayCommands
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> GameToPhone.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try GameToPhone.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class ZmlclientInfo : GeneratedMessage {
    public typealias BuilderType = ZmlclientInfo.Builder

    public static func == (lhs: ZmlclientInfo, rhs: ZmlclientInfo) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasAppVersion == rhs.hasAppVersion) && (!lhs.hasAppVersion || lhs.appVersion == rhs.appVersion)
        fieldCheck = fieldCheck && (lhs.hasSystemOsversion == rhs.hasSystemOsversion) && (!lhs.hasSystemOsversion || lhs.systemOsversion == rhs.systemOsversion)
        fieldCheck = fieldCheck && (lhs.hasSystemOs == rhs.hasSystemOs) && (!lhs.hasSystemOs || lhs.systemOs == rhs.systemOs)
        fieldCheck = fieldCheck && (lhs.hasSystemHardware == rhs.hasSystemHardware) && (!lhs.hasSystemHardware || lhs.systemHardware == rhs.systemHardware)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var appVersion:String! = nil
    public fileprivate(set) var hasAppVersion:Bool = false

    public fileprivate(set) var systemOsversion:String! = nil
    public fileprivate(set) var hasSystemOsversion:Bool = false

    public fileprivate(set) var systemOs:String! = nil
    public fileprivate(set) var hasSystemOs:Bool = false

    public fileprivate(set) var systemHardware:String! = nil
    public fileprivate(set) var hasSystemHardware:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasAppVersion {
            try codedOutputStream.writeString(fieldNumber: 1, value:appVersion)
        }
        if hasSystemOsversion {
            try codedOutputStream.writeString(fieldNumber: 2, value:systemOsversion)
        }
        if hasSystemOs {
            try codedOutputStream.writeString(fieldNumber: 3, value:systemOs)
        }
        if hasSystemHardware {
            try codedOutputStream.writeString(fieldNumber: 4, value:systemHardware)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasAppVersion {
            serialize_size += appVersion.computeStringSize(fieldNumber: 1)
        }
        if hasSystemOsversion {
            serialize_size += systemOsversion.computeStringSize(fieldNumber: 2)
        }
        if hasSystemOs {
            serialize_size += systemOs.computeStringSize(fieldNumber: 3)
        }
        if hasSystemHardware {
            serialize_size += systemHardware.computeStringSize(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> ZmlclientInfo.Builder {
        return ZmlclientInfo.classBuilder() as! ZmlclientInfo.Builder
    }
    public func getBuilder() -> ZmlclientInfo.Builder {
        return classBuilder() as! ZmlclientInfo.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ZmlclientInfo.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ZmlclientInfo.Builder()
    }
    public func toBuilder() throws -> ZmlclientInfo.Builder {
        return try ZmlclientInfo.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:ZmlclientInfo) throws -> ZmlclientInfo.Builder {
        return try ZmlclientInfo.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasAppVersion {
            jsonMap["appVersion"] = appVersion
        }
        if hasSystemOsversion {
            jsonMap["systemOSVersion"] = systemOsversion
        }
        if hasSystemOs {
            jsonMap["systemOS"] = systemOs
        }
        if hasSystemHardware {
            jsonMap["systemHardware"] = systemHardware
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ZmlclientInfo {
        return try ZmlclientInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> ZmlclientInfo {
        return try ZmlclientInfo.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasAppVersion {
            output += "\(indent) appVersion: \(appVersion) \n"
        }
        if hasSystemOsversion {
            output += "\(indent) systemOsversion: \(systemOsversion) \n"
        }
        if hasSystemOs {
            output += "\(indent) systemOs: \(systemOs) \n"
        }
        if hasSystemHardware {
            output += "\(indent) systemHardware: \(systemHardware) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasAppVersion {
                hashCode = (hashCode &* 31) &+ appVersion.hashValue
            }
            if hasSystemOsversion {
                hashCode = (hashCode &* 31) &+ systemOsversion.hashValue
            }
            if hasSystemOs {
                hashCode = (hashCode &* 31) &+ systemOs.hashValue
            }
            if hasSystemHardware {
                hashCode = (hashCode &* 31) &+ systemHardware.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ZmlclientInfo"
    }
    override public func className() -> String {
        return "ZmlclientInfo"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:ZmlclientInfo = ZmlclientInfo()
        public func getMessage() -> ZmlclientInfo {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var appVersion:String {
            get {
                return builderResult.appVersion
            }
            set (value) {
                builderResult.hasAppVersion = true
                builderResult.appVersion = value
            }
        }
        public var hasAppVersion:Bool {
            get {
                return builderResult.hasAppVersion
            }
        }
        @discardableResult
        public func setAppVersion(_ value:String) -> ZmlclientInfo.Builder {
            self.appVersion = value
            return self
        }
        @discardableResult
        public func clearAppVersion() -> ZmlclientInfo.Builder{
            builderResult.hasAppVersion = false
            builderResult.appVersion = nil
            return self
        }
        public var systemOsversion:String {
            get {
                return builderResult.systemOsversion
            }
            set (value) {
                builderResult.hasSystemOsversion = true
                builderResult.systemOsversion = value
            }
        }
        public var hasSystemOsversion:Bool {
            get {
                return builderResult.hasSystemOsversion
            }
        }
        @discardableResult
        public func setSystemOsversion(_ value:String) -> ZmlclientInfo.Builder {
            self.systemOsversion = value
            return self
        }
        @discardableResult
        public func clearSystemOsversion() -> ZmlclientInfo.Builder{
            builderResult.hasSystemOsversion = false
            builderResult.systemOsversion = nil
            return self
        }
        public var systemOs:String {
            get {
                return builderResult.systemOs
            }
            set (value) {
                builderResult.hasSystemOs = true
                builderResult.systemOs = value
            }
        }
        public var hasSystemOs:Bool {
            get {
                return builderResult.hasSystemOs
            }
        }
        @discardableResult
        public func setSystemOs(_ value:String) -> ZmlclientInfo.Builder {
            self.systemOs = value
            return self
        }
        @discardableResult
        public func clearSystemOs() -> ZmlclientInfo.Builder{
            builderResult.hasSystemOs = false
            builderResult.systemOs = nil
            return self
        }
        public var systemHardware:String {
            get {
                return builderResult.systemHardware
            }
            set (value) {
                builderResult.hasSystemHardware = true
                builderResult.systemHardware = value
            }
        }
        public var hasSystemHardware:Bool {
            get {
                return builderResult.hasSystemHardware
            }
        }
        @discardableResult
        public func setSystemHardware(_ value:String) -> ZmlclientInfo.Builder {
            self.systemHardware = value
            return self
        }
        @discardableResult
        public func clearSystemHardware() -> ZmlclientInfo.Builder{
            builderResult.hasSystemHardware = false
            builderResult.systemHardware = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> ZmlclientInfo.Builder {
            builderResult = ZmlclientInfo()
            return self
        }
        override public func clone() throws -> ZmlclientInfo.Builder {
            return try ZmlclientInfo.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> ZmlclientInfo {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> ZmlclientInfo {
            let returnMe:ZmlclientInfo = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:ZmlclientInfo) throws -> ZmlclientInfo.Builder {
            if other == ZmlclientInfo() {
                return self
            }
            if other.hasAppVersion {
                appVersion = other.appVersion
            }
            if other.hasSystemOsversion {
                systemOsversion = other.systemOsversion
            }
            if other.hasSystemOs {
                systemOs = other.systemOs
            }
            if other.hasSystemHardware {
                systemHardware = other.systemHardware
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ZmlclientInfo.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ZmlclientInfo.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    appVersion = try codedInputStream.readString()

                case 18:
                    systemOsversion = try codedInputStream.readString()

                case 26:
                    systemOs = try codedInputStream.readString()

                case 34:
                    systemHardware = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ZmlclientInfo.Builder {
            let resultDecodedBuilder = ZmlclientInfo.Builder()
            if let jsonValueAppVersion = jsonMap["appVersion"] as? String {
                resultDecodedBuilder.appVersion = jsonValueAppVersion
            }
            if let jsonValueSystemOsversion = jsonMap["systemOSVersion"] as? String {
                resultDecodedBuilder.systemOsversion = jsonValueSystemOsversion
            }
            if let jsonValueSystemOs = jsonMap["systemOS"] as? String {
                resultDecodedBuilder.systemOs = jsonValueSystemOs
            }
            if let jsonValueSystemHardware = jsonMap["systemHardware"] as? String {
                resultDecodedBuilder.systemHardware = jsonValueSystemHardware
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> ZmlclientInfo.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try ZmlclientInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class ZmlclientCapabilities : GeneratedMessage {
    public typealias BuilderType = ZmlclientCapabilities.Builder

    public static func == (lhs: ZmlclientCapabilities, rhs: ZmlclientCapabilities) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasF1 == rhs.hasF1) && (!lhs.hasF1 || lhs.f1 == rhs.f1)
        fieldCheck = fieldCheck && (lhs.hasInfo == rhs.hasInfo) && (!lhs.hasInfo || lhs.info == rhs.info)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var f1:Int32! = nil
    public fileprivate(set) var hasF1:Bool = false

    public fileprivate(set) var info:ZmlclientInfo!
    public fileprivate(set) var hasInfo:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasF1 {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:f1)
        }
        if hasInfo {
            try codedOutputStream.writeMessage(fieldNumber: 5, value:info)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasF1 {
            serialize_size += f1.computeInt32Size(fieldNumber: 1)
        }
        if hasInfo {
            if let varSizeinfo = info?.computeMessageSize(fieldNumber: 5) {
                serialize_size += varSizeinfo
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> ZmlclientCapabilities.Builder {
        return ZmlclientCapabilities.classBuilder() as! ZmlclientCapabilities.Builder
    }
    public func getBuilder() -> ZmlclientCapabilities.Builder {
        return classBuilder() as! ZmlclientCapabilities.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ZmlclientCapabilities.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ZmlclientCapabilities.Builder()
    }
    public func toBuilder() throws -> ZmlclientCapabilities.Builder {
        return try ZmlclientCapabilities.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:ZmlclientCapabilities) throws -> ZmlclientCapabilities.Builder {
        return try ZmlclientCapabilities.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasF1 {
            jsonMap["f1"] = Int(f1)
        }
        if hasInfo {
            jsonMap["info"] = try info.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ZmlclientCapabilities {
        return try ZmlclientCapabilities.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> ZmlclientCapabilities {
        return try ZmlclientCapabilities.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasF1 {
            output += "\(indent) f1: \(f1) \n"
        }
        if hasInfo {
            output += "\(indent) info {\n"
            if let outDescInfo = info {
                output += try outDescInfo.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasF1 {
                hashCode = (hashCode &* 31) &+ f1.hashValue
            }
            if hasInfo {
                if let hashValueinfo = info?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueinfo
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ZmlclientCapabilities"
    }
    override public func className() -> String {
        return "ZmlclientCapabilities"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:ZmlclientCapabilities = ZmlclientCapabilities()
        public func getMessage() -> ZmlclientCapabilities {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var f1:Int32 {
            get {
                return builderResult.f1
            }
            set (value) {
                builderResult.hasF1 = true
                builderResult.f1 = value
            }
        }
        public var hasF1:Bool {
            get {
                return builderResult.hasF1
            }
        }
        @discardableResult
        public func setF1(_ value:Int32) -> ZmlclientCapabilities.Builder {
            self.f1 = value
            return self
        }
        @discardableResult
        public func clearF1() -> ZmlclientCapabilities.Builder{
            builderResult.hasF1 = false
            builderResult.f1 = nil
            return self
        }
        public var info:ZmlclientInfo! {
            get {
                if infoBuilder_ != nil {
                    builderResult.info = infoBuilder_.getMessage()
                }
                return builderResult.info
            }
            set (value) {
                builderResult.hasInfo = value != nil
                builderResult.info = value
            }
        }
        public var hasInfo:Bool {
            get {
                return builderResult.hasInfo
            }
        }
        fileprivate var infoBuilder_:ZmlclientInfo.Builder! {
            didSet {
                builderResult.hasInfo = true
            }
        }
        public func getInfoBuilder() -> ZmlclientInfo.Builder {
            if infoBuilder_ == nil {
                infoBuilder_ = ZmlclientInfo.Builder()
                builderResult.info = infoBuilder_.getMessage()
                if info != nil {
                    try! infoBuilder_.mergeFrom(other: info)
                }
            }
            return infoBuilder_
        }
        @discardableResult
        public func setInfo(_ value:ZmlclientInfo!) -> ZmlclientCapabilities.Builder {
            self.info = value
            return self
        }
        @discardableResult
        public func mergeInfo(value:ZmlclientInfo) throws -> ZmlclientCapabilities.Builder {
            if builderResult.hasInfo {
                builderResult.info = try ZmlclientInfo.builderWithPrototype(prototype:builderResult.info).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.info = value
            }
            builderResult.hasInfo = true
            return self
        }
        @discardableResult
        public func clearInfo() -> ZmlclientCapabilities.Builder {
            infoBuilder_ = nil
            builderResult.hasInfo = false
            builderResult.info = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> ZmlclientCapabilities.Builder {
            builderResult = ZmlclientCapabilities()
            return self
        }
        override public func clone() throws -> ZmlclientCapabilities.Builder {
            return try ZmlclientCapabilities.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> ZmlclientCapabilities {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> ZmlclientCapabilities {
            let returnMe:ZmlclientCapabilities = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:ZmlclientCapabilities) throws -> ZmlclientCapabilities.Builder {
            if other == ZmlclientCapabilities() {
                return self
            }
            if other.hasF1 {
                f1 = other.f1
            }
            if (other.hasInfo) {
                try mergeInfo(value: other.info)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ZmlclientCapabilities.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ZmlclientCapabilities.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    f1 = try codedInputStream.readInt32()

                case 42:
                    let subBuilder:ZmlclientInfo.Builder = ZmlclientInfo.Builder()
                    if hasInfo {
                        try subBuilder.mergeFrom(other: info)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    info = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ZmlclientCapabilities.Builder {
            let resultDecodedBuilder = ZmlclientCapabilities.Builder()
            if let jsonValueF1 = jsonMap["f1"] as? Int {
                resultDecodedBuilder.f1 = Int32(jsonValueF1)
            } else if let jsonValueF1 = jsonMap["f1"] as? String {
                resultDecodedBuilder.f1 = Int32(jsonValueF1)!
            }
            if let jsonValueInfo = jsonMap["info"] as? Dictionary<String,Any> {
                resultDecodedBuilder.info = try ZmlclientInfo.Builder.decodeToBuilder(jsonMap:jsonValueInfo).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> ZmlclientCapabilities.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try ZmlclientCapabilities.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class PhoneToGameCommand : GeneratedMessage {
    public typealias BuilderType = PhoneToGameCommand.Builder

    public static func == (lhs: PhoneToGameCommand, rhs: PhoneToGameCommand) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasSeqno == rhs.hasSeqno) && (!lhs.hasSeqno || lhs.seqno == rhs.seqno)
        fieldCheck = fieldCheck && (lhs.hasCommand == rhs.hasCommand) && (!lhs.hasCommand || lhs.command == rhs.command)
        fieldCheck = fieldCheck && (lhs.hasSubject == rhs.hasSubject) && (!lhs.hasSubject || lhs.subject == rhs.subject)
        fieldCheck = fieldCheck && (lhs.hasF5 == rhs.hasF5) && (!lhs.hasF5 || lhs.f5 == rhs.f5)
        fieldCheck = fieldCheck && (lhs.hasF6 == rhs.hasF6) && (!lhs.hasF6 || lhs.f6 == rhs.f6)
        fieldCheck = fieldCheck && (lhs.hasF7 == rhs.hasF7) && (!lhs.hasF7 || lhs.f7 == rhs.f7)
        fieldCheck = fieldCheck && (lhs.hasPlayerId == rhs.hasPlayerId) && (!lhs.hasPlayerId || lhs.playerId == rhs.playerId)
        fieldCheck = fieldCheck && (lhs.hasCapabilities == rhs.hasCapabilities) && (!lhs.hasCapabilities || lhs.capabilities == rhs.capabilities)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var seqno:Int32! = nil
    public fileprivate(set) var hasSeqno:Bool = false

    public fileprivate(set) var command:Int32! = nil
    public fileprivate(set) var hasCommand:Bool = false

    public fileprivate(set) var subject:Int32! = nil
    public fileprivate(set) var hasSubject:Bool = false

    public fileprivate(set) var f5:Int32! = nil
    public fileprivate(set) var hasF5:Bool = false

    public fileprivate(set) var f6:String! = nil
    public fileprivate(set) var hasF6:Bool = false

    public fileprivate(set) var f7:Int32! = nil
    public fileprivate(set) var hasF7:Bool = false

    public fileprivate(set) var playerId:Int32! = nil
    public fileprivate(set) var hasPlayerId:Bool = false

    public fileprivate(set) var capabilities:ZmlclientCapabilities!
    public fileprivate(set) var hasCapabilities:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasSeqno {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:seqno)
        }
        if hasCommand {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:command)
        }
        if hasSubject {
            try codedOutputStream.writeInt32(fieldNumber: 3, value:subject)
        }
        if hasF5 {
            try codedOutputStream.writeInt32(fieldNumber: 5, value:f5)
        }
        if hasF6 {
            try codedOutputStream.writeString(fieldNumber: 6, value:f6)
        }
        if hasF7 {
            try codedOutputStream.writeInt32(fieldNumber: 7, value:f7)
        }
        if hasPlayerId {
            try codedOutputStream.writeInt32(fieldNumber: 19, value:playerId)
        }
        if hasCapabilities {
            try codedOutputStream.writeMessage(fieldNumber: 21, value:capabilities)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasSeqno {
            serialize_size += seqno.computeInt32Size(fieldNumber: 1)
        }
        if hasCommand {
            serialize_size += command.computeInt32Size(fieldNumber: 2)
        }
        if hasSubject {
            serialize_size += subject.computeInt32Size(fieldNumber: 3)
        }
        if hasF5 {
            serialize_size += f5.computeInt32Size(fieldNumber: 5)
        }
        if hasF6 {
            serialize_size += f6.computeStringSize(fieldNumber: 6)
        }
        if hasF7 {
            serialize_size += f7.computeInt32Size(fieldNumber: 7)
        }
        if hasPlayerId {
            serialize_size += playerId.computeInt32Size(fieldNumber: 19)
        }
        if hasCapabilities {
            if let varSizecapabilities = capabilities?.computeMessageSize(fieldNumber: 21) {
                serialize_size += varSizecapabilities
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> PhoneToGameCommand.Builder {
        return PhoneToGameCommand.classBuilder() as! PhoneToGameCommand.Builder
    }
    public func getBuilder() -> PhoneToGameCommand.Builder {
        return classBuilder() as! PhoneToGameCommand.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PhoneToGameCommand.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PhoneToGameCommand.Builder()
    }
    public func toBuilder() throws -> PhoneToGameCommand.Builder {
        return try PhoneToGameCommand.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:PhoneToGameCommand) throws -> PhoneToGameCommand.Builder {
        return try PhoneToGameCommand.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasSeqno {
            jsonMap["seqno"] = Int(seqno)
        }
        if hasCommand {
            jsonMap["command"] = Int(command)
        }
        if hasSubject {
            jsonMap["subject"] = Int(subject)
        }
        if hasF5 {
            jsonMap["f5"] = Int(f5)
        }
        if hasF6 {
            jsonMap["f6"] = f6
        }
        if hasF7 {
            jsonMap["f7"] = Int(f7)
        }
        if hasPlayerId {
            jsonMap["playerId"] = Int(playerId)
        }
        if hasCapabilities {
            jsonMap["capabilities"] = try capabilities.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> PhoneToGameCommand {
        return try PhoneToGameCommand.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> PhoneToGameCommand {
        return try PhoneToGameCommand.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasSeqno {
            output += "\(indent) seqno: \(seqno) \n"
        }
        if hasCommand {
            output += "\(indent) command: \(command) \n"
        }
        if hasSubject {
            output += "\(indent) subject: \(subject) \n"
        }
        if hasF5 {
            output += "\(indent) f5: \(f5) \n"
        }
        if hasF6 {
            output += "\(indent) f6: \(f6) \n"
        }
        if hasF7 {
            output += "\(indent) f7: \(f7) \n"
        }
        if hasPlayerId {
            output += "\(indent) playerId: \(playerId) \n"
        }
        if hasCapabilities {
            output += "\(indent) capabilities {\n"
            if let outDescCapabilities = capabilities {
                output += try outDescCapabilities.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSeqno {
                hashCode = (hashCode &* 31) &+ seqno.hashValue
            }
            if hasCommand {
                hashCode = (hashCode &* 31) &+ command.hashValue
            }
            if hasSubject {
                hashCode = (hashCode &* 31) &+ subject.hashValue
            }
            if hasF5 {
                hashCode = (hashCode &* 31) &+ f5.hashValue
            }
            if hasF6 {
                hashCode = (hashCode &* 31) &+ f6.hashValue
            }
            if hasF7 {
                hashCode = (hashCode &* 31) &+ f7.hashValue
            }
            if hasPlayerId {
                hashCode = (hashCode &* 31) &+ playerId.hashValue
            }
            if hasCapabilities {
                if let hashValuecapabilities = capabilities?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecapabilities
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "PhoneToGameCommand"
    }
    override public func className() -> String {
        return "PhoneToGameCommand"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PhoneToGameCommand = PhoneToGameCommand()
        public func getMessage() -> PhoneToGameCommand {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var seqno:Int32 {
            get {
                return builderResult.seqno
            }
            set (value) {
                builderResult.hasSeqno = true
                builderResult.seqno = value
            }
        }
        public var hasSeqno:Bool {
            get {
                return builderResult.hasSeqno
            }
        }
        @discardableResult
        public func setSeqno(_ value:Int32) -> PhoneToGameCommand.Builder {
            self.seqno = value
            return self
        }
        @discardableResult
        public func clearSeqno() -> PhoneToGameCommand.Builder{
            builderResult.hasSeqno = false
            builderResult.seqno = nil
            return self
        }
        public var command:Int32 {
            get {
                return builderResult.command
            }
            set (value) {
                builderResult.hasCommand = true
                builderResult.command = value
            }
        }
        public var hasCommand:Bool {
            get {
                return builderResult.hasCommand
            }
        }
        @discardableResult
        public func setCommand(_ value:Int32) -> PhoneToGameCommand.Builder {
            self.command = value
            return self
        }
        @discardableResult
        public func clearCommand() -> PhoneToGameCommand.Builder{
            builderResult.hasCommand = false
            builderResult.command = nil
            return self
        }
        public var subject:Int32 {
            get {
                return builderResult.subject
            }
            set (value) {
                builderResult.hasSubject = true
                builderResult.subject = value
            }
        }
        public var hasSubject:Bool {
            get {
                return builderResult.hasSubject
            }
        }
        @discardableResult
        public func setSubject(_ value:Int32) -> PhoneToGameCommand.Builder {
            self.subject = value
            return self
        }
        @discardableResult
        public func clearSubject() -> PhoneToGameCommand.Builder{
            builderResult.hasSubject = false
            builderResult.subject = nil
            return self
        }
        public var f5:Int32 {
            get {
                return builderResult.f5
            }
            set (value) {
                builderResult.hasF5 = true
                builderResult.f5 = value
            }
        }
        public var hasF5:Bool {
            get {
                return builderResult.hasF5
            }
        }
        @discardableResult
        public func setF5(_ value:Int32) -> PhoneToGameCommand.Builder {
            self.f5 = value
            return self
        }
        @discardableResult
        public func clearF5() -> PhoneToGameCommand.Builder{
            builderResult.hasF5 = false
            builderResult.f5 = nil
            return self
        }
        public var f6:String {
            get {
                return builderResult.f6
            }
            set (value) {
                builderResult.hasF6 = true
                builderResult.f6 = value
            }
        }
        public var hasF6:Bool {
            get {
                return builderResult.hasF6
            }
        }
        @discardableResult
        public func setF6(_ value:String) -> PhoneToGameCommand.Builder {
            self.f6 = value
            return self
        }
        @discardableResult
        public func clearF6() -> PhoneToGameCommand.Builder{
            builderResult.hasF6 = false
            builderResult.f6 = nil
            return self
        }
        public var f7:Int32 {
            get {
                return builderResult.f7
            }
            set (value) {
                builderResult.hasF7 = true
                builderResult.f7 = value
            }
        }
        public var hasF7:Bool {
            get {
                return builderResult.hasF7
            }
        }
        @discardableResult
        public func setF7(_ value:Int32) -> PhoneToGameCommand.Builder {
            self.f7 = value
            return self
        }
        @discardableResult
        public func clearF7() -> PhoneToGameCommand.Builder{
            builderResult.hasF7 = false
            builderResult.f7 = nil
            return self
        }
        public var playerId:Int32 {
            get {
                return builderResult.playerId
            }
            set (value) {
                builderResult.hasPlayerId = true
                builderResult.playerId = value
            }
        }
        public var hasPlayerId:Bool {
            get {
                return builderResult.hasPlayerId
            }
        }
        @discardableResult
        public func setPlayerId(_ value:Int32) -> PhoneToGameCommand.Builder {
            self.playerId = value
            return self
        }
        @discardableResult
        public func clearPlayerId() -> PhoneToGameCommand.Builder{
            builderResult.hasPlayerId = false
            builderResult.playerId = nil
            return self
        }
        public var capabilities:ZmlclientCapabilities! {
            get {
                if capabilitiesBuilder_ != nil {
                    builderResult.capabilities = capabilitiesBuilder_.getMessage()
                }
                return builderResult.capabilities
            }
            set (value) {
                builderResult.hasCapabilities = value != nil
                builderResult.capabilities = value
            }
        }
        public var hasCapabilities:Bool {
            get {
                return builderResult.hasCapabilities
            }
        }
        fileprivate var capabilitiesBuilder_:ZmlclientCapabilities.Builder! {
            didSet {
                builderResult.hasCapabilities = true
            }
        }
        public func getCapabilitiesBuilder() -> ZmlclientCapabilities.Builder {
            if capabilitiesBuilder_ == nil {
                capabilitiesBuilder_ = ZmlclientCapabilities.Builder()
                builderResult.capabilities = capabilitiesBuilder_.getMessage()
                if capabilities != nil {
                    try! capabilitiesBuilder_.mergeFrom(other: capabilities)
                }
            }
            return capabilitiesBuilder_
        }
        @discardableResult
        public func setCapabilities(_ value:ZmlclientCapabilities!) -> PhoneToGameCommand.Builder {
            self.capabilities = value
            return self
        }
        @discardableResult
        public func mergeCapabilities(value:ZmlclientCapabilities) throws -> PhoneToGameCommand.Builder {
            if builderResult.hasCapabilities {
                builderResult.capabilities = try ZmlclientCapabilities.builderWithPrototype(prototype:builderResult.capabilities).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.capabilities = value
            }
            builderResult.hasCapabilities = true
            return self
        }
        @discardableResult
        public func clearCapabilities() -> PhoneToGameCommand.Builder {
            capabilitiesBuilder_ = nil
            builderResult.hasCapabilities = false
            builderResult.capabilities = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> PhoneToGameCommand.Builder {
            builderResult = PhoneToGameCommand()
            return self
        }
        override public func clone() throws -> PhoneToGameCommand.Builder {
            return try PhoneToGameCommand.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> PhoneToGameCommand {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> PhoneToGameCommand {
            let returnMe:PhoneToGameCommand = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:PhoneToGameCommand) throws -> PhoneToGameCommand.Builder {
            if other == PhoneToGameCommand() {
                return self
            }
            if other.hasSeqno {
                seqno = other.seqno
            }
            if other.hasCommand {
                command = other.command
            }
            if other.hasSubject {
                subject = other.subject
            }
            if other.hasF5 {
                f5 = other.f5
            }
            if other.hasF6 {
                f6 = other.f6
            }
            if other.hasF7 {
                f7 = other.f7
            }
            if other.hasPlayerId {
                playerId = other.playerId
            }
            if (other.hasCapabilities) {
                try mergeCapabilities(value: other.capabilities)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PhoneToGameCommand.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PhoneToGameCommand.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    seqno = try codedInputStream.readInt32()

                case 16:
                    command = try codedInputStream.readInt32()

                case 24:
                    subject = try codedInputStream.readInt32()

                case 40:
                    f5 = try codedInputStream.readInt32()

                case 50:
                    f6 = try codedInputStream.readString()

                case 56:
                    f7 = try codedInputStream.readInt32()

                case 152:
                    playerId = try codedInputStream.readInt32()

                case 170:
                    let subBuilder:ZmlclientCapabilities.Builder = ZmlclientCapabilities.Builder()
                    if hasCapabilities {
                        try subBuilder.mergeFrom(other: capabilities)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    capabilities = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PhoneToGameCommand.Builder {
            let resultDecodedBuilder = PhoneToGameCommand.Builder()
            if let jsonValueSeqno = jsonMap["seqno"] as? Int {
                resultDecodedBuilder.seqno = Int32(jsonValueSeqno)
            } else if let jsonValueSeqno = jsonMap["seqno"] as? String {
                resultDecodedBuilder.seqno = Int32(jsonValueSeqno)!
            }
            if let jsonValueCommand = jsonMap["command"] as? Int {
                resultDecodedBuilder.command = Int32(jsonValueCommand)
            } else if let jsonValueCommand = jsonMap["command"] as? String {
                resultDecodedBuilder.command = Int32(jsonValueCommand)!
            }
            if let jsonValueSubject = jsonMap["subject"] as? Int {
                resultDecodedBuilder.subject = Int32(jsonValueSubject)
            } else if let jsonValueSubject = jsonMap["subject"] as? String {
                resultDecodedBuilder.subject = Int32(jsonValueSubject)!
            }
            if let jsonValueF5 = jsonMap["f5"] as? Int {
                resultDecodedBuilder.f5 = Int32(jsonValueF5)
            } else if let jsonValueF5 = jsonMap["f5"] as? String {
                resultDecodedBuilder.f5 = Int32(jsonValueF5)!
            }
            if let jsonValueF6 = jsonMap["f6"] as? String {
                resultDecodedBuilder.f6 = jsonValueF6
            }
            if let jsonValueF7 = jsonMap["f7"] as? Int {
                resultDecodedBuilder.f7 = Int32(jsonValueF7)
            } else if let jsonValueF7 = jsonMap["f7"] as? String {
                resultDecodedBuilder.f7 = Int32(jsonValueF7)!
            }
            if let jsonValuePlayerId = jsonMap["playerId"] as? Int {
                resultDecodedBuilder.playerId = Int32(jsonValuePlayerId)
            } else if let jsonValuePlayerId = jsonMap["playerId"] as? String {
                resultDecodedBuilder.playerId = Int32(jsonValuePlayerId)!
            }
            if let jsonValueCapabilities = jsonMap["capabilities"] as? Dictionary<String,Any> {
                resultDecodedBuilder.capabilities = try ZmlclientCapabilities.Builder.decodeToBuilder(jsonMap:jsonValueCapabilities).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> PhoneToGameCommand.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PhoneToGameCommand.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class PhoneToGame : GeneratedMessage {
    public typealias BuilderType = PhoneToGame.Builder

    public static func == (lhs: PhoneToGame, rhs: PhoneToGame) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasCommand == rhs.hasCommand) && (!lhs.hasCommand || lhs.command == rhs.command)
        fieldCheck = fieldCheck && (lhs.hasF10 == rhs.hasF10) && (!lhs.hasF10 || lhs.f10 == rhs.f10)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int32! = nil
    public fileprivate(set) var hasId:Bool = false
    public fileprivate(set) var command:PhoneToGameCommand!
    public fileprivate(set) var hasCommand:Bool = false
    public fileprivate(set) var f10:Int32! = nil
    public fileprivate(set) var hasF10:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:id)
        }
        if hasCommand {
            try codedOutputStream.writeMessage(fieldNumber: 2, value:command)
        }
        if hasF10 {
            try codedOutputStream.writeInt32(fieldNumber: 10, value:f10)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt32Size(fieldNumber: 1)
        }
        if hasCommand {
            if let varSizecommand = command?.computeMessageSize(fieldNumber: 2) {
                serialize_size += varSizecommand
            }
        }
        if hasF10 {
            serialize_size += f10.computeInt32Size(fieldNumber: 10)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> PhoneToGame.Builder {
        return PhoneToGame.classBuilder() as! PhoneToGame.Builder
    }
    public func getBuilder() -> PhoneToGame.Builder {
        return classBuilder() as! PhoneToGame.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PhoneToGame.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PhoneToGame.Builder()
    }
    public func toBuilder() throws -> PhoneToGame.Builder {
        return try PhoneToGame.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:PhoneToGame) throws -> PhoneToGame.Builder {
        return try PhoneToGame.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        guard isInitialized() else {
           return jsonMap
        }
        if hasId {
            jsonMap["id"] = Int(id)
        }
        if hasCommand {
            jsonMap["command"] = try command.encode()
        }
        if hasF10 {
            jsonMap["f10"] = Int(f10)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> PhoneToGame {
        return try PhoneToGame.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> PhoneToGame {
        return try PhoneToGame.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasCommand {
            output += "\(indent) command {\n"
            if let outDescCommand = command {
                output += try outDescCommand.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasF10 {
            output += "\(indent) f10: \(f10) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasCommand {
                if let hashValuecommand = command?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecommand
                }
            }
            if hasF10 {
                hashCode = (hashCode &* 31) &+ f10.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "PhoneToGame"
    }
    override public func className() -> String {
        return "PhoneToGame"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PhoneToGame = PhoneToGame()
        public func getMessage() -> PhoneToGame {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int32 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int32) -> PhoneToGame.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> PhoneToGame.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var command:PhoneToGameCommand! {
            get {
                if commandBuilder_ != nil {
                    builderResult.command = commandBuilder_.getMessage()
                }
                return builderResult.command
            }
            set (value) {
                builderResult.hasCommand = value != nil
                builderResult.command = value
            }
        }
        public var hasCommand:Bool {
            get {
                return builderResult.hasCommand
            }
        }
        fileprivate var commandBuilder_:PhoneToGameCommand.Builder! {
            didSet {
                builderResult.hasCommand = true
            }
        }
        public func getCommandBuilder() -> PhoneToGameCommand.Builder {
            if commandBuilder_ == nil {
                commandBuilder_ = PhoneToGameCommand.Builder()
                builderResult.command = commandBuilder_.getMessage()
                if command != nil {
                    try! commandBuilder_.mergeFrom(other: command)
                }
            }
            return commandBuilder_
        }
        @discardableResult
        public func setCommand(_ value:PhoneToGameCommand!) -> PhoneToGame.Builder {
            self.command = value
            return self
        }
        @discardableResult
        public func mergeCommand(value:PhoneToGameCommand) throws -> PhoneToGame.Builder {
            if builderResult.hasCommand {
                builderResult.command = try PhoneToGameCommand.builderWithPrototype(prototype:builderResult.command).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.command = value
            }
            builderResult.hasCommand = true
            return self
        }
        @discardableResult
        public func clearCommand() -> PhoneToGame.Builder {
            commandBuilder_ = nil
            builderResult.hasCommand = false
            builderResult.command = nil
            return self
        }
        public var f10:Int32 {
            get {
                return builderResult.f10
            }
            set (value) {
                builderResult.hasF10 = true
                builderResult.f10 = value
            }
        }
        public var hasF10:Bool {
            get {
                return builderResult.hasF10
            }
        }
        @discardableResult
        public func setF10(_ value:Int32) -> PhoneToGame.Builder {
            self.f10 = value
            return self
        }
        @discardableResult
        public func clearF10() -> PhoneToGame.Builder{
            builderResult.hasF10 = false
            builderResult.f10 = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> PhoneToGame.Builder {
            builderResult = PhoneToGame()
            return self
        }
        override public func clone() throws -> PhoneToGame.Builder {
            return try PhoneToGame.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> PhoneToGame {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> PhoneToGame {
            let returnMe:PhoneToGame = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:PhoneToGame) throws -> PhoneToGame.Builder {
            if other == PhoneToGame() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if (other.hasCommand) {
                try mergeCommand(value: other.command)
            }
            if other.hasF10 {
                f10 = other.f10
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PhoneToGame.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PhoneToGame.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt32()

                case 18:
                    let subBuilder:PhoneToGameCommand.Builder = PhoneToGameCommand.Builder()
                    if hasCommand {
                        try subBuilder.mergeFrom(other: command)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    command = subBuilder.buildPartial()

                case 80:
                    f10 = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PhoneToGame.Builder {
            let resultDecodedBuilder = PhoneToGame.Builder()
            if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int32(jsonValueId)
            } else if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int32(jsonValueId)!
            }
            if let jsonValueCommand = jsonMap["command"] as? Dictionary<String,Any> {
                resultDecodedBuilder.command = try PhoneToGameCommand.Builder.decodeToBuilder(jsonMap:jsonValueCommand).build()

            }
            if let jsonValueF10 = jsonMap["f10"] as? Int {
                resultDecodedBuilder.f10 = Int32(jsonValueF10)
            } else if let jsonValueF10 = jsonMap["f10"] as? String {
                resultDecodedBuilder.f10 = Int32(jsonValueF10)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> PhoneToGame.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PhoneToGame.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension PlayerState: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PlayerState> {
        var mergedArray = Array<PlayerState>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> PlayerState? {
        return try PlayerState.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> PlayerState {
        return try PlayerState.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PlayerState {
        return try PlayerState.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> PlayerState {
        return try PlayerState.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PlayerState {
        return try PlayerState.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> PlayerState {
        return try PlayerState.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PlayerState {
        return try PlayerState.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "worldTime": return self.worldTime
        case "distance": return self.distance
        case "roadTime": return self.roadTime
        case "laps": return self.laps
        case "speed": return self.speed
        case "roadPosition": return self.roadPosition
        case "cadenceUhz": return self.cadenceUhz
        case "heartrate": return self.heartrate
        case "power": return self.power
        case "heading": return self.heading
        case "lean": return self.lean
        case "climbing": return self.climbing
        case "time": return self.time
        case "f19": return self.f19
        case "f20": return self.f20
        case "progress": return self.progress
        case "customisationId": return self.customisationId
        case "justWatching": return self.justWatching
        case "calories": return self.calories
        case "x": return self.x
        case "altitude": return self.altitude
        case "y": return self.y
        case "watchingRiderId": return self.watchingRiderId
        case "groupId": return self.groupId
        case "sport": return self.sport
        default: return nil
        }
    }
}
extension PlayerState.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = PlayerState
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "worldTime": return self.worldTime
            case "distance": return self.distance
            case "roadTime": return self.roadTime
            case "laps": return self.laps
            case "speed": return self.speed
            case "roadPosition": return self.roadPosition
            case "cadenceUhz": return self.cadenceUhz
            case "heartrate": return self.heartrate
            case "power": return self.power
            case "heading": return self.heading
            case "lean": return self.lean
            case "climbing": return self.climbing
            case "time": return self.time
            case "f19": return self.f19
            case "f20": return self.f20
            case "progress": return self.progress
            case "customisationId": return self.customisationId
            case "justWatching": return self.justWatching
            case "calories": return self.calories
            case "x": return self.x
            case "altitude": return self.altitude
            case "y": return self.y
            case "watchingRiderId": return self.watchingRiderId
            case "groupId": return self.groupId
            case "sport": return self.sport
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.id = newSubscriptValue
            case "worldTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.worldTime = newSubscriptValue
            case "distance":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.distance = newSubscriptValue
            case "roadTime":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.roadTime = newSubscriptValue
            case "laps":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.laps = newSubscriptValue
            case "speed":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.speed = newSubscriptValue
            case "roadPosition":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.roadPosition = newSubscriptValue
            case "cadenceUhz":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.cadenceUhz = newSubscriptValue
            case "heartrate":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.heartrate = newSubscriptValue
            case "power":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.power = newSubscriptValue
            case "heading":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.heading = newSubscriptValue
            case "lean":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.lean = newSubscriptValue
            case "climbing":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.climbing = newSubscriptValue
            case "time":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.time = newSubscriptValue
            case "f19":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f19 = newSubscriptValue
            case "f20":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f20 = newSubscriptValue
            case "progress":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.progress = newSubscriptValue
            case "customisationId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.customisationId = newSubscriptValue
            case "justWatching":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.justWatching = newSubscriptValue
            case "calories":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.calories = newSubscriptValue
            case "x":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.x = newSubscriptValue
            case "altitude":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.altitude = newSubscriptValue
            case "y":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.y = newSubscriptValue
            case "watchingRiderId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.watchingRiderId = newSubscriptValue
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.groupId = newSubscriptValue
            case "sport":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.sport = newSubscriptValue
            default: return
            }
        }
    }
}
extension ClientToServer: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ClientToServer> {
        var mergedArray = Array<ClientToServer>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ClientToServer? {
        return try ClientToServer.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ClientToServer {
        return try ClientToServer.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ClientToServer {
        return try ClientToServer.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ClientToServer {
        return try ClientToServer.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ClientToServer {
        return try ClientToServer.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ClientToServer {
        return try ClientToServer.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ClientToServer {
        return try ClientToServer.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "connected": return self.connected
        case "riderId": return self.riderId
        case "worldTime": return self.worldTime
        case "state": return self.state
        case "seqno": return self.seqno
        case "tag8": return self.tag8
        case "tag9": return self.tag9
        case "lastUpdate": return self.lastUpdate
        case "tag11": return self.tag11
        case "lastPlayerUpdate": return self.lastPlayerUpdate
        default: return nil
        }
    }
}
extension ClientToServer.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ClientToServer
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "connected": return self.connected
            case "riderId": return self.riderId
            case "worldTime": return self.worldTime
            case "state": return self.state
            case "seqno": return self.seqno
            case "tag8": return self.tag8
            case "tag9": return self.tag9
            case "lastUpdate": return self.lastUpdate
            case "tag11": return self.tag11
            case "lastPlayerUpdate": return self.lastPlayerUpdate
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "connected":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.connected = newSubscriptValue
            case "riderId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.riderId = newSubscriptValue
            case "worldTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.worldTime = newSubscriptValue
            case "state":
                guard let newSubscriptValue = newSubscriptValue as? PlayerState else {
                    return
                }
                self.state = newSubscriptValue
            case "seqno":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.seqno = newSubscriptValue
            case "tag8":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.tag8 = newSubscriptValue
            case "tag9":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.tag9 = newSubscriptValue
            case "lastUpdate":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.lastUpdate = newSubscriptValue
            case "tag11":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.tag11 = newSubscriptValue
            case "lastPlayerUpdate":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.lastPlayerUpdate = newSubscriptValue
            default: return
            }
        }
    }
}
extension SegmentResult: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SegmentResult> {
        var mergedArray = Array<SegmentResult>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> SegmentResult? {
        return try SegmentResult.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> SegmentResult {
        return try SegmentResult.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SegmentResult {
        return try SegmentResult.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> SegmentResult {
        return try SegmentResult.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SegmentResult {
        return try SegmentResult.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> SegmentResult {
        return try SegmentResult.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SegmentResult {
        return try SegmentResult.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "riderId": return self.riderId
        case "eventSubgroupId": return self.eventSubgroupId
        case "firstName": return self.firstName
        case "lastName": return self.lastName
        case "finishTimeStr": return self.finishTimeStr
        case "elapsedMs": return self.elapsedMs
        case "powermeter": return self.powermeter
        case "weight": return self.weight
        case "power": return self.power
        case "heartrate": return self.heartrate
        default: return nil
        }
    }
}
extension SegmentResult.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = SegmentResult
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "riderId": return self.riderId
            case "eventSubgroupId": return self.eventSubgroupId
            case "firstName": return self.firstName
            case "lastName": return self.lastName
            case "finishTimeStr": return self.finishTimeStr
            case "elapsedMs": return self.elapsedMs
            case "powermeter": return self.powermeter
            case "weight": return self.weight
            case "power": return self.power
            case "heartrate": return self.heartrate
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "riderId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.riderId = newSubscriptValue
            case "eventSubgroupId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.eventSubgroupId = newSubscriptValue
            case "firstName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.firstName = newSubscriptValue
            case "lastName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.lastName = newSubscriptValue
            case "finishTimeStr":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.finishTimeStr = newSubscriptValue
            case "elapsedMs":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.elapsedMs = newSubscriptValue
            case "powermeter":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.powermeter = newSubscriptValue
            case "weight":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.weight = newSubscriptValue
            case "power":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.power = newSubscriptValue
            case "heartrate":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.heartrate = newSubscriptValue
            default: return
            }
        }
    }
}
extension SegmentResults: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SegmentResults> {
        var mergedArray = Array<SegmentResults>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> SegmentResults? {
        return try SegmentResults.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> SegmentResults {
        return try SegmentResults.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SegmentResults {
        return try SegmentResults.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> SegmentResults {
        return try SegmentResults.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SegmentResults {
        return try SegmentResults.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> SegmentResults {
        return try SegmentResults.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SegmentResults {
        return try SegmentResults.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "worldId": return self.worldId
        case "segmentId": return self.segmentId
        case "eventSubgroupId": return self.eventSubgroupId
        case "segmentResults": return self.segmentResults
        default: return nil
        }
    }
}
extension SegmentResults.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = SegmentResults
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "worldId": return self.worldId
            case "segmentId": return self.segmentId
            case "eventSubgroupId": return self.eventSubgroupId
            case "segmentResults": return self.segmentResults
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "worldId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.worldId = newSubscriptValue
            case "segmentId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.segmentId = newSubscriptValue
            case "eventSubgroupId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.eventSubgroupId = newSubscriptValue
            case "segmentResults":
                guard let newSubscriptValue = newSubscriptValue as? Array<SegmentResult> else {
                    return
                }
                self.segmentResults = newSubscriptValue
            default: return
            }
        }
    }
}
extension UnknownMessage1: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<UnknownMessage1> {
        var mergedArray = Array<UnknownMessage1>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> UnknownMessage1? {
        return try UnknownMessage1.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> UnknownMessage1 {
        return try UnknownMessage1.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> UnknownMessage1 {
        return try UnknownMessage1.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> UnknownMessage1 {
        return try UnknownMessage1.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> UnknownMessage1 {
        return try UnknownMessage1.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> UnknownMessage1 {
        return try UnknownMessage1.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UnknownMessage1 {
        return try UnknownMessage1.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension UnknownMessage1.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = UnknownMessage1
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension UnknownMessage: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<UnknownMessage> {
        var mergedArray = Array<UnknownMessage>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> UnknownMessage? {
        return try UnknownMessage.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> UnknownMessage {
        return try UnknownMessage.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> UnknownMessage {
        return try UnknownMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> UnknownMessage {
        return try UnknownMessage.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> UnknownMessage {
        return try UnknownMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> UnknownMessage {
        return try UnknownMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UnknownMessage {
        return try UnknownMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension UnknownMessage.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = UnknownMessage
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension ServerToClient: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ServerToClient> {
        var mergedArray = Array<ServerToClient>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ServerToClient? {
        return try ServerToClient.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ServerToClient {
        return try ServerToClient.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ServerToClient {
        return try ServerToClient.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ServerToClient {
        return try ServerToClient.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ServerToClient {
        return try ServerToClient.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ServerToClient {
        return try ServerToClient.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ServerToClient {
        return try ServerToClient.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tag1": return self.tag1
        case "riderId": return self.riderId
        case "worldTime": return self.worldTime
        case "seqno": return self.seqno
        case "playerStates": return self.playerStates
        case "playerUpdates": return self.playerUpdates
        case "tag11": return self.tag11
        case "tag17": return self.tag17
        case "numMsgs": return self.numMsgs
        case "msgnum": return self.msgnum
        default: return nil
        }
    }
}
extension ServerToClient.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ServerToClient
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tag1": return self.tag1
            case "riderId": return self.riderId
            case "worldTime": return self.worldTime
            case "seqno": return self.seqno
            case "playerStates": return self.playerStates
            case "playerUpdates": return self.playerUpdates
            case "tag11": return self.tag11
            case "tag17": return self.tag17
            case "numMsgs": return self.numMsgs
            case "msgnum": return self.msgnum
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tag1":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.tag1 = newSubscriptValue
            case "riderId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.riderId = newSubscriptValue
            case "worldTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.worldTime = newSubscriptValue
            case "seqno":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.seqno = newSubscriptValue
            case "playerStates":
                guard let newSubscriptValue = newSubscriptValue as? Array<PlayerState> else {
                    return
                }
                self.playerStates = newSubscriptValue
            case "playerUpdates":
                guard let newSubscriptValue = newSubscriptValue as? Array<UnknownMessage> else {
                    return
                }
                self.playerUpdates = newSubscriptValue
            case "tag11":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.tag11 = newSubscriptValue
            case "tag17":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.tag17 = newSubscriptValue
            case "numMsgs":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.numMsgs = newSubscriptValue
            case "msgnum":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.msgnum = newSubscriptValue
            default: return
            }
        }
    }
}
extension WorldAttributes: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<WorldAttributes> {
        var mergedArray = Array<WorldAttributes>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> WorldAttributes? {
        return try WorldAttributes.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> WorldAttributes {
        return try WorldAttributes.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> WorldAttributes {
        return try WorldAttributes.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> WorldAttributes {
        return try WorldAttributes.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> WorldAttributes {
        return try WorldAttributes.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> WorldAttributes {
        return try WorldAttributes.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> WorldAttributes {
        return try WorldAttributes.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "worldId": return self.worldId
        case "name": return self.name
        case "tag3": return self.tag3
        case "tag5": return self.tag5
        case "worldTime": return self.worldTime
        case "clockTime": return self.clockTime
        default: return nil
        }
    }
}
extension WorldAttributes.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = WorldAttributes
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "worldId": return self.worldId
            case "name": return self.name
            case "tag3": return self.tag3
            case "tag5": return self.tag5
            case "worldTime": return self.worldTime
            case "clockTime": return self.clockTime
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "worldId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.worldId = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "tag3":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.tag3 = newSubscriptValue
            case "tag5":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.tag5 = newSubscriptValue
            case "worldTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.worldTime = newSubscriptValue
            case "clockTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.clockTime = newSubscriptValue
            default: return
            }
        }
    }
}
extension WorldAttribute: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<WorldAttribute> {
        var mergedArray = Array<WorldAttribute>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> WorldAttribute? {
        return try WorldAttribute.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> WorldAttribute {
        return try WorldAttribute.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> WorldAttribute {
        return try WorldAttribute.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> WorldAttribute {
        return try WorldAttribute.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> WorldAttribute {
        return try WorldAttribute.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> WorldAttribute {
        return try WorldAttribute.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> WorldAttribute {
        return try WorldAttribute.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "worldTime": return self.worldTime
        default: return nil
        }
    }
}
extension WorldAttribute.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = WorldAttribute
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "worldTime": return self.worldTime
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "worldTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.worldTime = newSubscriptValue
            default: return
            }
        }
    }
}
extension EventSubgroupProtobuf: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<EventSubgroupProtobuf> {
        var mergedArray = Array<EventSubgroupProtobuf>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> EventSubgroupProtobuf? {
        return try EventSubgroupProtobuf.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> EventSubgroupProtobuf {
        return try EventSubgroupProtobuf.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> EventSubgroupProtobuf {
        return try EventSubgroupProtobuf.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> EventSubgroupProtobuf {
        return try EventSubgroupProtobuf.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> EventSubgroupProtobuf {
        return try EventSubgroupProtobuf.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> EventSubgroupProtobuf {
        return try EventSubgroupProtobuf.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EventSubgroupProtobuf {
        return try EventSubgroupProtobuf.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "name": return self.name
        case "rules": return self.rules
        case "route": return self.route
        case "laps": return self.laps
        case "startLocation": return self.startLocation
        case "label": return self.label
        case "paceType": return self.paceType
        case "jerseyHash": return self.jerseyHash
        default: return nil
        }
    }
}
extension EventSubgroupProtobuf.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = EventSubgroupProtobuf
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "name": return self.name
            case "rules": return self.rules
            case "route": return self.route
            case "laps": return self.laps
            case "startLocation": return self.startLocation
            case "label": return self.label
            case "paceType": return self.paceType
            case "jerseyHash": return self.jerseyHash
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.id = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "rules":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.rules = newSubscriptValue
            case "route":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.route = newSubscriptValue
            case "laps":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.laps = newSubscriptValue
            case "startLocation":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.startLocation = newSubscriptValue
            case "label":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.label = newSubscriptValue
            case "paceType":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.paceType = newSubscriptValue
            case "jerseyHash":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.jerseyHash = newSubscriptValue
            default: return
            }
        }
    }
}
extension RiderAttributes: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<RiderAttributes> {
        var mergedArray = Array<RiderAttributes>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> RiderAttributes? {
        return try RiderAttributes.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> RiderAttributes {
        return try RiderAttributes.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> RiderAttributes {
        return try RiderAttributes.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> RiderAttributes {
        return try RiderAttributes.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> RiderAttributes {
        return try RiderAttributes.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> RiderAttributes {
        return try RiderAttributes.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RiderAttributes {
        return try RiderAttributes.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "f2": return self.f2
        case "f3": return self.f3
        case "attributeMessage": return self.attributeMessage
        case "theirId": return self.theirId
        case "f13": return self.f13
        default: return nil
        }
    }
}
extension RiderAttributes.AttributeMessage: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<RiderAttributes.AttributeMessage> {
        var mergedArray = Array<RiderAttributes.AttributeMessage>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> RiderAttributes.AttributeMessage? {
        return try RiderAttributes.AttributeMessage.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> RiderAttributes.AttributeMessage {
        return try RiderAttributes.AttributeMessage.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> RiderAttributes.AttributeMessage {
        return try RiderAttributes.AttributeMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> RiderAttributes.AttributeMessage {
        return try RiderAttributes.AttributeMessage.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> RiderAttributes.AttributeMessage {
        return try RiderAttributes.AttributeMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> RiderAttributes.AttributeMessage {
        return try RiderAttributes.AttributeMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RiderAttributes.AttributeMessage {
        return try RiderAttributes.AttributeMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "myId": return self.myId
        case "theirId": return self.theirId
        case "firstName": return self.firstName
        case "lastName": return self.lastName
        case "countryCode": return self.countryCode
        default: return nil
        }
    }
}
extension RiderAttributes.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = RiderAttributes
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "f2": return self.f2
            case "f3": return self.f3
            case "attributeMessage": return self.attributeMessage
            case "theirId": return self.theirId
            case "f13": return self.f13
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "f2":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f2 = newSubscriptValue
            case "f3":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f3 = newSubscriptValue
            case "attributeMessage":
                guard let newSubscriptValue = newSubscriptValue as? RiderAttributes.AttributeMessage else {
                    return
                }
                self.attributeMessage = newSubscriptValue
            case "theirId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.theirId = newSubscriptValue
            case "f13":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f13 = newSubscriptValue
            default: return
            }
        }
    }
}
extension RiderAttributes.AttributeMessage.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = RiderAttributes.AttributeMessage
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "myId": return self.myId
            case "theirId": return self.theirId
            case "firstName": return self.firstName
            case "lastName": return self.lastName
            case "countryCode": return self.countryCode
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "myId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.myId = newSubscriptValue
            case "theirId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.theirId = newSubscriptValue
            case "firstName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.firstName = newSubscriptValue
            case "lastName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.lastName = newSubscriptValue
            case "countryCode":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.countryCode = newSubscriptValue
            default: return
            }
        }
    }
}
extension Profiles: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Profiles> {
        var mergedArray = Array<Profiles>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Profiles? {
        return try Profiles.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Profiles {
        return try Profiles.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Profiles {
        return try Profiles.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Profiles {
        return try Profiles.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Profiles {
        return try Profiles.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Profiles {
        return try Profiles.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Profiles {
        return try Profiles.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "profiles": return self.profiles
        default: return nil
        }
    }
}
extension Profiles.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Profiles
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "profiles": return self.profiles
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "profiles":
                guard let newSubscriptValue = newSubscriptValue as? Array<Profile> else {
                    return
                }
                self.profiles = newSubscriptValue
            default: return
            }
        }
    }
}
extension Profile: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Profile> {
        var mergedArray = Array<Profile>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Profile? {
        return try Profile.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Profile {
        return try Profile.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Profile {
        return try Profile.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Profile {
        return try Profile.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Profile {
        return try Profile.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Profile {
        return try Profile.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Profile {
        return try Profile.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "firstName": return self.firstName
        case "lastName": return self.lastName
        case "male": return self.male
        case "weight": return self.weight
        case "bodyType": return self.bodyType
        case "countryCode": return self.countryCode
        case "totalDistance": return self.totalDistance
        case "totalDistanceClimbed": return self.totalDistanceClimbed
        case "totalTimeInMinutes": return self.totalTimeInMinutes
        case "totalWattHours": return self.totalWattHours
        case "height": return self.height
        case "totalExperiencePoints": return self.totalExperiencePoints
        case "achievementLevel": return self.achievementLevel
        case "powerSource": return self.powerSource
        case "age": return self.age
        case "launchedGameClient": return self.launchedGameClient
        case "currentActivityId": return self.currentActivityId
        default: return nil
        }
    }
}
extension Profile.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Profile
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "firstName": return self.firstName
            case "lastName": return self.lastName
            case "male": return self.male
            case "weight": return self.weight
            case "bodyType": return self.bodyType
            case "countryCode": return self.countryCode
            case "totalDistance": return self.totalDistance
            case "totalDistanceClimbed": return self.totalDistanceClimbed
            case "totalTimeInMinutes": return self.totalTimeInMinutes
            case "totalWattHours": return self.totalWattHours
            case "height": return self.height
            case "totalExperiencePoints": return self.totalExperiencePoints
            case "achievementLevel": return self.achievementLevel
            case "powerSource": return self.powerSource
            case "age": return self.age
            case "launchedGameClient": return self.launchedGameClient
            case "currentActivityId": return self.currentActivityId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.id = newSubscriptValue
            case "firstName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.firstName = newSubscriptValue
            case "lastName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.lastName = newSubscriptValue
            case "male":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.male = newSubscriptValue
            case "weight":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.weight = newSubscriptValue
            case "bodyType":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.bodyType = newSubscriptValue
            case "countryCode":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.countryCode = newSubscriptValue
            case "totalDistance":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.totalDistance = newSubscriptValue
            case "totalDistanceClimbed":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.totalDistanceClimbed = newSubscriptValue
            case "totalTimeInMinutes":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.totalTimeInMinutes = newSubscriptValue
            case "totalWattHours":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.totalWattHours = newSubscriptValue
            case "height":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.height = newSubscriptValue
            case "totalExperiencePoints":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.totalExperiencePoints = newSubscriptValue
            case "achievementLevel":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.achievementLevel = newSubscriptValue
            case "powerSource":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.powerSource = newSubscriptValue
            case "age":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.age = newSubscriptValue
            case "launchedGameClient":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.launchedGameClient = newSubscriptValue
            case "currentActivityId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.currentActivityId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Vector3: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Vector3> {
        var mergedArray = Array<Vector3>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Vector3? {
        return try Vector3.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Vector3 {
        return try Vector3.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Vector3 {
        return try Vector3.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Vector3 {
        return try Vector3.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Vector3 {
        return try Vector3.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Vector3 {
        return try Vector3.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Vector3 {
        return try Vector3.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "x": return self.x
        case "y": return self.y
        case "z": return self.z
        default: return nil
        }
    }
}
extension Vector3.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Vector3
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "x": return self.x
            case "y": return self.y
            case "z": return self.z
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "x":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.x = newSubscriptValue
            case "y":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.y = newSubscriptValue
            case "z":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.z = newSubscriptValue
            default: return
            }
        }
    }
}
extension PlayerInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PlayerInfo> {
        var mergedArray = Array<PlayerInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> PlayerInfo? {
        return try PlayerInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> PlayerInfo {
        return try PlayerInfo.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PlayerInfo {
        return try PlayerInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> PlayerInfo {
        return try PlayerInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PlayerInfo {
        return try PlayerInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> PlayerInfo {
        return try PlayerInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PlayerInfo {
        return try PlayerInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "f2": return self.f2
        case "position": return self.position
        case "profile": return self.profile
        case "id2": return self.id2
        case "f7": return self.f7
        case "name": return self.name
        case "countryCode": return self.countryCode
        case "worldTime": return self.worldTime
        case "f16": return self.f16
        default: return nil
        }
    }
}
extension PlayerInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = PlayerInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "f2": return self.f2
            case "position": return self.position
            case "profile": return self.profile
            case "id2": return self.id2
            case "f7": return self.f7
            case "name": return self.name
            case "countryCode": return self.countryCode
            case "worldTime": return self.worldTime
            case "f16": return self.f16
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.id = newSubscriptValue
            case "f2":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f2 = newSubscriptValue
            case "position":
                guard let newSubscriptValue = newSubscriptValue as? Vector3 else {
                    return
                }
                self.position = newSubscriptValue
            case "profile":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.profile = newSubscriptValue
            case "id2":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.id2 = newSubscriptValue
            case "f7":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f7 = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "countryCode":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.countryCode = newSubscriptValue
            case "worldTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.worldTime = newSubscriptValue
            case "f16":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f16 = newSubscriptValue
            default: return
            }
        }
    }
}
extension Gtpc2161: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Gtpc2161> {
        var mergedArray = Array<Gtpc2161>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Gtpc2161? {
        return try Gtpc2161.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Gtpc2161 {
        return try Gtpc2161.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Gtpc2161 {
        return try Gtpc2161.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Gtpc2161 {
        return try Gtpc2161.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc2161 {
        return try Gtpc2161.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Gtpc2161 {
        return try Gtpc2161.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc2161 {
        return try Gtpc2161.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "seqno": return self.seqno
        case "playerInfos": return self.playerInfos
        case "f3": return self.f3
        default: return nil
        }
    }
}
extension Gtpc2161.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Gtpc2161
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "seqno": return self.seqno
            case "playerInfos": return self.playerInfos
            case "f3": return self.f3
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "seqno":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.seqno = newSubscriptValue
            case "playerInfos":
                guard let newSubscriptValue = newSubscriptValue as? Array<PlayerInfo> else {
                    return
                }
                self.playerInfos = newSubscriptValue
            case "f3":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f3 = newSubscriptValue
            default: return
            }
        }
    }
}
extension Gtpc216: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Gtpc216> {
        var mergedArray = Array<Gtpc216>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Gtpc216? {
        return try Gtpc216.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Gtpc216 {
        return try Gtpc216.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Gtpc216 {
        return try Gtpc216.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Gtpc216 {
        return try Gtpc216.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc216 {
        return try Gtpc216.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Gtpc216 {
        return try Gtpc216.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc216 {
        return try Gtpc216.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "gtpc2161": return self.gtpc2161
        default: return nil
        }
    }
}
extension Gtpc216.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Gtpc216
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "gtpc2161": return self.gtpc2161
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "gtpc2161":
                guard let newSubscriptValue = newSubscriptValue as? Array<Gtpc2161> else {
                    return
                }
                self.gtpc2161 = newSubscriptValue
            default: return
            }
        }
    }
}
extension Gtpc214: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Gtpc214> {
        var mergedArray = Array<Gtpc214>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Gtpc214? {
        return try Gtpc214.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Gtpc214 {
        return try Gtpc214.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Gtpc214 {
        return try Gtpc214.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Gtpc214 {
        return try Gtpc214.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc214 {
        return try Gtpc214.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Gtpc214 {
        return try Gtpc214.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc214 {
        return try Gtpc214.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "f1": return self.f1
        case "f6": return self.f6
        case "f7": return self.f7
        case "f8": return self.f8
        default: return nil
        }
    }
}
extension Gtpc214.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Gtpc214
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "f1": return self.f1
            case "f6": return self.f6
            case "f7": return self.f7
            case "f8": return self.f8
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "f1":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f1 = newSubscriptValue
            case "f6":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.f6 = newSubscriptValue
            case "f7":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f7 = newSubscriptValue
            case "f8":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f8 = newSubscriptValue
            default: return
            }
        }
    }
}
extension Gtpc218: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Gtpc218> {
        var mergedArray = Array<Gtpc218>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Gtpc218? {
        return try Gtpc218.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Gtpc218 {
        return try Gtpc218.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Gtpc218 {
        return try Gtpc218.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Gtpc218 {
        return try Gtpc218.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc218 {
        return try Gtpc218.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Gtpc218 {
        return try Gtpc218.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc218 {
        return try Gtpc218.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "f1": return self.f1
        case "f2": return self.f2
        default: return nil
        }
    }
}
extension Gtpc218.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Gtpc218
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "f1": return self.f1
            case "f2": return self.f2
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "f1":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f1 = newSubscriptValue
            case "f2":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f2 = newSubscriptValue
            default: return
            }
        }
    }
}
extension Gtpc21: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Gtpc21> {
        var mergedArray = Array<Gtpc21>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Gtpc21? {
        return try Gtpc21.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Gtpc21 {
        return try Gtpc21.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Gtpc21 {
        return try Gtpc21.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Gtpc21 {
        return try Gtpc21.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc21 {
        return try Gtpc21.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Gtpc21 {
        return try Gtpc21.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Gtpc21 {
        return try Gtpc21.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "f1": return self.f1
        case "gtpc214": return self.gtpc214
        case "gtpc216": return self.gtpc216
        case "gtpc218": return self.gtpc218
        default: return nil
        }
    }
}
extension Gtpc21.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Gtpc21
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "f1": return self.f1
            case "gtpc214": return self.gtpc214
            case "gtpc216": return self.gtpc216
            case "gtpc218": return self.gtpc218
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "f1":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f1 = newSubscriptValue
            case "gtpc214":
                guard let newSubscriptValue = newSubscriptValue as? Gtpc214 else {
                    return
                }
                self.gtpc214 = newSubscriptValue
            case "gtpc216":
                guard let newSubscriptValue = newSubscriptValue as? Gtpc216 else {
                    return
                }
                self.gtpc216 = newSubscriptValue
            case "gtpc218":
                guard let newSubscriptValue = newSubscriptValue as? Gtpc218 else {
                    return
                }
                self.gtpc218 = newSubscriptValue
            default: return
            }
        }
    }
}
extension GameToPhoneCommand: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GameToPhoneCommand> {
        var mergedArray = Array<GameToPhoneCommand>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GameToPhoneCommand? {
        return try GameToPhoneCommand.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GameToPhoneCommand {
        return try GameToPhoneCommand.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GameToPhoneCommand {
        return try GameToPhoneCommand.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GameToPhoneCommand {
        return try GameToPhoneCommand.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GameToPhoneCommand {
        return try GameToPhoneCommand.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GameToPhoneCommand {
        return try GameToPhoneCommand.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GameToPhoneCommand {
        return try GameToPhoneCommand.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "seqno": return self.seqno
        case "f2": return self.f2
        case "gtpc21": return self.gtpc21
        default: return nil
        }
    }
}
extension GameToPhoneCommand.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = GameToPhoneCommand
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "seqno": return self.seqno
            case "f2": return self.f2
            case "gtpc21": return self.gtpc21
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "seqno":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.seqno = newSubscriptValue
            case "f2":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f2 = newSubscriptValue
            case "gtpc21":
                guard let newSubscriptValue = newSubscriptValue as? Gtpc21 else {
                    return
                }
                self.gtpc21 = newSubscriptValue
            default: return
            }
        }
    }
}
extension GameToPhone: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GameToPhone> {
        var mergedArray = Array<GameToPhone>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GameToPhone? {
        return try GameToPhone.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GameToPhone {
        return try GameToPhone.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GameToPhone {
        return try GameToPhone.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GameToPhone {
        return try GameToPhone.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GameToPhone {
        return try GameToPhone.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GameToPhone {
        return try GameToPhone.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GameToPhone {
        return try GameToPhone.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "f1": return self.f1
        case "f2": return self.f2
        case "id": return self.id
        case "f4": return self.f4
        case "f6": return self.f6
        case "f7": return self.f7
        case "commands": return self.commands
        default: return nil
        }
    }
}
extension GameToPhone.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = GameToPhone
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "f1": return self.f1
            case "f2": return self.f2
            case "id": return self.id
            case "f4": return self.f4
            case "f6": return self.f6
            case "f7": return self.f7
            case "commands": return self.commands
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "f1":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f1 = newSubscriptValue
            case "f2":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f2 = newSubscriptValue
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.id = newSubscriptValue
            case "f4":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f4 = newSubscriptValue
            case "f6":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f6 = newSubscriptValue
            case "f7":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f7 = newSubscriptValue
            case "commands":
                guard let newSubscriptValue = newSubscriptValue as? Array<GameToPhoneCommand> else {
                    return
                }
                self.commands = newSubscriptValue
            default: return
            }
        }
    }
}
extension ZmlclientInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ZmlclientInfo> {
        var mergedArray = Array<ZmlclientInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ZmlclientInfo? {
        return try ZmlclientInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ZmlclientInfo {
        return try ZmlclientInfo.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ZmlclientInfo {
        return try ZmlclientInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ZmlclientInfo {
        return try ZmlclientInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ZmlclientInfo {
        return try ZmlclientInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ZmlclientInfo {
        return try ZmlclientInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ZmlclientInfo {
        return try ZmlclientInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "appVersion": return self.appVersion
        case "systemOsversion": return self.systemOsversion
        case "systemOs": return self.systemOs
        case "systemHardware": return self.systemHardware
        default: return nil
        }
    }
}
extension ZmlclientInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ZmlclientInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "appVersion": return self.appVersion
            case "systemOsversion": return self.systemOsversion
            case "systemOs": return self.systemOs
            case "systemHardware": return self.systemHardware
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "appVersion":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.appVersion = newSubscriptValue
            case "systemOsversion":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.systemOsversion = newSubscriptValue
            case "systemOs":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.systemOs = newSubscriptValue
            case "systemHardware":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.systemHardware = newSubscriptValue
            default: return
            }
        }
    }
}
extension ZmlclientCapabilities: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ZmlclientCapabilities> {
        var mergedArray = Array<ZmlclientCapabilities>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ZmlclientCapabilities? {
        return try ZmlclientCapabilities.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ZmlclientCapabilities {
        return try ZmlclientCapabilities.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ZmlclientCapabilities {
        return try ZmlclientCapabilities.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ZmlclientCapabilities {
        return try ZmlclientCapabilities.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ZmlclientCapabilities {
        return try ZmlclientCapabilities.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ZmlclientCapabilities {
        return try ZmlclientCapabilities.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ZmlclientCapabilities {
        return try ZmlclientCapabilities.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "f1": return self.f1
        case "info": return self.info
        default: return nil
        }
    }
}
extension ZmlclientCapabilities.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ZmlclientCapabilities
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "f1": return self.f1
            case "info": return self.info
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "f1":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f1 = newSubscriptValue
            case "info":
                guard let newSubscriptValue = newSubscriptValue as? ZmlclientInfo else {
                    return
                }
                self.info = newSubscriptValue
            default: return
            }
        }
    }
}
extension PhoneToGameCommand: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PhoneToGameCommand> {
        var mergedArray = Array<PhoneToGameCommand>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> PhoneToGameCommand? {
        return try PhoneToGameCommand.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> PhoneToGameCommand {
        return try PhoneToGameCommand.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PhoneToGameCommand {
        return try PhoneToGameCommand.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> PhoneToGameCommand {
        return try PhoneToGameCommand.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PhoneToGameCommand {
        return try PhoneToGameCommand.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> PhoneToGameCommand {
        return try PhoneToGameCommand.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PhoneToGameCommand {
        return try PhoneToGameCommand.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "seqno": return self.seqno
        case "command": return self.command
        case "subject": return self.subject
        case "f5": return self.f5
        case "f6": return self.f6
        case "f7": return self.f7
        case "playerId": return self.playerId
        case "capabilities": return self.capabilities
        default: return nil
        }
    }
}
extension PhoneToGameCommand.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = PhoneToGameCommand
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "seqno": return self.seqno
            case "command": return self.command
            case "subject": return self.subject
            case "f5": return self.f5
            case "f6": return self.f6
            case "f7": return self.f7
            case "playerId": return self.playerId
            case "capabilities": return self.capabilities
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "seqno":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.seqno = newSubscriptValue
            case "command":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.command = newSubscriptValue
            case "subject":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.subject = newSubscriptValue
            case "f5":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f5 = newSubscriptValue
            case "f6":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.f6 = newSubscriptValue
            case "f7":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f7 = newSubscriptValue
            case "playerId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.playerId = newSubscriptValue
            case "capabilities":
                guard let newSubscriptValue = newSubscriptValue as? ZmlclientCapabilities else {
                    return
                }
                self.capabilities = newSubscriptValue
            default: return
            }
        }
    }
}
extension PhoneToGame: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PhoneToGame> {
        var mergedArray = Array<PhoneToGame>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> PhoneToGame? {
        return try PhoneToGame.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> PhoneToGame {
        return try PhoneToGame.Builder().mergeFrom(data: data, extensionRegistry:ZwiftMessagesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PhoneToGame {
        return try PhoneToGame.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> PhoneToGame {
        return try PhoneToGame.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PhoneToGame {
        return try PhoneToGame.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> PhoneToGame {
        return try PhoneToGame.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PhoneToGame {
        return try PhoneToGame.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "command": return self.command
        case "f10": return self.f10
        default: return nil
        }
    }
}
extension PhoneToGame.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = PhoneToGame
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "command": return self.command
            case "f10": return self.f10
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.id = newSubscriptValue
            case "command":
                guard let newSubscriptValue = newSubscriptValue as? PhoneToGameCommand else {
                    return
                }
                self.command = newSubscriptValue
            case "f10":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.f10 = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
